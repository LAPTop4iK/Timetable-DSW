// ===== FILE: Timetable DSW/Services/Ads/AdCoordinator.swift =====
import Combine
import Foundation
import UIKit

protocol AdCoordinator {
    func loadAd(type: AdType) async throws
    func showAd(type: AdType) async throws
    func isAdReady(type: AdType) -> Bool
    func isAdDisabled() -> Bool
    var rewardPublisher: AnyPublisher<Bool, Never> { get }

    // View factories
    func makeBannerView(width: CGFloat) -> UIView
    func makeNativeAdView() -> UIView

    // Utilities
    func presentAdInspector() async
    func setTestDevices(_ deviceIDs: [String])
}

// ===== FILE: Timetable DSW/Services/Ads/AdEligibilityService.swift =====
protocol AdEligibilityService {
    var canShowAds: Bool { get }
    func checkEligibility() throws
}

// ===== FILE: Timetable DSW/Services/Ads/AdError.swift =====
import Foundation

enum AdError: Error, LocalizedError {
    case notLoaded
    case failedToLoad(Error)
    case failedToPresent(Error)
    case premiumUser
    case adsDisabled
    case noReward
    case timeout
    
    var errorDescription: String? {
        switch self {
        case .notLoaded: return "Ad not loaded yet"
        case .failedToLoad(let error): return "Failed to load: \(error.localizedDescription)"
        case .failedToPresent(let error): return "Failed to present: \(error.localizedDescription)"
        case .premiumUser: return "Ads disabled for premium users"
        case .adsDisabled: return "Ads are currently disabled"
        case .noReward: return "Ad closed before reward"
        case .timeout: return "Operation timeout"
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdLoadingView.swift =====
import SwiftUI

struct AdLoadingView: View {
    let adType: AdType
    let coordinator: AdCoordinator?
    @State private var isLoading = false
    @State private var error: Error?
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView("Loading ad...")
            } else if let error = error {
                VStack(spacing: 8) {
                    Text("Failed to load ad")
                        .font(.caption)
                        .foregroundColor(.red)
                    Button("Retry") {
                        Task { await loadAd() }
                    }
                    .font(.caption)
                }
            } else {
                EmptyView()
            }
        }
        .task {
            await loadAd()
        }
    }
    
    private func loadAd() async {
        guard let coordinator = coordinator else { return }
        isLoading = true
        error = nil
        
        do {
            try await coordinator.loadAd(type: adType)
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdMobCoordinator.swift =====
import Foundation
import Combine
import GoogleMobileAds
import UIKit
import AppTrackingTransparency

@MainActor
final class AdMobCoordinator: AdCoordinator {

    // Dependencies
    private let eligibilityService: AdEligibilityService
    private let viewControllerProvider: ViewControllerProvider
    private let configuration: AdUnitIDsConfiguration

    // Providers
    private var interstitialProvider: InterstitialAdProvider?
    private var rewardedProvider: RewardedAdProvider?
    private var rewardedInterstitialProvider: RewardedInterstitialAdProvider?
    private var appOpenProvider: AppOpenAdProvider?
    private var nativeProvider: NativeAdProvider?

    // Presentation gate для избежания конфликтов
    private var isPresenting = false

    // Reward publisher объединяет все rewarded провайдеры
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }

    init(
        eligibilityService: AdEligibilityService,
        viewControllerProvider: ViewControllerProvider,
        configuration: AdUnitIDsConfiguration
    ) {
        self.eligibilityService = eligibilityService
        self.viewControllerProvider = viewControllerProvider
        self.configuration = configuration

        MobileAds.shared.start()

        Task {
            await ATTrackingManager.requestTrackingAuthorization()
        }
    }

    // MARK: - Public Methods

    func isAdDisabled() -> Bool {
        !eligibilityService.canShowAds
    }

    func loadAd(type: AdType) async throws {
        try eligibilityService.checkEligibility()

        switch type {
        case .interstitial:
            let provider = InterstitialAdProvider(adUnitID: configuration.interstitial)
            try await provider.load()
            interstitialProvider = provider

        case .rewarded:
            let provider = RewardedAdProvider(adUnitID: configuration.rewarded)
            try await provider.load()
            setupRewardPublisher(for: provider)
            rewardedProvider = provider

        case .rewardedInterstitial:
            let provider = RewardedInterstitialAdProvider(adUnitID: configuration.rewardedInterstitial)
            try await provider.load()
            setupRewardPublisher(for: provider)
            rewardedInterstitialProvider = provider

        case .appOpen:
            let provider = AppOpenAdProvider(adUnitID: configuration.appOpen)
            try await provider.load()
            appOpenProvider = provider

        case .native:
            let provider = NativeAdProvider(
                adUnitID: configuration.native,
                viewControllerProvider: viewControllerProvider
            )
            try await provider.load()
            nativeProvider = provider

        case .banner:
            // Banner не требует предзагрузки
            break
        }
    }

    func showAd(type: AdType) async throws {
        try eligibilityService.checkEligibility()

        guard !isPresenting else {
            throw AdError.failedToPresent(NSError(
                domain: "AdCoordinator",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Another ad is currently presenting"]
            ))
        }

        isPresenting = true
        defer { isPresenting = false }

        let viewController = try await viewControllerProvider.acquirePresentingViewController(timeout: 2.0)

        switch type {
        case .interstitial:
            guard let provider = interstitialProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .rewarded:
            guard let provider = rewardedProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .rewardedInterstitial:
            guard let provider = rewardedInterstitialProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .appOpen:
            guard let provider = appOpenProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .banner, .native:
            // View-based ads не показываются через showAd
            break
        }
    }

    func isAdReady(type: AdType) -> Bool {
        guard eligibilityService.canShowAds else { return false }

        switch type {
        case .interstitial:
            return interstitialProvider?.isReady ?? false
        case .rewarded:
            return rewardedProvider?.isReady ?? false
        case .rewardedInterstitial:
            return rewardedInterstitialProvider?.isReady ?? false
        case .appOpen:
            return appOpenProvider?.isReady ?? false
        case .native:
            return nativeProvider?.isReady ?? false
        case .banner:
            return true
        }
    }

    // MARK: - View Factories

    func makeBannerView(width: CGFloat) -> UIView {
        // Создаем provider без rootViewController
        // Provider получит его сам когда понадобится
        let provider = BannerAdProvider(
            configuration: BannerAdConfiguration(
                adUnitID: configuration.banner,
                width: width
            ),
            viewControllerProvider: viewControllerProvider
        )
        return provider.createView()
    }

    func makeNativeAdView() -> UIView {
        if let provider = nativeProvider {
            return provider.createView()
        }

        // Создаем новый провайдер без rootViewController
        let provider = NativeAdProvider(
            adUnitID: configuration.native,
            viewControllerProvider: viewControllerProvider
        )
        nativeProvider = provider
        return provider.createView()
    }

    // MARK: - Utilities

    func presentAdInspector() async {
        guard let rootVC = await viewControllerProvider.getRootViewController() else { return }
        MobileAds.shared.presentAdInspector(from: rootVC) { error in
            if let error = error {
                print("[AdInspector] Error: \(error)")
            }
        }
    }

    func setTestDevices(_ deviceIDs: [String]) {
        MobileAds.shared.requestConfiguration.testDeviceIdentifiers = deviceIDs
    }

    // MARK: - Private Helpers

    private func setupRewardPublisher(for provider: RewardableAdProvider) {
        provider.rewardPublisher
            .sink { [weak self] earned in
                self?.rewardSubject.send(earned)
            }
            .store(in: &cancellables)
    }

    private var cancellables = Set<AnyCancellable>()
}

// MARK: - Dependency Injection Helpers

extension AdMobCoordinator {
    static func makeForProduction(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) -> AdMobCoordinator {
        let eligibility = DefaultAdEligibilityService(
            featureFlagService: featureFlagService,
            appStateService: appStateService
        )
        let vcProvider = DefaultViewControllerProvider()

        #if DEBUG
        let config = AdUnitIDsConfiguration.test
        #else
        let config = AdUnitIDsConfiguration.production
        #endif

        return AdMobCoordinator(
            eligibilityService: eligibility,
            viewControllerProvider: vcProvider,
            configuration: config
        )
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdPreloader.swift =====
import SwiftUI

struct AdPreloader: ViewModifier {
    let types: [AdType]
    let coordinator: AdCoordinator?

    func body(content: Content) -> some View {
        content
            .task {
                guard let coordinator = coordinator, !coordinator.isAdDisabled() else { return }

                for type in types {
                    try? await coordinator.loadAd(type: type)
                }
            }
    }
}

extension View {
    func preloadAds(_ types: AdType..., coordinator: AdCoordinator?) -> some View {
        modifier(AdPreloader(types: types, coordinator: coordinator))
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdProvider.swift =====
import UIKit.UIViewController
import Combine

protocol AdProvider {
    associatedtype AdObject

    var adType: AdType { get }
    var isReady: Bool { get }

    func load() async throws
    func reset()
}

protocol PresentableAdProvider: AdProvider {
    func present(from viewController: UIViewController) async throws
}

protocol RewardableAdProvider: PresentableAdProvider {
    var rewardPublisher: AnyPublisher<Bool, Never> { get }
}

protocol ViewAdProvider: AdProvider {
    associatedtype ViewType
    func createView() -> ViewType
}

// ===== FILE: Timetable DSW/Services/Ads/AdType.swift =====
enum AdType {
    case banner
    case interstitial
    case rewarded
    case rewardedInterstitial
    case native
    case appOpen
}

// ===== FILE: Timetable DSW/Services/Ads/AdUnitIDsConfiguration.swift =====
struct AdUnitIDsConfiguration {
    let rewarded: String
    let interstitial: String
    let banner: String
    let rewardedInterstitial: String
    let appOpen: String
    let native: String

    static let test = AdUnitIDsConfiguration(
        rewarded: "ca-app-pub-3940256099942544/1712485313",
        interstitial: "ca-app-pub-3940256099942544/4411468910",
        banner: "ca-app-pub-3940256099942544/2934735716",
        rewardedInterstitial: "ca-app-pub-3940256099942544/6978759866",
        appOpen: "ca-app-pub-3940256099942544/5662855259",
        native: "ca-app-pub-3940256099942544/3986624511"
    )

    static let production = AdUnitIDsConfiguration(
        rewarded: "YOUR_REWARDED_AD_UNIT_ID",
        interstitial: "YOUR_INTERSTITIAL_AD_UNIT_ID",
        banner: "YOUR_BANNER_AD_UNIT_ID",
        rewardedInterstitial: "YOUR_REWARDED_INTERSTITIAL_AD_UNIT_ID",
        appOpen: "YOUR_APP_OPEN_AD_UNIT_ID",
        native: "YOUR_NATIVE_AD_UNIT_ID"
    )
}

// ===== FILE: Timetable DSW/Services/Ads/AdaptiveBannerView.swift =====
import SwiftUI
import GoogleMobileAds

struct AdaptiveBannerView: View {
    @Environment(\.adCoordinator) private var coordinator
    @State private var bannerHeight: CGFloat = 50

    var body: some View {
        if coordinator?.isAdDisabled() ?? false {
            EmptyView()
        } else {
            GeometryReader { geometry in
                BannerViewRepresentable(
                    coordinator: coordinator,
                    availableWidth: geometry.size.width,
                    onHeightChange: { newHeight in
                        bannerHeight = newHeight
                    }
                )
            }
            .frame(height: bannerHeight)
        }
    }
}

private struct BannerViewRepresentable: UIViewRepresentable {
    let coordinator: AdCoordinator?
    let availableWidth: CGFloat
    let onHeightChange: (CGFloat) -> Void

    func makeUIView(context: Context) -> UIView {
        let container = UIView()
        container.backgroundColor = .clear
        return container
    }

    func updateUIView(_ container: UIView, context: Context) {
        // Пересоздаем баннер только если ширина изменилась значительно
        let currentWidth = container.subviews.first?.frame.width ?? 0
        let widthDifference = abs(currentWidth - availableWidth)

        // Пересоздаем только если разница больше 10pt
        guard widthDifference > 10 || container.subviews.isEmpty else {
            return
        }

        container.subviews.forEach { $0.removeFromSuperview() }

        guard let coordinator = coordinator, availableWidth > 0 else { return }

        let bannerView = coordinator.makeBannerView(width: availableWidth)
        bannerView.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(bannerView)

        NSLayoutConstraint.activate([
            bannerView.centerXAnchor.constraint(equalTo: container.centerXAnchor),
            bannerView.centerYAnchor.constraint(equalTo: container.centerYAnchor),
            bannerView.widthAnchor.constraint(lessThanOrEqualTo: container.widthAnchor)
        ])

        // Получаем точную высоту баннера после layout
        DispatchQueue.main.async {
            let adSize = currentOrientationAnchoredAdaptiveBanner(width: availableWidth)
            let height = adSize.size.height
            if height > 0 {
                onHeightChange(height)
            }
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AppOpenAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class AppOpenAdProvider: NSObject, PresentableAdProvider {
    typealias AdObject = AppOpenAd
    
    let adType: AdType = .appOpen
    private let adUnitID: String
    private var ad: AppOpenAd?
    private var loadTime: Date?
    private var lastShownAt: Date?
    private let expirationInterval: TimeInterval = 30 * 60 // 30 минут
    private let cooldownInterval: TimeInterval = 60 // 1 минута
    
    var isReady: Bool {
        guard let loadTime = loadTime, ad != nil else { return false }
        return Date().timeIntervalSince(loadTime) < expirationInterval
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        let loadedAd = try await AppOpenAd.load(with: adUnitID, request: Request())
        ad = loadedAd
        loadTime = Date()
        loadedAd.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard isReady, let ad = ad else { throw AdError.notLoaded }
        
        // Cooldown check
        if let last = lastShownAt, Date().timeIntervalSince(last) < cooldownInterval {
            throw AdError.failedToPresent(NSError(
                domain: "AppOpenAd",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Cooldown period"]
            ))
        }
        
        ad.present(from: viewController)
        lastShownAt = Date()
    }
    
    func reset() {
        ad = nil
        loadTime = nil
    }
}

extension AppOpenAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { await reset() }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { await reset() }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/BannerAdConfiguration.swift =====
import GoogleMobileAds

struct BannerAdConfiguration {
    let adUnitID: String
    let width: CGFloat

    var adSize: AdSize {
        currentOrientationAnchoredAdaptiveBanner(width: width)
    }
}

// ===== FILE: Timetable DSW/Services/Ads/BannerAdProvider.swift =====
import GoogleMobileAds
import UIKit
import Combine

@MainActor
final class BannerAdProvider: NSObject, ViewAdProvider {
    typealias AdObject = BannerView
    typealias ViewType = UIView

    let adType: AdType = .banner
    private let configuration: BannerAdConfiguration
    private let viewControllerProvider: ViewControllerProvider

    var isReady: Bool { true } // Banner всегда ready, загружается при создании

    init(configuration: BannerAdConfiguration, viewControllerProvider: ViewControllerProvider) {
        self.configuration = configuration
        self.viewControllerProvider = viewControllerProvider
    }

    func load() async throws {
        // Banner загружается при создании view
    }

    func createView() -> UIView {
        let bannerView = BannerView(adSize: configuration.adSize)
        bannerView.adUnitID = configuration.adUnitID
        bannerView.delegate = self
        bannerView.translatesAutoresizingMaskIntoConstraints = false

        // Получаем rootViewController асинхронно
        Task { @MainActor in
            bannerView.rootViewController = await viewControllerProvider.getTopMostViewController()
            // Загружаем после получения VC
            bannerView.load(Request())
        }

        return bannerView
    }

    func reset() {
        // Banner не требует reset
    }
}

extension BannerAdProvider: BannerViewDelegate {
    nonisolated func bannerViewDidReceiveAd(_ bannerView: BannerView) {
        print("[Banner] Ad received")
    }

    nonisolated func bannerView(_ bannerView: BannerView, didFailToReceiveAdWithError error: Error) {
        print("[Banner] Failed to receive ad: \(error)")
    }
}

// ===== FILE: Timetable DSW/Services/Ads/CompactBannerAd.swift =====
import SwiftUI

struct CompactBannerAd: View {
    var body: some View {
        AdaptiveBannerView()
            .background(Color(uiColor: .systemBackground))
            .cornerRadius(8)
            .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
    }
}

struct CardStyleNativeAd: View {
    var body: some View {
        NativeAdViewSui()
            .padding(.horizontal, 16)
            .background(Color(uiColor: .systemBackground))
            .cornerRadius(12)
            .shadow(color: .black.opacity(0.08), radius: 8, x: 0, y: 4)
    }
}

// ===== FILE: Timetable DSW/Services/Ads/DefaultAdEligibilityService.swift =====
final class DefaultAdEligibilityService: AdEligibilityService {
    private let featureFlagService: FeatureFlagService
    private let appStateService: AppStateService
    
    var canShowAds: Bool {
        !appStateService.isPremium && featureFlagService.isEnabled(.showAds)
    }
    
    init(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) {
        self.featureFlagService = featureFlagService
        self.appStateService = appStateService
    }
    
    func checkEligibility() throws {
        if appStateService.isPremium {
            throw AdError.premiumUser
        }
        if !featureFlagService.isEnabled(.showAds) {
            throw AdError.adsDisabled
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/DefaultViewControllerProvider.swift =====
import UIKit

@MainActor
final class DefaultViewControllerProvider: ViewControllerProvider {
    func getRootViewController() async -> UIViewController? {
        UIApplication.shared.connectedScenes
            .compactMap { $0 as? UIWindowScene }
            .first(where: { $0.activationState == .foregroundActive })?
            .windows
            .first(where: { $0.isKeyWindow })?
            .rootViewController
    }
    
    func getTopMostViewController() async -> UIViewController? {
        guard let root = await getRootViewController() else { return nil }
        
        var top = root
        while true {
            if let presented = top.presentedViewController, !presented.isBeingDismissed {
                top = presented
            } else if let nav = top as? UINavigationController, let visible = nav.visibleViewController {
                top = visible
            } else if let tab = top as? UITabBarController, let selected = tab.selectedViewController {
                top = selected
            } else if let split = top as? UISplitViewController, let last = split.viewControllers.last {
                top = last
            } else {
                break
            }
        }
        return top
    }
    
    func acquirePresentingViewController(timeout: TimeInterval = 2.0) async throws -> UIViewController {
        let start = Date()
        while Date().timeIntervalSince(start) < timeout {
            if let vc = await getTopMostViewController(),
               vc.presentedViewController == nil,
               !vc.isBeingPresented,
               !vc.isBeingDismissed,
               vc.view.window != nil {
                return vc
            }
            try? await Task.sleep(nanoseconds: 100_000_000)
        }
        throw AdError.timeout
    }
}

// ===== FILE: Timetable DSW/Services/Ads/InterstitialAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class InterstitialAdProvider: NSObject, PresentableAdProvider {
    typealias AdObject = InterstitialAd
    
    let adType: AdType = .interstitial
    private let adUnitID: String
    private var ad: InterstitialAd?
    
    var isReady: Bool { ad != nil }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            InterstitialAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        ad.present(from: viewController)
    }
    
    func reset() {
        ad = nil
    }
}

extension InterstitialAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { await reset() }
    }

    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { await reset() }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/NativeAdContainerView.swift =====
import UIKit
import GoogleMobileAds

final class NativeAdContainerView: UIView {
    private let layout: NativeAdViewLayout
    private var adView: NativeAdView?

    // ✅ КРИТИЧНО: Intrinsic content size для SwiftUI
    override var intrinsicContentSize: CGSize {
        // Если есть загруженная реклама, используем её размер
        if let adView = adView {
            let size = adView.systemLayoutSizeFitting(
                CGSize(width: bounds.width, height: UIView.layoutFittingCompressedSize.height),
                withHorizontalFittingPriority: .required,
                verticalFittingPriority: .fittingSizeLevel
            )
            return size
        }

        // Пока реклама загружается, возвращаем минимальный размер
        let minHeight = layout.mediaHeight + layout.padding * 4 + 80 // media + text + padding
        return CGSize(width: UIView.noIntrinsicMetric, height: minHeight)
    }

    init(layout: NativeAdViewLayout) {
        self.layout = layout
        super.init(frame: .zero)
        setupLoadingState()

        // ✅ Устанавливаем compression resistance
        setContentHuggingPriority(.required, for: .vertical)
        setContentCompressionResistancePriority(.required, for: .vertical)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private func setupLoadingState() {
        backgroundColor = .secondarySystemBackground
        layer.cornerRadius = layout.cornerRadius
        clipsToBounds = true

        let indicator = UIActivityIndicatorView(style: .medium)
        indicator.translatesAutoresizingMaskIntoConstraints = false
        indicator.startAnimating()
        addSubview(indicator)

        NSLayoutConstraint.activate([
            indicator.centerXAnchor.constraint(equalTo: centerXAnchor),
            indicator.centerYAnchor.constraint(equalTo: centerYAnchor),
            // ✅ Минимальная высота для loading state
            indicator.heightAnchor.constraint(greaterThanOrEqualToConstant: 200)
        ])
    }

    func render(ad: NativeAd) {
        // Очищаем предыдущий контент
        subviews.forEach { $0.removeFromSuperview() }

        let adView = NativeAdView()
        adView.translatesAutoresizingMaskIntoConstraints = false
        adView.backgroundColor = .secondarySystemBackground
        adView.layer.cornerRadius = layout.cornerRadius
        adView.clipsToBounds = true
        self.adView = adView

        // Создаем компоненты
        let mediaView = MediaView()
        let headlineLabel = UILabel()
        let bodyLabel = UILabel()
        let ctaButton = UIButton(type: .system)

        // Настраиваем компоненты
        mediaView.translatesAutoresizingMaskIntoConstraints = false
        mediaView.contentMode = .scaleAspectFill
        mediaView.clipsToBounds = true

        headlineLabel.translatesAutoresizingMaskIntoConstraints = false
        headlineLabel.font = .boldSystemFont(ofSize: 16)
        headlineLabel.numberOfLines = 2

        bodyLabel.translatesAutoresizingMaskIntoConstraints = false
        bodyLabel.font = .systemFont(ofSize: 14)
        bodyLabel.textColor = .secondaryLabel
        bodyLabel.numberOfLines = 3

        ctaButton.translatesAutoresizingMaskIntoConstraints = false
        ctaButton.backgroundColor = .systemBlue
        ctaButton.setTitleColor(.white, for: .normal)
        ctaButton.layer.cornerRadius = 8
        ctaButton.contentEdgeInsets = UIEdgeInsets(top: 10, left: 16, bottom: 10, right: 16)

        // Добавляем в иерархию
        [mediaView, headlineLabel, bodyLabel, ctaButton].forEach {
            adView.addSubview($0)
        }

        // Связываем с GADNativeAdView
        adView.mediaView = mediaView
        adView.headlineView = headlineLabel
        adView.bodyView = bodyLabel
        adView.callToActionView = ctaButton

        // Устанавливаем данные
        headlineLabel.text = ad.headline
        bodyLabel.text = ad.body
        ctaButton.setTitle(ad.callToAction, for: .normal)
        mediaView.mediaContent = ad.mediaContent
        adView.nativeAd = ad

        // ✅ КРИТИЧНО: Правильные constraints с фиксированной высотой
        NSLayoutConstraint.activate([
            mediaView.topAnchor.constraint(equalTo: adView.topAnchor),
            mediaView.leadingAnchor.constraint(equalTo: adView.leadingAnchor),
            mediaView.trailingAnchor.constraint(equalTo: adView.trailingAnchor),
            mediaView.heightAnchor.constraint(equalToConstant: layout.mediaHeight), // ✅ Фиксированная высота

            headlineLabel.topAnchor.constraint(equalTo: mediaView.bottomAnchor, constant: layout.padding),
            headlineLabel.leadingAnchor.constraint(equalTo: adView.leadingAnchor, constant: layout.padding),
            headlineLabel.trailingAnchor.constraint(equalTo: adView.trailingAnchor, constant: -layout.padding),

            bodyLabel.topAnchor.constraint(equalTo: headlineLabel.bottomAnchor, constant: 6),
            bodyLabel.leadingAnchor.constraint(equalTo: headlineLabel.leadingAnchor),
            bodyLabel.trailingAnchor.constraint(equalTo: headlineLabel.trailingAnchor),

            ctaButton.topAnchor.constraint(equalTo: bodyLabel.bottomAnchor, constant: layout.padding),
            ctaButton.leadingAnchor.constraint(equalTo: headlineLabel.leadingAnchor),
            ctaButton.bottomAnchor.constraint(equalTo: adView.bottomAnchor, constant: -layout.padding),
            ctaButton.heightAnchor.constraint(equalToConstant: 44) // ✅ Фиксированная высота кнопки
        ])

        // Добавляем в контейнер
        addSubview(adView)
        NSLayoutConstraint.activate([
            adView.topAnchor.constraint(equalTo: topAnchor),
            adView.leadingAnchor.constraint(equalTo: leadingAnchor),
            adView.trailingAnchor.constraint(equalTo: trailingAnchor),
            adView.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])

        // ✅ КРИТИЧНО: Обновляем intrinsic size после загрузки
        invalidateIntrinsicContentSize()
        setNeedsLayout()
        layoutIfNeeded()
    }
}

// ===== FILE: Timetable DSW/Services/Ads/NativeAdProvider.swift =====
import GoogleMobileAds
import UIKit
import Combine

@MainActor
final class NativeAdProvider: NSObject, ViewAdProvider {
    typealias AdObject = NativeAd
    typealias ViewType = UIView

    let adType: AdType = .native
    private let adUnitID: String
    private let layout: NativeAdViewLayout
    private let viewControllerProvider: ViewControllerProvider

    private var adLoader: AdLoader?
    private var nativeAd: NativeAd?
    private var containerView: NativeAdContainerView?

    private let loadedSubject = PassthroughSubject<NativeAd, Never>()
    var loadedPublisher: AnyPublisher<NativeAd, Never> {
        loadedSubject.eraseToAnyPublisher()
    }

    var isReady: Bool { nativeAd != nil }

    init(
        adUnitID: String,
        layout: NativeAdViewLayout = .default,
        viewControllerProvider: ViewControllerProvider
    ) {
        self.adUnitID = adUnitID
        self.layout = layout
        self.viewControllerProvider = viewControllerProvider
    }

    func load() async throws {
        guard let rootVC = await viewControllerProvider.getTopMostViewController() else {
            throw AdError.failedToLoad(NSError(
                domain: "NativeAd",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "No root view controller"]
            ))
        }

        let loader = AdLoader(
            adUnitID: adUnitID,
            rootViewController: rootVC,
            adTypes: [.native],
            options: []
        )

        self.adLoader = loader
        loader.delegate = self
        loader.load(Request())
    }

    func createView() -> UIView {
        let container = NativeAdContainerView(layout: layout)
        containerView = container

        // Если реклама уже загружена, отображаем сразу
        if let ad = nativeAd {
            container.render(ad: ad)
        } else {
            // Если нет, начинаем загрузку
            Task {
                try? await load()
            }
        }

        return container
    }

    func reset() {
        nativeAd = nil
        adLoader = nil
        containerView = nil
    }
}

extension NativeAdProvider: AdLoaderDelegate, NativeAdLoaderDelegate {
    nonisolated func adLoader(_ adLoader: AdLoader, didFailToReceiveAdWithError error: Error) {
        print("[Native] Failed: \(error)")
        Task { @MainActor in
            self.adLoader = nil
        }
    }

    nonisolated func adLoader(_ adLoader: AdLoader, didReceive nativeAd: NativeAd) {
        Task { @MainActor in
            self.nativeAd = nativeAd
            self.adLoader = nil
            self.loadedSubject.send(nativeAd)

            // Автоматически отрисовываем, если контейнер уже создан
            if let container = self.containerView {
                container.render(ad: nativeAd)
            }
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/NativeAdViewLayout.swift =====
import Foundation

struct NativeAdViewLayout {
    let mediaHeight: CGFloat
    let padding: CGFloat
    let cornerRadius: CGFloat

    static let `default` = NativeAdViewLayout(
        mediaHeight: 180,
        padding: 12,
        cornerRadius: 12
    )
}

// ===== FILE: Timetable DSW/Services/Ads/NativeAdViewSui.swift =====
import SwiftUI

struct NativeAdViewSui: View {
    @Environment(\.adCoordinator) private var coordinator
    @EnvironmentObject private var appStateService: DefaultAppStateService
    
    var body: some View {
        // ✅ КРИТИЧНО: Не показываем native ad для premium
        if coordinator?.isAdDisabled() ?? false {
            EmptyView()
        } else {
            NativeAdViewRepresentable(coordinator: coordinator)
                .frame(minHeight: 280) // ✅ Минимальная высота
                .fixedSize(horizontal: false, vertical: true) // ✅ Позволяем view определить свою высоту
        }
    }
    
    private struct NativeAdViewRepresentable: UIViewRepresentable {
        let coordinator: AdCoordinator?
        
        func makeUIView(context: Context) -> UIView {
            guard let coordinator = coordinator else {
                return createPlaceholderView()
            }
            
            let nativeView = coordinator.makeNativeAdView()
            
            // ✅ КРИТИЧНО: Настраиваем layout для SwiftUI
            nativeView.translatesAutoresizingMaskIntoConstraints = false
            nativeView.setContentHuggingPriority(.required, for: .vertical)
            nativeView.setContentCompressionResistancePriority(.required, for: .vertical)
            
            return nativeView
        }
        
        func updateUIView(_ uiView: UIView, context: Context) {
            // ✅ Триггерим layout update если нужно
            DispatchQueue.main.async {
                uiView.invalidateIntrinsicContentSize()
                uiView.setNeedsLayout()
            }
        }
        
        private func createPlaceholderView() -> UIView {
            let view = UIView()
            view.backgroundColor = .secondarySystemBackground
            view.layer.cornerRadius = 12
            
            let label = UILabel()
            label.text = "Loading ad..."
            label.textColor = .secondaryLabel
            label.translatesAutoresizingMaskIntoConstraints = false
            view.addSubview(label)
            
            NSLayoutConstraint.activate([
                label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
                label.centerYAnchor.constraint(equalTo: view.centerYAnchor),
                view.heightAnchor.constraint(equalToConstant: 280) // ✅ Фиксированная высота для placeholder
            ])
            
            return view
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/RewardedAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class RewardedAdProvider: NSObject, RewardableAdProvider {
    typealias AdObject = RewardedAd
    
    let adType: AdType = .rewarded
    private let adUnitID: String
    private var ad: RewardedAd?
    private var didEarnReward = false
    private var presentationContinuation: CheckedContinuation<Void, Error>?
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    
    var isReady: Bool { ad != nil }
    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            RewardedAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        
        didEarnReward = false
        
        try await withCheckedThrowingContinuation { continuation in
            presentationContinuation = continuation
            ad.present(from: viewController) { [weak self] in
                self?.didEarnReward = true
                self?.rewardSubject.send(true)
            }
        }
    }
    
    func reset() {
        ad = nil
        presentationContinuation = nil
        didEarnReward = false
    }
}

extension RewardedAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { @MainActor in
            if let cont = presentationContinuation {
                presentationContinuation = nil
                if didEarnReward {
                    cont.resume()
                } else {
                    cont.resume(throwing: AdError.noReward)
                }
            }
            reset()
        }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { @MainActor in
            presentationContinuation?.resume(throwing: AdError.failedToPresent(error))
            presentationContinuation = nil
            reset()
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/RewardedInterstitialAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class RewardedInterstitialAdProvider: NSObject, RewardableAdProvider {
    typealias AdObject = RewardedInterstitialAd
    
    let adType: AdType = .rewardedInterstitial
    private let adUnitID: String
    private var ad: RewardedInterstitialAd?
    private var didEarnReward = false
    private var presentationContinuation: CheckedContinuation<Void, Error>?
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    
    var isReady: Bool { ad != nil }
    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            RewardedInterstitialAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        
        didEarnReward = false
        
        try await withCheckedThrowingContinuation { continuation in
            presentationContinuation = continuation
            ad.present(from: viewController) { [weak self] in
                self?.didEarnReward = true
                self?.rewardSubject.send(true)
            }
        }
    }
    
    func reset() {
        ad = nil
        presentationContinuation = nil
        didEarnReward = false
    }
}

extension RewardedInterstitialAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { @MainActor in
            if let cont = presentationContinuation {
                presentationContinuation = nil
                if didEarnReward {
                    cont.resume()
                } else {
                    cont.resume(throwing: AdError.noReward)
                }
            }
            reset()
        }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { @MainActor in
            presentationContinuation?.resume(throwing: AdError.failedToPresent(error))
            presentationContinuation = nil
            reset()
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/ViewControllerProvider.swift =====
import UIKit.UIViewController

protocol ViewControllerProvider {
    func getRootViewController() async -> UIViewController?
    func getTopMostViewController() async -> UIViewController?
    func acquirePresentingViewController(timeout: TimeInterval) async throws -> UIViewController
}

// ===== FILE: Timetable DSW/Services/AppState/AppStateService.swift =====
// ===== FILE: Timetable DSW/Services/AppState/AppStateService.swift =====
import Foundation
import Combine

// MARK: - Core Models (Sendable для Swift Concurrency)

enum PremiumStatus: Codable, Sendable, Equatable {
    case free
    case premium
    case temporaryPremium(expiresAt: Date)

    var isPremium: Bool {
        switch self {
        case .free:
            return false
        case .premium:
            return true
        case .temporaryPremium(let expiresAt):
            return Date() < expiresAt
        }
    }
}

struct AppState: Codable, Sendable, Equatable {
    var premiumStatus: PremiumStatus
    var premiumPurchaseDate: Date?
    var lastAdWatchedDate: Date?
    var totalAdsWatched: Int

    static let `default` = AppState(
        premiumStatus: .free,
        premiumPurchaseDate: nil,
        lastAdWatchedDate: nil,
        totalAdsWatched: 0
    )
}

// MARK: - Protocol (@MainActor для SwiftUI)

// MARK: - Configuration

struct AppStateConfiguration {
    static let temporaryPremiumDuration: TimeInterval = 3600 // 1 hour
    static let stateStorageKey = "app_state"
}

// MARK: - Storage Layer (Single Responsibility: Persistence)

actor AppStateStorage {
    private let userDefaults: UserDefaults
    private let storageKey: String

    init(
        userDefaults: UserDefaults = .standard,
        storageKey: String = AppStateConfiguration.stateStorageKey
    ) {
        self.userDefaults = userDefaults
        self.storageKey = storageKey
    }

    func loadState() -> AppState {
        guard let data = userDefaults.data(forKey: storageKey),
              let state = try? JSONDecoder().decode(AppState.self, from: data) else {
            return .default
        }
        return state
    }

    func saveState(_ state: AppState) {
        guard let data = try? JSONEncoder().encode(state) else { return }
        userDefaults.set(data, forKey: storageKey)
    }
}

// MARK: - Premium Expiration Monitor (Single Responsibility: Time-based checks)

@MainActor
final class PremiumExpirationMonitor {
    private var timer: Timer?
    private let onExpiration: () -> Void

    init(onExpiration: @escaping () -> Void) {
        self.onExpiration = onExpiration
    }

    func scheduleCheck(for expirationDate: Date) {
        cancelScheduledCheck()

        let timeInterval = expirationDate.timeIntervalSince(Date())
        guard timeInterval > 0 else {
            onExpiration()
            return
        }

        timer = Timer.scheduledTimer(
            withTimeInterval: timeInterval,
            repeats: false
        ) { [weak self] _ in
            self?.onExpiration()
        }
    }

    func cancelScheduledCheck() {
        timer?.invalidate()
        timer = nil
    }

    // deinit не может быть @MainActor, поэтому делаем cleanup синхронно
    nonisolated deinit {
        // Timer.invalidate() может быть вызвано из любого потока
        // Для безопасности проверяем, что timer существует
        Task { @MainActor [timer] in
            timer?.invalidate()
        }
    }
}

// MARK: - Premium Status Validator (Single Responsibility: Validation logic)

struct PremiumStatusValidator {
    func validateAndUpdate(_ state: AppState) -> AppState {
        var updatedState = state

        guard case .temporaryPremium(let expiresAt) = state.premiumStatus else {
            return state
        }

        if Date() >= expiresAt {
            updatedState.premiumStatus = .free
        }

        return updatedState
    }

    func isExpired(_ status: PremiumStatus) -> Bool {
        guard case .temporaryPremium(let expiresAt) = status else {
            return false
        }
        return Date() >= expiresAt
    }
}

// MARK: - Main Service (@MainActor для SwiftUI)

@MainActor
final class DefaultAppStateService: ObservableObject, AppStateService {

    // MARK: - Dependencies

    private let storage: AppStateStorage
    private let validator = PremiumStatusValidator()

    // MARK: - Published State

    @Published private(set) var state: AppState {
        didSet {
            Task {
                await storage.saveState(state)
            }
            updateExpirationMonitor()
        }
    }

    // MARK: - Computed Properties

    var statePublisher: AnyPublisher<AppState, Never> {
        $state.eraseToAnyPublisher()
    }

    var premiumStatus: PremiumStatus {
        state.premiumStatus
    }

    var isPremium: Bool {
        state.premiumStatus.isPremium
    }

    private lazy var expirationMonitor: PremiumExpirationMonitor = {
            PremiumExpirationMonitor { [weak self] in
                self?.handlePremiumExpiration()
            }
        }()

    // MARK: - Initialization

    init(userDefaults: UserDefaults = .standard) {
        self.storage = AppStateStorage(userDefaults: userDefaults)

        // Временная инициализация для создания monitor
        self.state = .default

        // Загружаем реальное состояние
        Task {
            await loadInitialState()
        }
    }

    // MARK: - Public Methods

    func grantPremium() {
        state.premiumStatus = .premium
        state.premiumPurchaseDate = Date()
    }

    func grantTemporaryPremium(
        duration: TimeInterval = AppStateConfiguration.temporaryPremiumDuration
    ) {
        let expiresAt = Date().addingTimeInterval(duration)
        state.premiumStatus = .temporaryPremium(expiresAt: expiresAt)
    }

    func revokePremium() {
        state.premiumStatus = .free
        state.premiumPurchaseDate = nil
    }

    func recordAdWatched() {
        state.lastAdWatchedDate = Date()
        state.totalAdsWatched += 1
    }

    // MARK: - Private Methods

    private func loadInitialState() async {
        let loadedState = await storage.loadState()
        state = validator.validateAndUpdate(loadedState)
    }

    private func handlePremiumExpiration() {
        guard validator.isExpired(state.premiumStatus) else { return }
        state.premiumStatus = .free
    }

    private func updateExpirationMonitor() {
        guard case .temporaryPremium(let expiresAt) = state.premiumStatus else {
            expirationMonitor.cancelScheduledCheck()
            return
        }

        expirationMonitor.scheduleCheck(for: expiresAt)
    }
}

// ===== FILE: Timetable DSW/Services/DateService/DateService.swift =====
import Foundation

// MARK: - Protocol

protocol DateService {
    func greeting(for date: Date) -> String
    func formatDate(_ date: Date) -> String
    func formatTime(_ date: Date) -> String
    func weekdayShort(_ date: Date) -> String
    func weekdayFull(_ date: Date) -> String
    func dayNumber(_ date: Date) -> String
    func startOfWeek(for date: Date) -> Date
    func daysInWeek(startingFrom date: Date) -> [Date]
    func parseISO8601(_ string: String) -> Date?
}

// ===== FILE: Timetable DSW/Services/DateService/DefaultDateService.swift =====
import Foundation

final class DefaultDateService: DateService {
    // MARK: - Properties
    
    private let calendar: Calendar
    
    // MARK: - Formatters
    
    private lazy var iso8601Formatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return formatter
    }()
    
    private lazy var dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .none
        formatter.locale = .current
        return formatter
    }()
    
    private lazy var timeFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter
    }()
    
    private lazy var weekdayShortFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEE"
        return formatter
    }()
    
    private lazy var weekdayFullFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE"
        formatter.locale = .current
        return formatter
    }()
    
    private lazy var dayFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "dd"
        return formatter
    }()
    
    // MARK: - Initialization
    
    init(calendar: Calendar = .current) {
        self.calendar = calendar
    }
    
    // MARK: - DateService Implementation
    
    func greeting(for date: Date) -> String {
        let hour = calendar.component(.hour, from: date)
        switch hour {
        case 5..<12: return LocalizedString.greetingMorning.localized
        case 12..<17: return LocalizedString.greetingAfternoon.localized
        case 17..<22: return LocalizedString.greetingEvening.localized
        default: return LocalizedString.greetingNight.localized
        }
    }
    
    func formatDate(_ date: Date) -> String {
        dateFormatter.string(from: date)
    }
    
    func formatTime(_ date: Date) -> String {
        timeFormatter.string(from: date)
    }
    
    func weekdayShort(_ date: Date) -> String {
        weekdayShortFormatter.string(from: date).uppercased()
    }
    
    func weekdayFull(_ date: Date) -> String {
        weekdayFullFormatter.string(from: date).capitalized
    }
    
    func dayNumber(_ date: Date) -> String {
        dayFormatter.string(from: date)
    }
    
    func startOfWeek(for date: Date) -> Date {
        let components = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)
        return calendar.date(from: components) ?? date
    }
    
    func daysInWeek(startingFrom date: Date) -> [Date] {
        (0..<7).compactMap { offset in
            calendar.date(byAdding: .day, value: offset, to: date)
        }
    }
    
    func parseISO8601(_ string: String) -> Date? {
        iso8601Formatter.date(from: string)
    }
}

// ===== FILE: Timetable DSW/Services/EventTypeDetector/DefaultEventTypeDetector.swift =====
import Foundation

final class DefaultEventTypeDetector: EventTypeDetector {
    // MARK: - Configuration
    
    struct Configuration {
        struct Keywords {
            static let lecture = ["wyk", "лекц"]
            static let exercise = ["ćw", "cw", "практ"]
            static let laboratory = ["lab", "лаб"]
            static let online = ["online", "онлайн", "teams", "zoom", "distance"]
            static let cancelled = ["zajęcia odwołane", "odwołane"];
        }
    }
    
    // MARK: - EventTypeDetector Implementation
    
    func detectEventType(from type: String?) -> EventType {
        guard let type = type?.lowercased() else { return .other }
        
        if Configuration.Keywords.lecture.contains(where: { type.contains($0) }) {
            return .lecture
        }
        
        if Configuration.Keywords.exercise.contains(where: { type.contains($0) }) {
            return .exercise
        }
        
        if Configuration.Keywords.laboratory.contains(where: { type.contains($0) }) {
            return .laboratory
        }
        
        return .other
    }
    
    func isOnline(remarks: String?) -> Bool {
        let remarksLower = remarks?.lowercased() ?? ""
        
        return Configuration.Keywords.online.contains { keyword in
            remarksLower.contains(keyword)
        }
    }

    func isCancelled(remarks: String?) -> Bool {
        let remarksLower = remarks?.lowercased() ?? ""
        
        return Configuration.Keywords.cancelled.contains { keyword in
            remarksLower.contains(keyword)
        }
    }
}

// ===== FILE: Timetable DSW/Services/EventTypeDetector/EventType.swift =====
import Foundation

// MARK: - Event Type

enum EventType {
    case lecture
    case exercise
    case laboratory
    case other
}

// MARK: - Protocol

protocol EventTypeDetector {
    func detectEventType(from type: String?) -> EventType
    func isOnline(remarks: String?) -> Bool
    func isCancelled(remarks: String?) -> Bool
}

// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlag.swift =====
// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlag.swift =====
import Foundation
import Combine

enum FeatureFlag: String, CaseIterable, Codable, Sendable {
    case showSubjectsTab = "show_subjects_tab"
    case showTeachersTab = "show_teachers_tab"
    case enableAnalytics = "enable_analytics"
    case showAds = "show_ads"
    case enablePushNotifications = "enable_push_notifications"
    case darkModeOnly = "dark_mode_only"
    case showDebugMenu = "show_debug_menu"

    nonisolated var defaultValue: Bool {
        switch self {
        case .showSubjectsTab, .showTeachersTab, .showAds:
            return true
        case .enableAnalytics, .enablePushNotifications:
            return false
        case .darkModeOnly:
            return false
        case .showDebugMenu:
            #if DEBUG
            return true
            #else
            return false
            #endif
        }
    }

    nonisolated var displayName: String {
        switch self {
        case .showSubjectsTab: return "Show Subjects Tab"
        case .showTeachersTab: return "Show Teachers Tab"
        case .enableAnalytics: return "Enable Analytics"
        case .showAds: return "Show Advertisements"
        case .enablePushNotifications: return "Enable Push Notifications"
        case .darkModeOnly: return "Dark Mode Only"
        case .showDebugMenu: return "Show Debug Menu"
        }
    }

    nonisolated var description: String {
        switch self {
        case .showSubjectsTab: return "Display subjects tab in navigation"
        case .showTeachersTab: return "Display teachers tab in navigation"
        case .enableAnalytics: return "Send analytics data"
        case .showAds: return "Display advertisements (disabled for premium users)"
        case .enablePushNotifications: return "Enable push notifications"
        case .darkModeOnly: return "Force dark mode for all users"
        case .showDebugMenu: return "Show debug menu in settings"
        }
    }
}

struct FeatureFlagsResponse: Codable, Sendable {
    let flags: [String: Bool]
    let version: String
    let updatedAt: String
}

struct FeatureFlagsState: Codable, Sendable {
    var localOverrides: [String: Bool]
    var remoteFlags: [String: Bool]
    var version: String?
    var lastSync: Date?

    static let empty = FeatureFlagsState(
        localOverrides: [:],
        remoteFlags: [:],
        version: nil,
        lastSync: nil
    )
}

// MARK: - Protocol (Main Actor для SwiftUI совместимости)


// MARK: - Storage Layer (Single Responsibility: Persistence)

actor FeatureFlagsStorage {
    private let userDefaults: UserDefaults
    private let stateKey = "feature_flags_state"

    init(userDefaults: UserDefaults = .standard) {
        self.userDefaults = userDefaults
    }

    func loadState() -> FeatureFlagsState {
        guard let data = userDefaults.data(forKey: stateKey),
              let state = try? JSONDecoder().decode(FeatureFlagsState.self, from: data) else {
            return .empty
        }
        return state
    }

    func saveState(_ state: FeatureFlagsState) {
        guard let data = try? JSONEncoder().encode(state) else { return }
        userDefaults.set(data, forKey: stateKey)
    }
}

// MARK: - Sync Layer (Single Responsibility: Remote Sync)

actor FeatureFlagsSyncService {
    private let networkManager: NetworkManager
    private let syncInterval: TimeInterval = 3600 // 1 hour

    init(networkManager: NetworkManager) {
        self.networkManager = networkManager
    }

    func shouldSync(lastSyncDate: Date?) -> Bool {
        guard let lastSync = lastSyncDate else { return true }
        return Date().timeIntervalSince(lastSync) > syncInterval
    }

    func fetchRemoteFlags() async throws -> FeatureFlagsResponse {
        try await networkManager.fetch(endpoint: "/api/feature-flags")
    }
}

// MARK: - Resolution Layer (Single Responsibility: Flag Resolution Logic)

struct FeatureFlagResolver {
    func resolveValue(
        for flag: FeatureFlag,
        localOverride: Bool?,
        remoteValue: Bool?
    ) -> Bool {
        // Priority: local override > remote > default
        if let override = localOverride {
            return override
        }

        if let remote = remoteValue {
            return remote
        }

        return flag.defaultValue
    }

    func resolveAllFlags(
        localOverrides: [String: Bool],
        remoteFlags: [String: Bool]
    ) -> [FeatureFlag: Bool] {
        var result: [FeatureFlag: Bool] = [:]

        for flag in FeatureFlag.allCases {
            let localOverride = localOverrides[flag.rawValue]
            let remoteValue = remoteFlags[flag.rawValue]
            result[flag] = resolveValue(
                for: flag,
                localOverride: localOverride,
                remoteValue: remoteValue
            )
        }

        return result
    }
}

// MARK: - Main Service (@MainActor для SwiftUI)

@MainActor
final class DefaultFeatureFlagService: ObservableObject, FeatureFlagService {

    // MARK: - Dependencies

    private let storage: FeatureFlagsStorage
    private let syncService: FeatureFlagsSyncService
    private let resolver = FeatureFlagResolver()

    // MARK: - State

    @Published private var state: FeatureFlagsState
    private let flagsSubject = CurrentValueSubject<[FeatureFlag: Bool], Never>([:])

    nonisolated var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> {
        flagsSubject.eraseToAnyPublisher()
    }

    // MARK: - Initialization

    init(
        networkManager: NetworkManager = NetworkManager(),
        userDefaults: UserDefaults = .standard
    ) {
        self.storage = FeatureFlagsStorage(userDefaults: userDefaults)
        self.syncService = FeatureFlagsSyncService(networkManager: networkManager)
        self.state = .empty

        Task {
            await loadInitialState()
        }
    }

    // MARK: - Public Methods

    func isEnabled(_ flag: FeatureFlag) -> Bool {
        resolver.resolveValue(
            for: flag,
            localOverride: state.localOverrides[flag.rawValue],
            remoteValue: state.remoteFlags[flag.rawValue]
        )
    }

    func setEnabled(_ flag: FeatureFlag, enabled: Bool) {
        state.localOverrides[flag.rawValue] = enabled
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func reset(_ flag: FeatureFlag) {
        state.localOverrides.removeValue(forKey: flag.rawValue)
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func resetAll() {
        state.localOverrides.removeAll()
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func syncFromRemote() async throws {
        let response = try await syncService.fetchRemoteFlags()

        state.remoteFlags = response.flags
        state.version = response.version
        state.lastSync = Date()

        updatePublisher()
        await storage.saveState(state)
    }

    // MARK: - Internal Methods

    func hasLocalOverride(for flag: FeatureFlag) -> Bool {
        state.localOverrides[flag.rawValue] != nil
    }

    // MARK: - Private Methods

    private func loadInitialState() async {
        state = await storage.loadState()
        updatePublisher()

        // Auto-sync if needed
        if await syncService.shouldSync(lastSyncDate: state.lastSync) {
            try? await syncFromRemote()
        }
    }

    private func updatePublisher() {
        let allFlags = resolver.resolveAllFlags(
            localOverrides: state.localOverrides,
            remoteFlags: state.remoteFlags
        )
        flagsSubject.send(allFlags)
    }
}

// MARK: - Preview/Mock Service

// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlagService.swift =====
import Foundation
import Combine
import SwiftUI

// MARK: - Feature Flags Protocol (Complete)

@MainActor
protocol FeatureFlagService: AnyObject {
    // Basic operations
    func isEnabled(_ flag: FeatureFlag) -> Bool
    func setEnabled(_ flag: FeatureFlag, enabled: Bool)
    func reset(_ flag: FeatureFlag)
    func resetAll()
    func syncFromRemote() async throws
    
    // Additional methods needed by consumers
    func hasLocalOverride(for flag: FeatureFlag) -> Bool
    
    // Publishers for reactive updates
    var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> { get }
}

// MARK: - App State Protocol (Complete)

@MainActor
protocol AppStateService: AnyObject {
    // State properties
    var isPremium: Bool { get }
    var premiumStatus: PremiumStatus { get }
    var state: AppState { get }
    
    // Actions
    func grantPremium()
    func grantTemporaryPremium(duration: TimeInterval)
    func revokePremium()
    func recordAdWatched()
    
    // Publisher for reactive updates
    var statePublisher: AnyPublisher<AppState, Never> { get }
}

// MARK: - DefaultFeatureFlagService conforms to protocol


// MARK: - Mock Services for Testing

#if DEBUG

@MainActor
final class MockFeatureFlagService: FeatureFlagService {
    private var flags: [FeatureFlag: Bool] = [:]
    private var overrides: Set<FeatureFlag> = []
    private let subject = CurrentValueSubject<[FeatureFlag: Bool], Never>([:])
    
    var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> {
        subject.eraseToAnyPublisher()
    }
    
    init(defaultFlags: [FeatureFlag: Bool] = [:]) {
        self.flags = defaultFlags
        subject.send(flags)
    }
    
    func isEnabled(_ flag: FeatureFlag) -> Bool {
        flags[flag] ?? flag.defaultValue
    }
    
    func setEnabled(_ flag: FeatureFlag, enabled: Bool) {
        flags[flag] = enabled
        overrides.insert(flag)
        subject.send(flags)
    }
    
    func reset(_ flag: FeatureFlag) {
        flags.removeValue(forKey: flag)
        overrides.remove(flag)
        subject.send(flags)
    }
    
    func resetAll() {
        flags.removeAll()
        overrides.removeAll()
        subject.send(flags)
    }
    
    func syncFromRemote() async throws {
        // Mock implementation
        try await Task.sleep(nanoseconds: 1_000_000_000)
    }
    
    func hasLocalOverride(for flag: FeatureFlag) -> Bool {
        overrides.contains(flag)
    }
}

@MainActor
final class MockAppStateService: AppStateService {
    @Published private(set) var state: AppState
    
    var statePublisher: AnyPublisher<AppState, Never> {
        $state.eraseToAnyPublisher()
    }
    
    var premiumStatus: PremiumStatus {
        state.premiumStatus
    }
    
    var isPremium: Bool {
        state.premiumStatus.isPremium
    }
    
    init(initialState: AppState = .default) {
        self.state = initialState
    }
    
    func grantPremium() {
        state.premiumStatus = .premium
        state.premiumPurchaseDate = Date()
    }
    
    func grantTemporaryPremium(duration: TimeInterval = 3600) {
        let expiresAt = Date().addingTimeInterval(duration)
        state.premiumStatus = .temporaryPremium(expiresAt: expiresAt)
    }
    
    func revokePremium() {
        state.premiumStatus = .free
        state.premiumPurchaseDate = nil
    }
    
    func recordAdWatched() {
        state.lastAdWatchedDate = Date()
        state.totalAdsWatched += 1
    }
}

#endif

// MARK: - Service Container (Dependency Injection)

@MainActor
final class ServiceContainer {
    // Singleton pattern (или можно использовать другой DI подход)
    static let shared = ServiceContainer()
    
    // Services как protocols
    let featureFlagService: FeatureFlagService
    let appStateService: AppStateService
    
    private init(
        featureFlagService: FeatureFlagService? = nil,
        appStateService: AppStateService? = nil
    ) {
        // Production services по умолчанию
        self.featureFlagService = featureFlagService ?? DefaultFeatureFlagService()
        self.appStateService = appStateService ?? DefaultAppStateService()
    }
    
    // Factory для тестов
    static func mock(
        featureFlagService: FeatureFlagService? = nil,
        appStateService: AppStateService? = nil
    ) -> ServiceContainer {
        ServiceContainer(
            featureFlagService: featureFlagService ?? MockFeatureFlagService(),
            appStateService: appStateService ?? MockAppStateService()
        )
    }
}

// MARK: - Environment Key для Protocols



// MARK: - View Extension для удобства

extension View {
    func services(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) -> some View {
        self
            .environment(\.featureFlagService, featureFlagService)
            .environment(\.appStateService, appStateService)
    }
}

// ===== FILE: Timetable DSW/Services/HapticFeedbackService/DefaultHapticFeedbackService.swift =====
import UIKit

final class DefaultHapticFeedbackService: HapticFeedbackService {
    // MARK: - HapticFeedbackService Implementation
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
}

// ===== FILE: Timetable DSW/Services/HapticFeedbackService/HapticFeedbackService.swift =====
import UIKit

protocol HapticFeedbackService {
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle)
    func selection()
    func notification(type: UINotificationFeedbackGenerator.FeedbackType)
}

// ===== FILE: Timetable DSW/ViewModels/AppViewModel.swift =====
import Combine
import Foundation

@MainActor
final class AppViewModel: ObservableObject, EventsProviderProtocol {
    // MARK: - Configuration

    struct Configuration {
        struct Constants {
            let scheduleFrom = "2025-09-06"
            let scheduleTo = "2026-02-08"
        }

        static let constants = Constants()
    }

    // MARK: - Performance Cache
    private let eventTypeDetector: EventTypeDetector
    private var eventsDayTypeCache: [String: EventDayType] = [:]
    private var eventsCacheVersion = UUID()

    @Published var scheduleData: AggregateResponse? {
        didSet {
            if scheduleData?.groupSchedule != oldValue?.groupSchedule {
                invalidateEventsCache()
            }
        }
    }

    // MARK: - Published Properties

    @Published var isLoading = false
    @Published var isRefreshing = false
    @Published var errorMessage: String?
    @Published var lastUpdated: Date?
    @Published var isOffline = false
    @Published var groups: [GroupInfo] = []
    @Published var isLoadingGroups = false

    // MARK: - Properties

    private let repository: ScheduleRepository
    private let userDefaults: UserDefaults

    // MARK: - User Defaults Keys

    private enum UserDefaultsKey {
        static let groupId = "groupId"
        static let lastUpdated = "lastUpdated"
    }

    // MARK: - Computed Properties

    var groupId: Int {
        get { userDefaults.integer(forKey: UserDefaultsKey.groupId) }
        set { userDefaults.set(newValue, forKey: UserDefaultsKey.groupId) }
    }

    var selectedGroupName: String? {
        groups.first(where: { $0.groupId == groupId })?.displayName
    }

    // MARK: - Initialization

    init(repository: ScheduleRepository,
         userDefaults: UserDefaults = .standard,
         eventTypeDetector: EventTypeDetector = DefaultEventTypeDetector()) {
        self.repository = repository
        self.userDefaults = userDefaults
        self.eventTypeDetector = eventTypeDetector
    }

    // MARK: - Groups Loading

    func loadGroupsIfNeeded() async {
        guard groups.isEmpty else { return }

        groups = await repository.getCachedGroups() ?? []

        if groups.isEmpty {
            await loadGroups()
        }
    }

    func loadGroups() async {
        isLoadingGroups = true
        defer { isLoadingGroups = false }

        do {
            let fetchedGroups = try await repository.getGroups()
            groups = fetchedGroups.sorted { $0.displayName < $1.displayName }
        } catch {
            print("Failed to load groups: \(error)")
        }
    }

    // MARK: - Schedule Loading

    func loadSchedule() async {
        guard groupId > 0 else {
            errorMessage = LocalizedString.settingsPleaseSelectGroup.localized
            return
        }

        await loadCachedScheduleIfNeeded()

        isLoading = scheduleData == nil
        isRefreshing = scheduleData != nil
        errorMessage = nil

        await fetchFreshSchedule()
    }

    private func loadCachedScheduleIfNeeded() async {
        guard scheduleData == nil else { return }

        scheduleData = await repository.getCachedSchedule()
        if scheduleData != nil {
            lastUpdated = userDefaults.object(forKey: UserDefaultsKey.lastUpdated) as? Date
        }
    }

    private func fetchFreshSchedule() async {
        do {
            let fresh = try await repository.getSchedule(
                groupId: groupId,
                from: Configuration.constants.scheduleFrom,
                to: Configuration.constants.scheduleTo
            )
            scheduleData = fresh
            updateLastUpdatedTimestamp()
            isOffline = false
        } catch {
            errorMessage = error.localizedDescription
            isOffline = true
        }

        isLoading = false
        isRefreshing = false
    }

    private func updateLastUpdatedTimestamp() {
        lastUpdated = Date()
        userDefaults.set(lastUpdated, forKey: UserDefaultsKey.lastUpdated)
    }

    func refresh() async {
        await loadSchedule()
    }

    // MARK: - Cache Management

    func clearCache() async {
        do {
            try await repository.clearScheduleCache()
            scheduleData = nil
            lastUpdated = nil
            userDefaults.removeObject(forKey: UserDefaultsKey.lastUpdated)
        } catch {
            print("Failed to clear cache: \(error)")
        }
    }

    // MARK: - EventsProviderProtocol

    private func cacheKey(for date: Date) -> String {
        let calendar = Calendar.current
        let components = calendar.dateComponents([.year, .month, .day], from: date)
        return "\(eventsCacheVersion)-\(components.year!)-\(components.month!)-\(components.day!)"
    }

    private func invalidateEventsCache() {
        eventsDayTypeCache.removeAll()
        eventsCacheVersion = UUID()
    }

    func hasEventsOn(date: Date) -> Bool {
        eventType(on: date) != .none
    }

    func eventsForDate(_ date: Date) -> [ScheduleEvent] {
        guard let scheduleData = scheduleData else { return [] }

        return scheduleData.groupSchedule.filter { event in
            guard let eventDate = event.startDate else { return false }
            return Calendar.current.isDate(eventDate, inSameDayAs: date)
        }
    }

    func eventType(on date: Date) -> EventDayType {
        let key = cacheKey(for: date)
        if let cached = eventsDayTypeCache[key] { return cached }

        let events = eventsForDate(date)
        let value: EventDayType
        if events.isEmpty {
            value = .none
        } else {
            let allOnline = events.allSatisfy { ev in
                eventTypeDetector.isOnline(remarks: ev.remarks)
            }
            value = allOnline ? .onlineOnly : .regular
        }
        eventsDayTypeCache[key] = value
        return value
    }
}

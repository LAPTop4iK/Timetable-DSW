
// ===== FILE: Timetable DSW/App/AdCoordinatorKey.swift =====
import SwiftUI

private struct AdCoordinatorKey: EnvironmentKey {
    static let defaultValue: AdCoordinator? = nil
}

extension EnvironmentValues {
    var adCoordinator: AdCoordinator? {
        get { self[AdCoordinatorKey.self] }
        set { self[AdCoordinatorKey.self] = newValue }
    }
}

extension View {
    func adCoordinator(_ coordinator: AdCoordinator) -> some View {
        environment(\.adCoordinator, coordinator)
    }
}

// ===== FILE: Timetable DSW/App/AppDelegate.swift =====
import SwiftUI
import FirebaseCore

class AppDelegate: NSObject, UIApplicationDelegate {
  func application(_ application: UIApplication,
                   didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    FirebaseApp.configure()
    return true
  }
}

// ===== FILE: Timetable DSW/App/ContentView.swift =====
import SwiftUI

struct ContentView: View {
    // MARK: - Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let springResponse: Double = 0.4
            let springDamping: Double = 0.8
        }
        static let constants = Constants()
    }

    // MARK: - Properties
    @EnvironmentObject var appViewModel: AppViewModel
    @EnvironmentObject var appStateService: DefaultAppStateService
    @Environment(\.adCoordinator) private var adCoordinator

    @State private var selectedTab = 0
    @State private var showConfetti = false

    // MARK: - Dependencies
    private let tabs: [TabBarItem] = [
        TabBarItem(icon: .calendar,    title: .tabsSchedule, tag: 0),
        TabBarItem(icon: .listBullet,  title: .tabsSubjects, tag: 1),
        TabBarItem(icon: .people,      title: .tabsTeachers, tag: 2),
        TabBarItem(icon: .gear,        title: .tabsSettings, tag: 3)
    ]

    // MARK: - Computed Properties

    private var premiumAccess: PremiumAccess {
        PremiumAccess.from(appState: appStateService.state)
    }

    // MARK: - Body
    var body: some View {
        ZStack(alignment: .bottom) {
            contentView
            FloatingTabBar(tabs: tabs, selectedTab: $selectedTab)
        }
        .task {
            await appViewModel.loadGroupsIfNeeded()
        }
    }

    // MARK: - Subviews
    private var contentView: some View {
        Group {
            switch selectedTab {
            case 0:
                ScheduleView()
                    .transition(tabTransition)
            case 1:
                SubjectsView()
                    .premiumContent(
                        feature: .subjectsTab,
                        premiumAccess: premiumAccess,
                        coordinator: adCoordinator,
                        onWatchAd: handleWatchAd,
                        onPurchase: handlePurchase
                    )
                    .transition(tabTransition)
            case 2:
                TeachersView(viewModel: TeachersViewModel())
                    .premiumContent(
                        feature: .teachersTab,
                        premiumAccess: premiumAccess,
                        coordinator: adCoordinator,
                        onWatchAd: handleWatchAd,
                        onPurchase: handlePurchase
                    )
                    .transition(tabTransition)
            case 3:
                SettingsView()
                    .transition(tabTransition)
            default:
                EmptyView()
            }
        }
        .animation(
            .spring(response: Configuration.constants.springResponse,
                    dampingFraction: Configuration.constants.springDamping),
            value: selectedTab
        )
        .confetti(isShowing: $showConfetti, configuration: .rainbow)
    }

    // MARK: - Actions

    private func handleWatchAd() {
        Task {
            do {
                try await adCoordinator?.loadAd(type: .rewarded)
                try await adCoordinator?.showAd(type: .rewarded)

                // Grant temporary premium (duration from AppStateConfiguration)
                appStateService.grantTemporaryPremium()

                // Show confetti celebration
                withAnimation {
                    showConfetti = true
                }
            } catch {
                print("[Premium] Failed to show rewarded ad: \(error)")
            }
        }
    }

    private func handlePurchase() {
        // TODO: Implement purchase flow
        // For now, grant permanent premium for testing
        #if DEBUG
        appStateService.grantPremium()
        withAnimation {
            showConfetti = true
        }
        #endif
    }

    // MARK: - Computed Properties
    private var tabTransition: AnyTransition {
        .asymmetric(
            insertion: .move(edge: .trailing).combined(with: .opacity),
            removal: .move(edge: .leading).combined(with: .opacity)
        )
    }
}

// ===== FILE: Timetable DSW/App/DSWScheduleApp.swift =====
import SwiftUI
import AppTrackingTransparency 

@main
struct DSWScheduleApp: App {

    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
    // MARK: - Properties

    @StateObject private var appViewModel: AppViewModel
    @StateObject private var appStateService: DefaultAppStateService
    @StateObject private var featureFlagService: DefaultFeatureFlagService
    @StateObject private var parametersService: FeatureFlagParametersService
    @StateObject private var bottomInsetService: DefaultBottomInsetService
    @StateObject private var themeManager = ThemeManager.shared

    // AdCoordinator - не ObservableObject, поэтому @State
    @State private var adCoordinator: AdMobCoordinator

    // ⬇️ Добавлено: следим за жизненным циклом сцены и флаг от повторных вызовов
    @Environment(\.scenePhase) private var scenePhase
    @State private var didAskATTThisSession = false

    // MARK: - Initialization

    init() {
        // 1️⃣ Создаем базовые зависимости (не ObservableObject)
        let networkManager = NetworkManager()
        let cacheManager = CacheManager()
        let repository = ScheduleRepository(
            networkManager: networkManager,
            cacheManager: cacheManager
        )

        // 2️⃣ Создаем сервисы как ObservableObject
        let parameters = FeatureFlagParametersService()
        let featureFlags = DefaultFeatureFlagService(networkManager: networkManager)
        let appState = DefaultAppStateService(parametersService: parameters)
        let viewModel = AppViewModel(repository: repository)

        // 3️⃣ BottomInsetService
        let bottomInset = DefaultBottomInsetService(
            appStateService: appState,
            featureFlagService: featureFlags,
            parametersService: parameters
        )

        // 4️⃣ Оборачиваем в StateObject
        _appViewModel = StateObject(wrappedValue: viewModel)
        _appStateService = StateObject(wrappedValue: appState)
        _featureFlagService = StateObject(wrappedValue: featureFlags)
        _parametersService = StateObject(wrappedValue: parameters)
        _bottomInsetService = StateObject(wrappedValue: bottomInset)

        // 5️⃣ Создаем AdCoordinator используя уже созданные сервисы
        // ✅ Правильно: используем те же экземпляры, что и в StateObject
        let coordinator = AdMobCoordinator.makeForProduction(
            featureFlagService: featureFlags,
            appStateService: appState
        )

        #if DEBUG
        coordinator.setTestDevices(["abe4cf7d005b0f028298ebf7aafd7e17"])
        #endif

        _adCoordinator = State(wrappedValue: coordinator)
    }

    // MARK: - Body

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appViewModel)
                .environmentObject(appStateService)
                .environmentObject(featureFlagService)
                .environmentObject(parametersService)
                .environmentObject(bottomInsetService)
                .environmentObject(themeManager)
                .environment(\.featureFlagParameters, parametersService)
                .environment(\.bottomInsetService, bottomInsetService)
                .environment(\.themeManager, themeManager)
                .adCoordinator(adCoordinator)
                .onChange(of: scenePhase) { _, phase in
                    guard phase == .active else { return }
                    guard !didAskATTThisSession else {
                        Task { @MainActor in
                            let status = ATTrackingManager.trackingAuthorizationStatus
                            adCoordinator.start(afterATT: status)
                        }
                        return
                    }
                    didAskATTThisSession = true

                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        Task { @MainActor in
                            let status = await ATTPermissionManager.requestIfNeeded()
                            adCoordinator.start(afterATT: status)
                        }
                    }
                }
        }
    }
}

// MARK: - Environment Extension (если нужен прямой доступ)

extension EnvironmentValues {
    var featureFlagService: FeatureFlagService {
        get { self[FeatureFlagServiceKey.self] }
        set { self[FeatureFlagServiceKey.self] = newValue }
    }

    var appStateService: AppStateService {
        get { self[AppStateServiceKey.self] }
        set { self[AppStateServiceKey.self] = newValue }
    }
}

private struct FeatureFlagServiceKey: EnvironmentKey {
    static let defaultValue: FeatureFlagService = DefaultFeatureFlagService()
}

private struct AppStateServiceKey: EnvironmentKey {
    static let defaultValue: AppStateService = DefaultAppStateService()
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Colors/AppColor.swift =====
import SwiftUI

enum AppColor {
    // MARK: - Text Colors
    case primaryText
    case secondaryText
    case tertiaryText
    case quaternaryText

    // MARK: - Background Colors
    case background
    case secondaryBackground
    case tertiaryBackground

    // MARK: - Theme Colors
    case themePrimary
    case themeSecondary
    case themeTertiary
    case themeAccent

    // MARK: - Status Colors
    case success
    case warning
    case error
    case info

    // MARK: - Basic Colors
    case white
    case black
    case clear
    case green
    case orange
    case red
    case blue
    case purple
    case pink
    case cyan

    // MARK: - Custom
    case custom(Color, opacity: Double)

    // MARK: - Method
    func color(for scheme: ColorScheme, theme: (any Theme)? = nil) -> Color {
        let currentTheme = theme ?? ThemeManager.shared.currentTheme(for: scheme)

        switch self {
        case .primaryText:
            return .primary
        case .secondaryText:
            return .secondary
        case .tertiaryText:
            return scheme == .dark ? Color.white.opacity(0.6) : Color.black.opacity(0.5)
        case .quaternaryText:
            return scheme == .dark ? Color.white.opacity(0.4) : Color.black.opacity(0.3)

        case .background:
            return Color(.systemBackground)
        case .secondaryBackground:
            return Color(.secondarySystemBackground)
        case .tertiaryBackground:
            return Color(.tertiarySystemBackground)

        case .themePrimary:
            return currentTheme.primary
        case .themeSecondary:
            return currentTheme.secondary
        case .themeTertiary:
            return currentTheme.tertiary
        case .themeAccent:
            return currentTheme.accent

        case .success:
            return currentTheme.success
        case .warning:
            return currentTheme.warning
        case .error:
            return currentTheme.error
        case .info:
            return currentTheme.info

        case .white:
            return .white
        case .black:
            return .black
        case .clear:
            return .clear
        case .green:
            return .green
        case .orange:
            return .orange
        case .red:
            return .red
        case .blue:
            return .blue
        case .purple:
            return .purple
        case .pink:
            return .pink
        case .cyan:
            return .cyan

        case .custom(let color, let opacity):
            return color.opacity(opacity)
        }
    }
}

// MARK: - View Extension
extension View {
    func foregroundAppColor(_ appColor: AppColor, colorScheme: ColorScheme, theme: (any Theme)? = nil) -> some View {
        self.foregroundColor(appColor.color(for: colorScheme, theme: theme))
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Gradients/GradientStyle.swift =====
import SwiftUI

enum GradientStyle {
    case primary
    case secondary
    case accent
    case success
    case warning
    case error
    case lecture
    case exercise
    case laboratory
    case header
    case online
    case cancelled

    func colors(for scheme: ColorScheme, theme: (any Theme)? = nil) -> [Color] {
        let currentTheme = theme ?? ThemeManager.shared.currentTheme(for: scheme)
        let opacity1: Double = scheme == .dark ? 0.9 : 0.9
        let opacity2: Double = scheme == .dark ? 0.7 : 0.6

        switch self {
        case .primary:
            return [
                currentTheme.primary,
                currentTheme.secondary.opacity(opacity2),
                currentTheme.tertiary.opacity(0.8)
            ]

        case .secondary:
            return [
                currentTheme.secondary.opacity(opacity1),
                currentTheme.tertiary.opacity(opacity2)
            ]

        case .accent:
            return [
                currentTheme.accent.opacity(opacity1),
                currentTheme.primary.opacity(opacity2)
            ]

        case .success:
            return [
                currentTheme.success.opacity(opacity1),
                currentTheme.info.opacity(opacity2)
            ]

        case .warning:
            return [
                currentTheme.warning.opacity(opacity1),
                currentTheme.error.opacity(opacity2)
            ]

        case .error:
            return [
                currentTheme.error.opacity(opacity1),
                currentTheme.warning.opacity(opacity2)
            ]

        case .lecture:
            return [
                currentTheme.lectureStart.opacity(opacity1),
                currentTheme.lectureEnd.opacity(opacity2)
            ]

        case .exercise:
            return [
                currentTheme.exerciseStart.opacity(opacity1),
                currentTheme.exerciseEnd.opacity(opacity2)
            ]

        case .laboratory:
            return [
                currentTheme.laboratoryStart.opacity(opacity1),
                currentTheme.laboratoryEnd.opacity(opacity2)
            ]

        case .header:
            return scheme == .dark
                ? [currentTheme.primary, currentTheme.secondary.opacity(opacity2)]
                : [currentTheme.accent, currentTheme.primary.opacity(opacity2)]

        case .online:
            return [
                currentTheme.online.opacity(0.95),
                currentTheme.warning.opacity(opacity2)
            ]

        case .cancelled:
            return [
                currentTheme.cancelled.opacity(0.95),
                currentTheme.cancelled.opacity(0.85)
            ]
        }
    }

    func linearGradient(
        for scheme: ColorScheme,
        startPoint: UnitPoint = .topLeading,
        endPoint: UnitPoint = .bottomTrailing,
        theme: (any Theme)? = nil
    ) -> LinearGradient {
        LinearGradient(
            colors: colors(for: scheme, theme: theme),
            startPoint: startPoint,
            endPoint: endPoint
        )
    }
}

// MARK: - View Extension
extension View {
    func themedForeground(_ style: GradientStyle, colorScheme: ColorScheme, theme: (any Theme)? = nil) -> some View {
        self.foregroundStyle(
            LinearGradient(
                colors: style.colors(for: colorScheme, theme: theme),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Icons/AppIcon.swift =====
import SwiftUI

enum AppIcon {
    // MARK: - Navigation
    case calendar
    case people
    case gear
    case chevronLeft
    case chevronRight
    case chevronUp
    case chevronDown
    case chevronLeftCircleFill
    case chevronRightCircleFill

    // MARK: - Actions
    case checkmark
    case xmark
    case plus
    case minus
    case trash
    case docOnDoc
    case arrowClockwise
    case pencil
    case squareAndArrowUp

    // MARK: - Status
    case checkmarkCircleFill
    case exclamationTriangleFill
    case exclamationMarkCircle
    case infoCircle
    case wifiSlash
    case wifi
    case circle
    case circleFill
    case circleLeftHalfFilled  // NEW

    // MARK: - Calendar
    case calendarBadgeCheckmark
    case clock
    case clockFill

    // MARK: - People
    case person
    case person2
    case person3Fill
    case personFill
    case person2Slash

    // MARK: - Search
    case magnifyingGlass
    case listBullet
    case lineHorizontal3DecreaseCircle

    // MARK: - Misc
    case envelope
    case lockOpen
    case paintpaletteFill

    // MARK: - Themes / Appearance (NEW)
    case sunMaxFill
    case moonFill
    case waterWaves
    case sunsetFill
    case leafFill
    case sparkles
    case sparkle
    case heartFill
    case moonStarsFill
    case squareGrid2x2Fill

    // MARK: - System Name
    var systemName: String {
        switch self {
        // Navigation
        case .calendar: return "calendar"
        case .people: return "person.2"
        case .gear: return "gear"
        case .chevronLeft: return "chevron.left"
        case .chevronRight: return "chevron.right"
        case .chevronUp: return "chevron.up"
        case .chevronDown: return "chevron.down"
        case .chevronLeftCircleFill: return "chevron.left.circle.fill"
        case .chevronRightCircleFill: return "chevron.right.circle.fill"

        // Actions
        case .checkmark: return "checkmark"
        case .xmark: return "xmark"
        case .plus: return "plus"
        case .minus: return "minus"
        case .trash: return "trash"
        case .docOnDoc: return "doc.on.doc"
        case .arrowClockwise: return "arrow.clockwise"
        case .pencil: return "pencil"
        case .squareAndArrowUp: return "square.and.arrow.up"

        // Status
        case .checkmarkCircleFill: return "checkmark.circle.fill"
        case .exclamationTriangleFill: return "exclamationmark.triangle.fill"
        case .exclamationMarkCircle: return "exclamationmark.circle"
        case .infoCircle: return "info.circle"
        case .wifiSlash: return "wifi.slash"
        case .wifi: return "wifi"
        case .circle: return "circle"
        case .circleFill: return "circle.fill"
        case .circleLeftHalfFilled: return "circle.lefthalf.filled"

        // Calendar
        case .calendarBadgeCheckmark: return "calendar.badge.checkmark"
        case .clock: return "clock"
        case .clockFill: return "clock.fill"

        // People
        case .person: return "person"
        case .person2: return "person.2"
        case .person3Fill: return "person.3.fill"
        case .personFill: return "person.fill"
        case .person2Slash: return "person.2.slash"

        // Search
        case .magnifyingGlass: return "magnifyingglass"
        case .listBullet: return "list.bullet"
        case .lineHorizontal3DecreaseCircle: return "line.horizontal.3.decrease.circle"

        // Misc
        case .envelope: return "envelope"
        case .lockOpen: return "lock.open"
        case .paintpaletteFill: return "paintpalette.fill"

        // Themes / Appearance
        case .sunMaxFill: return "sun.max.fill"
        case .moonFill: return "moon.fill"
        case .waterWaves: return "water.waves"
        case .sunsetFill: return "sunset.fill"
        case .leafFill: return "leaf.fill"
        case .sparkles: return "sparkles"
        case .sparkle: return "sparkle"
        case .heartFill: return "heart.fill"
        case .moonStarsFill: return "moon.stars.fill"
        case .squareGrid2x2Fill: return "square.grid.2x2.fill"
        }
    }

    // MARK: - Image
    func image() -> Image {
        Image(systemName: systemName)
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Spacing/AppCornerRadius.swift =====
import Foundation

public enum AppCornerRadius {
    case xs
    case small
    case medium
    case large
    case xl
    case xxl
    case circle
    case custom(CGFloat)
    
    public var value: CGFloat {
        switch self {
        case .xs: return 4
        case .small: return 8
        case .medium: return 12
        case .large: return 16
        case .xl: return 24
        case .xxl: return 32
        case .circle: return 999
        case .custom(let value): return value
        }
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Spacing/AppDimensions.swift =====
import Foundation

enum AppDimensions {
    // MARK: - Icons
    case iconXS
    case iconSmall
    case iconMedium
    case iconLarge
    case iconXL
    
    // MARK: - Avatar
    case avatarSmall
    case avatarMedium
    case avatarLarge
    
    // MARK: - Components
    case chipMinHeight
    case chipCompactHeight
    case chipMaxHeight
    case tabBarHeight
    case headerMinHeight
    case buttonHeight
    
    // MARK: - Lines
    case lineXS
    case lineSmall
    case lineMedium
    
    // MARK: - Dots
    case dotSmall
    case dotMedium
    case dotLarge
    
    // MARK: - Gestures
    case minimumSwipeDistance
    case weekChangeThreshold
    
    var value: CGFloat {
        switch self {
        // Icons
        case .iconXS: return 12
        case .iconSmall: return 16
        case .iconMedium: return 20
        case .iconLarge: return 24
        case .iconXL: return 32
            
        // Avatar
        case .avatarSmall: return 32
        case .avatarMedium: return 40
        case .avatarLarge: return 48
            
        // Components
        case .chipMinHeight: return 56
        case .chipCompactHeight: return 58
        case .chipMaxHeight: return 72
        case .tabBarHeight: return 70
        case .headerMinHeight: return 200
        case .buttonHeight: return 44
            
        // Lines
        case .lineXS: return 1
        case .lineSmall: return 2
        case .lineMedium: return 4
            
        // Dots
        case .dotSmall: return 4
        case .dotMedium: return 6
        case .dotLarge: return 8
            
        // Gestures
        case .minimumSwipeDistance: return 30
        case .weekChangeThreshold: return 100
        }
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Spacing/AppSpacing.swift =====
import Foundation

enum AppSpacing {
    case xxs
    case xs
    case small
    case medium
    case large
    case xl
    case xxl
    case xxxl
    case custom(CGFloat)
    
    var value: CGFloat {
        switch self {
        case .xxs: return 2
        case .xs: return 4
        case .small: return 8
        case .medium: return 12
        case .large: return 16
        case .xl: return 20
        case .xxl: return 24
        case .xxxl: return 32
        case .custom(let value): return value
        }
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Themes/AppTheme.swift =====
import SwiftUI

enum ThemeConst {
    enum id {
        static let `default`   = "default"
        static let ocean       = "ocean"
        static let sunset      = "sunset"
        static let forest      = "forest"
        static let lavender    = "lavender"
        static let cherry      = "cherry"
        static let midnight    = "midnight"
        static let monochrome  = "monochrome"
    }

    /// Технические имена тем (могут использоваться как fallback/отладка).
    /// Для UI мы показываем локализованное имя через `LocalizedString.themeName(for:)`.
    enum name {
        static let `default`   = "Default"
        static let ocean       = "Ocean"
        static let sunset      = "Sunset"
        static let forest      = "Forest"
        static let lavender    = "Lavender"
        static let cherry      = "Cherry Blossom"
        static let midnight    = "Midnight"
        static let monochrome  = "Monochrome"
    }
}

// MARK: - Theme Protocol

protocol Theme {
    var id: String { get }
    var name: String { get }      // техническое имя (для логов / fallback)
    var icon: AppIcon { get }     // системная иконка через AppIcon
    var isDark: Bool { get }

    var primary: Color { get }
    var secondary: Color { get }
    var tertiary: Color { get }
    var accent: Color { get }

    var lectureStart: Color { get }
    var lectureEnd: Color { get }
    var exerciseStart: Color { get }
    var exerciseEnd: Color { get }
    var laboratoryStart: Color { get }
    var laboratoryEnd: Color { get }

    var success: Color { get }
    var warning: Color { get }
    var error: Color { get }
    var info: Color { get }

    var online: Color { get }
    var cancelled: Color { get }
}

// MARK: - Default Theme

struct DefaultTheme: Theme {
    let id = ThemeConst.id.default
    let name = ThemeConst.name.default
    let icon: AppIcon = .sparkles
    let isDark: Bool

    var primary: Color { isDark ? Color.purple.opacity(0.9) : Color.pink.opacity(0.9) }
    var secondary: Color { isDark ? Color.blue.opacity(0.7) : Color.purple.opacity(0.7) }
    var tertiary: Color { isDark ? Color.pink.opacity(0.8) : Color.blue.opacity(0.6) }
    var accent: Color { isDark ? Color.purple : Color.pink }

    var lectureStart: Color { Color(red: 1.0, green: 0.5, blue: 0.0) }
    var lectureEnd: Color { Color(red: 0.9, green: 0.2, blue: 0.1) }
    var exerciseStart: Color { Color(red: 0.1, green: 0.6, blue: 1.0) }
    var exerciseEnd: Color { Color(red: 0.0, green: 0.8, blue: 0.9) }
    var laboratoryStart: Color { Color(red: 0.7, green: 0.2, blue: 0.9) }
    var laboratoryEnd: Color { Color(red: 0.9, green: 0.3, blue: 0.7) }

    var success: Color { Color(red: 0.18, green: 0.78, blue: 0.70) }
    var warning: Color { .orange }
    var error: Color { .red }
    var info: Color { Color(red: 0.40, green: 0.45, blue: 0.95) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.85, blue: 0.2) : Color(red: 1.0, green: 0.75, blue: 0.0) }
    var cancelled: Color { isDark ? Color(red: 0.95, green: 0.2, blue: 0.25) : Color(red: 0.9, green: 0.15, blue: 0.2) }
}

// MARK: - Ocean Theme

struct OceanTheme: Theme {
    let id = ThemeConst.id.ocean
    let name = ThemeConst.name.ocean
    let icon: AppIcon = .waterWaves
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 0.2, green: 0.6, blue: 0.86) : Color(red: 0.0, green: 0.48, blue: 0.8) }
    var secondary: Color { isDark ? Color(red: 0.0, green: 0.7, blue: 0.8) : Color(red: 0.0, green: 0.55, blue: 0.65) }
    var tertiary: Color { isDark ? Color(red: 0.1, green: 0.4, blue: 0.7) : Color(red: 0.0, green: 0.35, blue: 0.6) }
    var accent: Color { isDark ? Color.cyan : Color.teal }

    var lectureStart: Color { Color(red: 1.0, green: 0.6, blue: 0.2) }
    var lectureEnd: Color { Color(red: 0.9, green: 0.3, blue: 0.2) }
    var exerciseStart: Color { Color(red: 0.0, green: 0.7, blue: 1.0) }
    var exerciseEnd: Color { Color(red: 0.2, green: 0.9, blue: 1.0) }
    var laboratoryStart: Color { Color(red: 0.1, green: 0.5, blue: 0.7) }
    var laboratoryEnd: Color { Color(red: 0.0, green: 0.65, blue: 0.8) }

    var success: Color { Color(red: 0.0, green: 0.75, blue: 0.65) }
    var warning: Color { Color(red: 1.0, green: 0.7, blue: 0.0) }
    var error: Color { Color(red: 0.9, green: 0.3, blue: 0.3) }
    var info: Color { Color.cyan }

    var online: Color { isDark ? Color(red: 1.0, green: 0.9, blue: 0.3) : Color(red: 1.0, green: 0.8, blue: 0.1) }
    var cancelled: Color { isDark ? Color(red: 0.95, green: 0.25, blue: 0.3) : Color(red: 0.9, green: 0.2, blue: 0.25) }
}

// MARK: - Sunset Theme

struct SunsetTheme: Theme {
    let id = ThemeConst.id.sunset
    let name = ThemeConst.name.sunset
    let icon: AppIcon = .sunsetFill
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 1.0, green: 0.45, blue: 0.35) : Color(red: 0.95, green: 0.3, blue: 0.2) }
    var secondary: Color { isDark ? Color(red: 1.0, green: 0.6, blue: 0.2) : Color(red: 0.9, green: 0.5, blue: 0.1) }
    var tertiary: Color { isDark ? Color(red: 0.9, green: 0.35, blue: 0.5) : Color(red: 0.85, green: 0.25, blue: 0.4) }
    var accent: Color { isDark ? Color.orange : Color(red: 1.0, green: 0.3, blue: 0.3) }

    var lectureStart: Color { Color(red: 1.0, green: 0.4, blue: 0.0) }
    var lectureEnd: Color { Color(red: 0.95, green: 0.15, blue: 0.1) }
    var exerciseStart: Color { Color(red: 1.0, green: 0.75, blue: 0.2) }
    var exerciseEnd: Color { Color(red: 1.0, green: 0.55, blue: 0.0) }
    var laboratoryStart: Color { Color(red: 0.9, green: 0.2, blue: 0.5) }
    var laboratoryEnd: Color { Color(red: 0.75, green: 0.1, blue: 0.35) }

    var success: Color { Color(red: 1.0, green: 0.7, blue: 0.2) }
    var warning: Color { Color(red: 1.0, green: 0.55, blue: 0.1) }
    var error: Color { Color(red: 0.9, green: 0.2, blue: 0.2) }
    var info: Color { Color(red: 1.0, green: 0.6, blue: 0.3) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.85, blue: 0.25) : Color(red: 1.0, green: 0.75, blue: 0.1) }
    var cancelled: Color { isDark ? Color(red: 0.95, green: 0.15, blue: 0.2) : Color(red: 0.9, green: 0.1, blue: 0.15) }
}

// MARK: - Forest Theme

struct ForestTheme: Theme {
    let id = ThemeConst.id.forest
    let name = ThemeConst.name.forest
    let icon: AppIcon = .leafFill
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 0.4, green: 0.75, blue: 0.45) : Color(red: 0.2, green: 0.65, blue: 0.3) }
    var secondary: Color { isDark ? Color(red: 0.5, green: 0.85, blue: 0.6) : Color(red: 0.3, green: 0.75, blue: 0.4) }
    var tertiary: Color { isDark ? Color(red: 0.3, green: 0.6, blue: 0.4) : Color(red: 0.15, green: 0.5, blue: 0.25) }
    var accent: Color { isDark ? Color.mint : Color.green }

    var lectureStart: Color { Color(red: 0.8, green: 0.7, blue: 0.2) }
    var lectureEnd: Color { Color(red: 0.6, green: 0.5, blue: 0.1) }
    var exerciseStart: Color { Color(red: 0.2, green: 0.6, blue: 0.5) }
    var exerciseEnd: Color { Color(red: 0.1, green: 0.5, blue: 0.4) }
    var laboratoryStart: Color { Color(red: 0.5, green: 0.8, blue: 0.3) }
    var laboratoryEnd: Color { Color(red: 0.3, green: 0.7, blue: 0.2) }

    var success: Color { Color(red: 0.3, green: 0.8, blue: 0.4) }
    var warning: Color { Color(red: 0.9, green: 0.75, blue: 0.2) }
    var error: Color { Color(red: 0.85, green: 0.35, blue: 0.3) }
    var info: Color { Color(red: 0.4, green: 0.75, blue: 0.5) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.9, blue: 0.2) : Color(red: 1.0, green: 0.8, blue: 0.0) }
    var cancelled: Color { isDark ? Color(red: 0.9, green: 0.2, blue: 0.25) : Color(red: 0.85, green: 0.15, blue: 0.2) }
}

// MARK: - Lavender Theme

struct LavenderTheme: Theme {
    let id = ThemeConst.id.lavender
    let name = ThemeConst.name.lavender
    let icon: AppIcon = .sparkle
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 0.7, green: 0.6, blue: 0.9) : Color(red: 0.6, green: 0.45, blue: 0.8) }
    var secondary: Color { isDark ? Color(red: 0.8, green: 0.7, blue: 0.95) : Color(red: 0.7, green: 0.55, blue: 0.85) }
    var tertiary: Color { isDark ? Color(red: 0.6, green: 0.5, blue: 0.8) : Color(red: 0.5, green: 0.35, blue: 0.7) }
    var accent: Color { isDark ? Color(red: 0.75, green: 0.65, blue: 0.95) : Color(red: 0.65, green: 0.5, blue: 0.85) }

    var lectureStart: Color { Color(red: 0.5, green: 0.3, blue: 0.9) }
    var lectureEnd: Color { Color(red: 0.4, green: 0.2, blue: 0.75) }
    var exerciseStart: Color { Color(red: 0.7, green: 0.5, blue: 1.0) }
    var exerciseEnd: Color { Color(red: 0.6, green: 0.4, blue: 0.9) }
    var laboratoryStart: Color { Color(red: 0.85, green: 0.4, blue: 0.9) }
    var laboratoryEnd: Color { Color(red: 0.75, green: 0.3, blue: 0.8) }

    var success: Color { Color(red: 0.6, green: 0.8, blue: 0.7) }
    var warning: Color { Color(red: 0.9, green: 0.7, blue: 0.5) }
    var error: Color { Color(red: 0.9, green: 0.4, blue: 0.5) }
    var info: Color { Color(red: 0.7, green: 0.6, blue: 0.9) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.9, blue: 0.3) : Color(red: 1.0, green: 0.8, blue: 0.1) }
    var cancelled: Color { isDark ? Color(red: 0.95, green: 0.25, blue: 0.35) : Color(red: 0.9, green: 0.2, blue: 0.3) }
}

// MARK: - Cherry Blossom Theme

struct CherryBlossomTheme: Theme {
    let id = ThemeConst.id.cherry
    let name = ThemeConst.name.cherry
    let icon: AppIcon = .heartFill
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 1.0, green: 0.7, blue: 0.8) : Color(red: 0.95, green: 0.5, blue: 0.65) }
    var secondary: Color { isDark ? Color(red: 0.95, green: 0.6, blue: 0.75) : Color(red: 0.9, green: 0.4, blue: 0.6) }
    var tertiary: Color { isDark ? Color(red: 0.9, green: 0.5, blue: 0.7) : Color(red: 0.85, green: 0.35, blue: 0.55) }
    var accent: Color { isDark ? Color.pink : Color(red: 0.95, green: 0.4, blue: 0.6) }

    var lectureStart: Color { Color(red: 1.0, green: 0.5, blue: 0.7) }
    var lectureEnd: Color { Color(red: 0.9, green: 0.3, blue: 0.5) }
    var exerciseStart: Color { Color(red: 1.0, green: 0.75, blue: 0.85) }
    var exerciseEnd: Color { Color(red: 0.95, green: 0.6, blue: 0.75) }
    var laboratoryStart: Color { Color(red: 0.9, green: 0.45, blue: 0.75) }
    var laboratoryEnd: Color { Color(red: 0.75, green: 0.25, blue: 0.55) }

    var success: Color { Color(red: 0.9, green: 0.75, blue: 0.8) }
    var warning: Color { Color(red: 1.0, green: 0.75, blue: 0.6) }
    var error: Color { Color(red: 0.95, green: 0.35, blue: 0.45) }
    var info: Color { Color(red: 0.95, green: 0.7, blue: 0.85) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.9, blue: 0.35) : Color(red: 1.0, green: 0.8, blue: 0.15) }
    var cancelled: Color { isDark ? Color(red: 0.95, green: 0.2, blue: 0.3) : Color(red: 0.9, green: 0.15, blue: 0.25) }
}

// MARK: - Midnight Theme

struct MidnightTheme: Theme {
    let id = ThemeConst.id.midnight
    let name = ThemeConst.name.midnight
    let icon: AppIcon = .moonStarsFill
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 0.4, green: 0.5, blue: 0.9) : Color(red: 0.25, green: 0.35, blue: 0.75) }
    var secondary: Color { isDark ? Color(red: 0.5, green: 0.4, blue: 0.85) : Color(red: 0.35, green: 0.25, blue: 0.7) }
    var tertiary: Color { isDark ? Color(red: 0.3, green: 0.45, blue: 0.8) : Color(red: 0.2, green: 0.3, blue: 0.65) }
    var accent: Color { isDark ? Color.indigo : Color(red: 0.3, green: 0.4, blue: 0.8) }

    var lectureStart: Color { Color(red: 0.3, green: 0.5, blue: 1.0) }
    var lectureEnd: Color { Color(red: 0.2, green: 0.35, blue: 0.8) }
    var exerciseStart: Color { Color(red: 0.5, green: 0.35, blue: 0.9) }
    var exerciseEnd: Color { Color(red: 0.35, green: 0.2, blue: 0.7) }
    var laboratoryStart: Color { Color(red: 0.4, green: 0.6, blue: 0.95) }
    var laboratoryEnd: Color { Color(red: 0.25, green: 0.45, blue: 0.75) }

    var success: Color { Color(red: 0.4, green: 0.7, blue: 0.9) }
    var warning: Color { Color(red: 0.8, green: 0.65, blue: 0.4) }
    var error: Color { Color(red: 0.85, green: 0.4, blue: 0.5) }
    var info: Color { Color(red: 0.5, green: 0.6, blue: 0.95) }

    var online: Color { isDark ? Color(red: 1.0, green: 0.9, blue: 0.3) : Color(red: 1.0, green: 0.8, blue: 0.1) }
    var cancelled: Color { isDark ? Color(red: 0.9, green: 0.25, blue: 0.3) : Color(red: 0.85, green: 0.2, blue: 0.25) }
}

// MARK: - Monochrome Theme

struct MonochromeTheme: Theme {
    let id = ThemeConst.id.monochrome
    let name = ThemeConst.name.monochrome
    let icon: AppIcon = .squareGrid2x2Fill
    let isDark: Bool

    var primary: Color { isDark ? Color(red: 0.45, green: 0.5, blue: 0.55) : Color(red: 0.4, green: 0.42, blue: 0.45) }
    var secondary: Color { isDark ? Color(red: 0.35, green: 0.38, blue: 0.42) : Color(red: 0.5, green: 0.52, blue: 0.55) }
    var tertiary: Color { isDark ? Color(red: 0.3, green: 0.33, blue: 0.37) : Color(red: 0.55, green: 0.57, blue: 0.6) }
    var accent: Color { isDark ? Color(red: 0.5, green: 0.55, blue: 0.6) : Color(red: 0.35, green: 0.38, blue: 0.42) }

    var lectureStart: Color { Color(red: 0.6, green: 0.5, blue: 0.4) }
    var lectureEnd: Color { Color(red: 0.5, green: 0.42, blue: 0.35) }
    var exerciseStart: Color { Color(red: 0.4, green: 0.48, blue: 0.55) }
    var exerciseEnd: Color { Color(red: 0.35, green: 0.42, blue: 0.48) }
    var laboratoryStart: Color { Color(red: 0.45, green: 0.52, blue: 0.45) }
    var laboratoryEnd: Color { Color(red: 0.38, green: 0.45, blue: 0.38) }

    var success: Color { Color(red: 0.4, green: 0.55, blue: 0.5) }
    var warning: Color { Color(red: 0.65, green: 0.55, blue: 0.4) }
    var error: Color { Color(red: 0.6, green: 0.4, blue: 0.4) }
    var info: Color { Color(red: 0.4, green: 0.48, blue: 0.55) }

    var online: Color { isDark ? Color(red: 0.8, green: 0.75, blue: 0.5) : Color(red: 0.75, green: 0.7, blue: 0.45) }
    var cancelled: Color { isDark ? Color(red: 0.7, green: 0.45, blue: 0.45) : Color(red: 0.65, green: 0.4, blue: 0.4) }
}

// MARK: - Theme Factory

struct ThemeFactory {
    static func allThemes(for colorScheme: ColorScheme) -> [any Theme] {
        let isDark = colorScheme == .dark
        return [
            DefaultTheme(isDark: isDark),
            OceanTheme(isDark: isDark),
            SunsetTheme(isDark: isDark),
            ForestTheme(isDark: isDark),
            LavenderTheme(isDark: isDark),
            CherryBlossomTheme(isDark: isDark),
            MidnightTheme(isDark: isDark),
            MonochromeTheme(isDark: isDark)
        ]
    }

    static func theme(withId id: String, for colorScheme: ColorScheme) -> any Theme {
        let isDark = colorScheme == .dark
        switch id {
        case ThemeConst.id.ocean:      return OceanTheme(isDark: isDark)
        case ThemeConst.id.sunset:     return SunsetTheme(isDark: isDark)
        case ThemeConst.id.forest:     return ForestTheme(isDark: isDark)
        case ThemeConst.id.lavender:   return LavenderTheme(isDark: isDark)
        case ThemeConst.id.cherry:     return CherryBlossomTheme(isDark: isDark)
        case ThemeConst.id.midnight:   return MidnightTheme(isDark: isDark)
        case ThemeConst.id.monochrome: return MonochromeTheme(isDark: isDark)
        default:                       return DefaultTheme(isDark: isDark)
        }
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Themes/ThemeManager.swift =====
import SwiftUI
import Combine
import WidgetKit

// MARK: - Appearance Mode

enum AppearanceMode: String, CaseIterable, Identifiable {
    case system
    case light
    case dark

    var id: String { rawValue }

    var displayName: String {
        switch self {
        case .system: return LocalizedString.appearanceSystem.localized
        case .light:  return LocalizedString.appearanceLight.localized
        case .dark:   return LocalizedString.appearanceDark.localized
        }
    }

    var icon: AppIcon {
        switch self {
        case .system: return .circleLeftHalfFilled
        case .light:  return .sunMaxFill
        case .dark:   return .moonFill
        }
    }
}

// MARK: - Theme Manager

class ThemeManager: ObservableObject {
    static let shared = ThemeManager()

    // MARK: - Published Properties

    @Published var selectedThemeId: String {
        didSet {
            UserDefaults.standard.set(selectedThemeId, forKey: Keys.selectedTheme)
            // Save to App Group for widget
            AppGroupManager.saveSelectedTheme(id: selectedThemeId, appearanceMode: appearanceMode.rawValue)
            WidgetCenter.shared.reloadAllTimelines()
        }
    }

    @Published var appearanceMode: AppearanceMode {
        didSet {
            UserDefaults.standard.set(appearanceMode.rawValue, forKey: Keys.appearanceMode)
            applyAppearanceMode()
            // Save to App Group for widget
            AppGroupManager.saveSelectedTheme(id: selectedThemeId, appearanceMode: appearanceMode.rawValue)
            WidgetCenter.shared.reloadAllTimelines()
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let selectedTheme = "app.theme.selected"
        static let appearanceMode = "app.appearance.mode"
    }

    // MARK: - Initialization

    private init() {
        self.selectedThemeId = UserDefaults.standard.string(forKey: Keys.selectedTheme) ?? "default"
        let modeString = UserDefaults.standard.string(forKey: Keys.appearanceMode) ?? "system"
        self.appearanceMode = AppearanceMode(rawValue: modeString) ?? .system
        applyAppearanceMode()
    }

    // MARK: - Methods

    func currentTheme(for colorScheme: ColorScheme) -> any Theme {
        ThemeFactory.theme(withId: selectedThemeId, for: colorScheme)
    }

    func allThemes(for colorScheme: ColorScheme) -> [any Theme] {
        ThemeFactory.allThemes(for: colorScheme)
    }

    private func applyAppearanceMode() {
        #if !APPEXTENSION
        DispatchQueue.main.async {
            guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                  let window = windowScene.windows.first else {
                return
            }

            switch self.appearanceMode {
            case .system:
                window.overrideUserInterfaceStyle = .unspecified
            case .light:
                window.overrideUserInterfaceStyle = .light
            case .dark:
                window.overrideUserInterfaceStyle = .dark
            }
        }
        #endif
    }

    func selectTheme(_ themeId: String) {
        selectedThemeId = themeId
    }

    func setAppearanceMode(_ mode: AppearanceMode) {
        appearanceMode = mode
    }
}

// MARK: - Environment Key

private struct ThemeManagerKey: EnvironmentKey {
    static let defaultValue = ThemeManager.shared
}

extension EnvironmentValues {
    var themeManager: ThemeManager {
        get { self[ThemeManagerKey.self] }
        set { self[ThemeManagerKey.self] = newValue }
    }
}

// ===== FILE: Timetable DSW/Core/DesignSystem/Typography/AppTypography.swift =====
import SwiftUI

enum AppTypography {
    case largeTitle
    case title
    case title2
    case title3
    case headline
    case subheadline
    case body
    case bodyMedium
    case bodySemibold
    case callout
    case caption
    case caption2
    case footnote
    case custom(size: CGFloat, weight: Font.Weight)
    
    var font: Font {
        switch self {
        case .largeTitle: return .largeTitle
        case .title: return .title
        case .title2: return .title2
        case .title3: return .title3
        case .headline: return .headline
        case .subheadline: return .subheadline
        case .body: return .body
        case .bodyMedium: return .system(size: 17, weight: .medium)
        case .bodySemibold: return .system(size: 17, weight: .semibold)
        case .callout: return .callout
        case .caption: return .caption
        case .caption2: return .caption2
        case .footnote: return .footnote
        case .custom(let size, let weight): return .system(size: size, weight: weight)
        }
    }
}

// ===== FILE: Timetable DSW/Core/Helpers/CalendarHelper.swift =====
//
//  CalendarHelper.swift
//  Timetable DSW
//
//  Created by Mikita Laptsionak on 18/10/2025.
//

import Foundation

enum CalendarHelper {
    /// Генерирует массив дат внутри заданного интервала
    /// - Parameters:
    ///   - calendar: Calendar для использования
    ///   - interval: Интервал дат
    ///   - components: Компоненты для поиска совпадений
    /// - Returns: Массив дат
    static func generateDates(
        in calendar: Calendar,
        inside interval: DateInterval,
        matching components: DateComponents
    ) -> [Date] {
        var dates: [Date] = []
        dates.append(interval.start)
        
        calendar.enumerateDates(
            startingAfter: interval.start,
            matching: components,
            matchingPolicy: .nextTime
        ) { date, _, stop in
            if let date = date {
                if date < interval.end {
                    dates.append(date)
                } else {
                    stop = true
                }
            }
        }
        
        return dates
    }
}

// ===== FILE: Timetable DSW/Core/Localization/LocalizedString.swift =====
import Foundation

enum LocalizedString {
    // MARK: - General
    case generalCancel
    case generalDone
    case generalToday
    case generalRetry
    case generalRefresh
    case generalOnline
    case generalOffline
    case generalCancelled
    case generalLoading

    // MARK: - Greeting
    case greetingMorning
    case greetingAfternoon
    case greetingEvening
    case greetingNight

    // MARK: - Schedule
    case scheduleTitle
    case scheduleSelectDate
    case scheduleHasClasses
    case scheduleOnlineOnly
    case scheduleNoClasses
    case scheduleEnjoyFreeTime
    case scheduleLoading
    case scheduleLastUpdated

    // MARK: - Groups
    case groupsSelect
    case groupsSelected
    case groupsNoSelection
    case groupsSearch
    case groupsLoading
    case groupsNoAvailable
    case groupsNoFound
    case groupsPullToRefresh
    case groupsAdjustSearch

    // MARK: - Teachers
    case teachersTitle
    case teachersSearch
    case teachersLoading
    case teachersNoFound
    case teachersClasses
    case teachersNoData
    case teachersLoadScheduleFirst

    // MARK: - Subjects (NEW)
    case subjectsTitle
    case subjectsSearch
    case subjectsLoading
    case subjectsNoFound
    case subjectsClasses
    case subjectsNoData
    case subjectsLoadScheduleFirst
    case subjectsStats
    case subjectsTotal
    case subjectsPast
    case subjectsUpcoming
    case subjectsLectures
    case subjectsExercises
    case subjectsLaboratories
    case subjectsGradingType

    // MARK: - Settings
    case settingsTitle
    case settingsGroupSettings
    case settingsThemeSectionTitle
    case settingsThemeSectionHeader
    case settingsThemeSectionFooter
    case settingsCacheStatus
    case settingsClearCache
    case settingsClearCacheMessage
    case settingsVersion
    case settingsAbout
    case settingsEvents
    case settingsLastUpdated
    case settingsNever
    case settingsPleaseSelectGroup

    // MARK: - Tabs
    case tabsSchedule
    case tabsTeachers
    case tabsSettings
    case tabsSubjects

    // MARK: - Error
    case errorTitle
    case errorInvalidURL
    case errorInvalidResponse
    case errorServer

    // MARK: - Days
    case daysMonday
    case daysTuesday
    case daysWednesday
    case daysThursday
    case daysFriday
    case daysSaturday
    case daysSunday

    // MARK: - Support / Contact (NEW)
    case settingsContactTitle
    case settingsSupportSectionTitle
    case settingsSupportFooter

    // MARK: - Developer Support (NEW)
    case settingsDeveloperSectionTitle
    case settingsDeveloperAction
    case settingsDeveloperFooter

    // MARK: - Contact actions (NEW)
    case contactActionReportProblem
    case contactActionRequestFeature

    // MARK: - Mail / system (NEW)
    case mailUnavailableTitle
    /// uses %@ placeholder for email
    case mailUnavailableMessage
    case mailCopyAddress

    // MARK: - Email subjects (NEW)
    case contactEmailSubjectBug
    case contactEmailSubjectFeature

    // MARK: - Email body headers (NEW)
    case contactEmailBodyBugHeader
    case contactEmailBodyFeatureHeader

    // MARK: - Email info labels (NEW)
    case contactEmailInfoApp
    case contactEmailInfoiOS
    case contactEmailInfoDevice
    case contactEmailInfoLocale
    case contactEmailInfoGroup
    case contactEmailInfoDate

    case contactEmailBodyAdditionalInfo
    case contactEmailBodyDetailsTitle

    // MARK: - Premium
    case premiumFeatureTitle
    case premiumTapToUnlock
    case premiumActive
    case premiumThankYou
    case premiumEnjoyFeatures
    case premiumTimeRemaining
    case premiumWatchOrPurchase
    case premiumUnlockTitle
    case premiumGetAccess
    case premiumWatchAdButton
    case premiumPurchaseButton
    case premiumUnlocked
    case premiumMaybeLater
    case premiumCalculating
    case premiumRemaining

    // MARK: - Settings Premium
    case settingsPremiumActive

    // MARK: - Debug
    case debugTools
    case debugDone
    case debugResetAllFlags
    case debugResetConfirm
    case debugCancel
    case debugPremiumStatus
    case debugPremiumControls
    case debugGrantPermanentPremium
    case debugGrant1HourPremium
    case debugRevokePremium
    case debugFeatureFlags
    case debugFlagsFooter
    case debugActions
    case debugResetToDefault
    case debugSyncFromRemote
    case debugShowDetails
    case debugHideDetails

    // MARK: - Debug Menu (Extended)
    case debugMenuTitle
    case debugActionResult
    case debugOK
    case debugConfirm
    case debugFree
    case debugPremiumLabel
    case debugTrial
    case debugStatus
    case debugExpires
    case debugGrantPremium
    case debugGrantTrial1h
    case debugRevokePremiumLabel
    case debugPremiumManagement
    case debugFeatureFlagsTitle
    case debugLocalOverrides
    case debugLastSynced
    case debugActionsTitle
    case debugSyncFromServer
    case debugClearAllData
    case debugStatistics
    case debugAdsWatched
    case debugLastAd
    case debugPremiumSince
    case debugAbout
    case debugEnvironment
    case debugDebug
    case debugRelease
    case debugBuild
    case debugOnlyInDebugBuilds
    case debugResetToDefaultLabel
    case debugResetAllFlagsLabel
    case debugRevokePremiumQuestion
    case debugResetAllFlagsQuestion
    case debugClearAllDataQuestion
    case debugConfirmActionQuestion
    case debugWillRemovePremium
    case debugWillResetAllFlags
    case debugWillResetEverything
    case debugAreYouSure
    case debugPremiumGranted
    case debugTemporaryPremiumGranted
    case debugPremiumRevoked
    case debugAllFlagsReset
    case debugAllDataCleared
    case debugFlagResetTemplate
    case debugSyncFailedTemplate

    // MARK: - Performance Monitor
    case perfMonitorTitle
    case perfMonitorClear
    case perfMonitorExport
    case perfMonitorExportedEvents
    case perfMonitorMetrics
    case perfMonitorTotalEvents
    case perfMonitorAverageDuration
    case perfMonitorSlowestEvent
    case perfMonitorFastestEvent
    case perfMonitorFilterByCategory
    case perfMonitorCategory
    case perfMonitorAll
    case perfMonitorEvents
    case perfMonitorNoEventsRecorded

    // MARK: - Ads Debug
    case adsDebugTitle
    case adsDebugAdaptiveBanner
    case adsDebugBannerAd
    case adsDebugBannerDescription
    case adsDebugNativeAd
    case adsDebugNativeDescription
    case adsDebugLoad
    case adsDebugShow
    case adsDebugReadyToShow
    case adsDebugInterstitialAd
    case adsDebugInterstitialDescription
    case adsDebugRewardedAd
    case adsDebugRewardedDescription
    case adsDebugRewardedInterstitial
    case adsDebugRewardedInterstitialDescription
    case adsDebugPreload
    case adsDebugAppOpenAd
    case adsDebugAppOpenDescription
    case adsDebugDeveloperTools
    case adsDebugLaunchAdInspector
    case adsDebugAdInspectorDescription
    case adsDebugEventLog
    case adsDebugNoEventsYet
    case adsDebugClearLog

    // MARK: - Ad Loading
    case adLoadingText
    case adLoadingFailed
    case adLoadingRetry

    // MARK: - Theme Settings (NEW)
    case themeSettingsTitle
    case themeSettingsAppearanceTitle
    case themeSettingsColorThemeTitle

    case appearanceSystem
    case appearanceLight
    case appearanceDark
    case appearanceDescSystem
    case appearanceDescLight
    case appearanceDescDark

    case themeNameDefault
    case themeNameOcean
    case themeNameSunset
    case themeNameForest
    case themeNameLavender
    case themeNameCherry
    case themeNameMidnight
    case themeNameMonochrome

    // MARK: - Widgets (titles/sections)
    case widgetAvailable
    case widgetConfigure
    case widgetHowToAdd
    case widgetNeverUpdated
    case widgetTroubleshooting
    case widgetTitle
    case widgetEnabled
    case widgetAccess

    // MARK: - Widgets (detailed keys)
    case widgetStatusTitle
    case widgetEnabledTitle
    case widgetAccessDescription
    case widgetInstructionStep1
    case widgetInstructionStep2
    case widgetInstructionStep3
    case widgetInstructionStep4
    case widgetTypeSmallTitle
    case widgetTypeSmallDescription
    case widgetTypeMediumTitle
    case widgetTypeMediumDescription
    case widgetTypeLargeTitle
    case widgetTypeLargeDescription
    case widgetTypeLiveTitle
    case widgetTypeLiveDescription
    case relativeAgo
    case widgetTroubleNoDataTitle
    case widgetTroubleNoDataSolution
    case widgetTroubleNotUpdatingTitle
    case widgetTroubleNotUpdatingSolution
    case widgetTroubleWrongThemeTitle
    case widgetTroubleWrongThemeSolution
    case widgetSettingsSubtitle
    case settingsRefresh
    case widgetFooterReloadHint
    case widgetHomeTitle
    case widgetHomeSubtitle

    case featureTeachersTab
    case featureTeachersTabDescription
    case featureSubjectsTab
    case featureSubjectsTabDescription
    case featureThemeSettings
    case featureThemeSettingsDescription
    case featureWidgetSettings

    // Widget names/descriptions
        case widgetNameTimetable
        case widgetDescriptionTimetable

        // Control Center: open schedule
        case controlOpenScheduleDisplayName
        case controlOpenScheduleDescription
        case controlOpenScheduleLabel

        // Control Center: toggle
        case controlToggleDisplayName
        case controlToggleDescription
        case controlToggleLabel

        // Status
        case statusActive
        case statusNoClasses

        // AppIntents
        case intentOpenTimetableTitle
        case intentOpenTimetableDescription
        case intentTodayScheduleTitle
        case intentTodayScheduleDescription
        case intentNextClassTitle
        case intentNextClassDescription
        case intentRefreshScheduleTitle
        case intentRefreshScheduleParameterEnabled
        case intentConfigurationTitle

        // Live Activity
        case liveEnds
        case livePercentCompleteSuffix

        // Common UI
        case commonNow
        case commonNext
        case commonUntil
        case commonNoClasses
        case commonNoClassesToday
        case commonEnjoyFreeDay
        case commonToday
        case commonThisWeek
        case commonWeek
        case commonClasses
        case commonMoreSuffix

        // Widget config (widget configuration intent)
        case configTitle
        case configDescription
        case configViewTypeTitle
        case configViewTypeToday
        case configViewTypeWeek
        case configShowOnlineStatusTitle
}

extension LocalizedString {
    var key: String {
        switch self {
        // General
        case .generalCancel: return "general.cancel"
        case .generalDone: return "general.done"
        case .generalToday: return "general.today"
        case .generalRetry: return "general.retry"
        case .generalRefresh: return "general.refresh"
        case .generalOnline: return "general.online"
        case .generalOffline: return "general.offline"
        case .generalCancelled: return "general.cancelled"
        case .generalLoading: return "general.loading"

        // Greeting
        case .greetingMorning: return "greeting.morning"
        case .greetingAfternoon: return "greeting.afternoon"
        case .greetingEvening: return "greeting.evening"
        case .greetingNight: return "greeting.night"

        // Schedule
        case .scheduleTitle: return "schedule.title"
        case .scheduleSelectDate: return "schedule.selectDate"
        case .scheduleHasClasses: return "schedule.hasClasses"
        case .scheduleOnlineOnly: return "schedule.onlineOnly"
        case .scheduleNoClasses: return "schedule.noClasses"
        case .scheduleEnjoyFreeTime: return "schedule.enjoyFreeTime"
        case .scheduleLoading: return "schedule.loading"
        case .scheduleLastUpdated: return "schedule.lastUpdated"

        // Groups
        case .groupsSelect: return "groups.select"
        case .groupsSelected: return "groups.selected"
        case .groupsNoSelection: return "groups.noSelection"
        case .groupsSearch: return "groups.search"
        case .groupsLoading: return "groups.loading"
        case .groupsNoAvailable: return "groups.noAvailable"
        case .groupsNoFound: return "groups.noFound"
        case .groupsPullToRefresh: return "groups.pullToRefresh"
        case .groupsAdjustSearch: return "groups.adjustSearch"

        // Teachers
        case .teachersTitle: return "teachers.title"
        case .teachersSearch: return "teachers.search"
        case .teachersLoading: return "teachers.loading"
        case .teachersNoFound: return "teachers.noFound"
        case .teachersClasses: return "teachers.classes"
        case .teachersNoData: return "teachers.noData"
        case .teachersLoadScheduleFirst: return "teachers.loadScheduleFirst"

        // Subjects
        case .subjectsTitle: return "subjects.title"
        case .subjectsSearch: return "subjects.search"
        case .subjectsLoading: return "subjects.loading"
        case .subjectsNoFound: return "subjects.noFound"
        case .subjectsClasses: return "subjects.classes"
        case .subjectsNoData: return "subjects.noData"
        case .subjectsLoadScheduleFirst: return "subjects.loadScheduleFirst"
        case .subjectsStats: return "subjects.stats"
        case .subjectsTotal: return "subjects.total"
        case .subjectsPast: return "subjects.past"
        case .subjectsUpcoming: return "subjects.upcoming"
        case .subjectsLectures: return "subjects.lectures"
        case .subjectsExercises: return "subjects.exercises"
        case .subjectsLaboratories: return "subjects.laboratories"
        case .subjectsGradingType: return "subjects.gradingType"

        // Settings
        case .settingsTitle: return "settings.title"
        case .settingsGroupSettings: return "settings.groupSettings"
        case .settingsThemeSectionTitle: return "settings.themeSection.title"
        case .settingsThemeSectionHeader: return "settings.themeSection.header"
        case .settingsThemeSectionFooter: return "settings.themeSection.footer"
        case .settingsCacheStatus: return "settings.cacheStatus"
        case .settingsClearCache: return "settings.clearCache"
        case .settingsClearCacheMessage: return "settings.clearCacheMessage"
        case .settingsVersion: return "settings.version"
        case .settingsAbout: return "settings.about"
        case .settingsEvents: return "settings.events"
        case .settingsLastUpdated: return "settings.lastUpdated"
        case .settingsNever: return "settings.never"
        case .settingsPleaseSelectGroup: return "settings.pleaseSelectGroup"

        // Tabs
        case .tabsSchedule: return "tabs.schedule"
        case .tabsTeachers: return "tabs.teachers"
        case .tabsSettings: return "tabs.settings"
        case .tabsSubjects: return "tabs.subjects"

        // Error
        case .errorTitle: return "error.title"
        case .errorInvalidURL: return "error.invalidURL"
        case .errorInvalidResponse: return "error.invalidResponse"
        case .errorServer: return "error.server"

        // Days
        case .daysMonday: return "days.monday"
        case .daysTuesday: return "days.tuesday"
        case .daysWednesday: return "days.wednesday"
        case .daysThursday: return "days.thursday"
        case .daysFriday: return "days.friday"
        case .daysSaturday: return "days.saturday"
        case .daysSunday: return "days.sunday"

        // Support / Contact
        case .settingsContactTitle: return "settings.contact.title"
        case .settingsSupportSectionTitle: return "settings.support.sectionTitle"
        case .settingsSupportFooter: return "settings.support.footer"

        // Developer Support
        case .settingsDeveloperSectionTitle: return "settings.developer.sectionTitle"
        case .settingsDeveloperAction: return "settings.developer.action"
        case .settingsDeveloperFooter: return "settings.developer.footer"

        // Contact actions
        case .contactActionReportProblem: return "contact.action.reportProblem"
        case .contactActionRequestFeature: return "contact.action.requestFeature"

        // Mail / system
        case .mailUnavailableTitle: return "mail.unavailable.title"
        case .mailUnavailableMessage: return "mail.unavailable.message"
        case .mailCopyAddress: return "mail.copyAddress"

        // Email subjects
        case .contactEmailSubjectBug: return "contact.email.subject.bug"
        case .contactEmailSubjectFeature: return "contact.email.subject.feature"

        // Email body headers
        case .contactEmailBodyBugHeader: return "contact.email.body.bugHeader"
        case .contactEmailBodyFeatureHeader: return "contact.email.body.featureHeader"

        // Email info labels
        case .contactEmailInfoApp: return "contact.email.info.app"
        case .contactEmailInfoiOS: return "contact.email.info.ios"
        case .contactEmailInfoDevice: return "contact.email.info.device"
        case .contactEmailInfoLocale: return "contact.email.info.locale"
        case .contactEmailInfoGroup: return "contact.email.info.group"
        case .contactEmailInfoDate: return "contact.email.info.date"

        case .contactEmailBodyAdditionalInfo: return "contact.email.body.additionalInfo"
        case .contactEmailBodyDetailsTitle: return "contact.email.body.detailsTitle"

        // Premium
        case .premiumFeatureTitle: return "premium.feature.title"
        case .premiumTapToUnlock: return "premium.tapToUnlock"
        case .premiumActive: return "premium.active"
        case .premiumThankYou: return "premium.thankYou"
        case .premiumEnjoyFeatures: return "premium.enjoyFeatures"
        case .premiumTimeRemaining: return "premium.timeRemaining"
        case .premiumWatchOrPurchase: return "premium.watchOrPurchase"
        case .premiumUnlockTitle: return "premium.unlock.title"
        case .premiumGetAccess: return "premium.getAccess"
        case .premiumWatchAdButton: return "premium.watchAd.button"
        case .premiumPurchaseButton: return "premium.purchase.button"
        case .premiumUnlocked: return "premium.unlocked"
        case .premiumMaybeLater: return "premium.maybeLater"
        case .premiumCalculating: return "premium.calculating"
        case .premiumRemaining: return "premium.remaining"

        // Settings Premium
        case .settingsPremiumActive: return "settings.premium.active"

        // Debug
        case .debugTools: return "debug.tools"
        case .debugDone: return "debug.done"
        case .debugResetAllFlags: return "debug.resetAllFlags"
        case .debugResetConfirm: return "debug.resetConfirm"
        case .debugCancel: return "debug.cancel"
        case .debugPremiumStatus: return "debug.premiumStatus"
        case .debugPremiumControls: return "debug.premiumControls"
        case .debugGrantPermanentPremium: return "debug.grantPermanentPremium"
        case .debugGrant1HourPremium: return "debug.grant1HourPremium"
        case .debugRevokePremium: return "debug.revokePremium"
        case .debugFeatureFlags: return "debug.featureFlags"
        case .debugFlagsFooter: return "debug.flagsFooter"
        case .debugActions: return "debug.actions"
        case .debugResetToDefault: return "debug.resetToDefault"
        case .debugSyncFromRemote: return "debug.syncFromRemote"
        case .debugShowDetails: return "debug.showDetails"
        case .debugHideDetails: return "debug.hideDetails"

        // Debug Menu (Extended)
        case .debugMenuTitle: return "debug.menu.title"
        case .debugActionResult: return "debug.actionResult"
        case .debugOK: return "debug.ok"
        case .debugConfirm: return "debug.confirm"
        case .debugFree: return "debug.free"
        case .debugPremiumLabel: return "debug.premiumLabel"
        case .debugTrial: return "debug.trial"
        case .debugStatus: return "debug.status"
        case .debugExpires: return "debug.expires"
        case .debugGrantPremium: return "debug.grantPremium"
        case .debugGrantTrial1h: return "debug.grantTrial1h"
        case .debugRevokePremiumLabel: return "debug.revokePremiumLabel"
        case .debugPremiumManagement: return "debug.premiumManagement"
        case .debugFeatureFlagsTitle: return "debug.featureFlagsTitle"
        case .debugLocalOverrides: return "debug.localOverrides"
        case .debugLastSynced: return "debug.lastSynced"
        case .debugActionsTitle: return "debug.actionsTitle"
        case .debugSyncFromServer: return "debug.syncFromServer"
        case .debugClearAllData: return "debug.clearAllData"
        case .debugStatistics: return "debug.statistics"
        case .debugAdsWatched: return "debug.adsWatched"
        case .debugLastAd: return "debug.lastAd"
        case .debugPremiumSince: return "debug.premiumSince"
        case .debugAbout: return "debug.about"
        case .debugEnvironment: return "debug.environment"
        case .debugDebug: return "debug.debug"
        case .debugRelease: return "debug.release"
        case .debugBuild: return "debug.build"
        case .debugOnlyInDebugBuilds: return "debug.onlyInDebugBuilds"
        case .debugResetToDefaultLabel: return "debug.resetToDefaultLabel"
        case .debugResetAllFlagsLabel: return "debug.resetAllFlagsLabel"
        case .debugRevokePremiumQuestion: return "debug.revokePremiumQuestion"
        case .debugResetAllFlagsQuestion: return "debug.resetAllFlagsQuestion"
        case .debugClearAllDataQuestion: return "debug.clearAllDataQuestion"
        case .debugConfirmActionQuestion: return "debug.confirmActionQuestion"
        case .debugWillRemovePremium: return "debug.willRemovePremium"
        case .debugWillResetAllFlags: return "debug.willResetAllFlags"
        case .debugWillResetEverything: return "debug.willResetEverything"
        case .debugAreYouSure: return "debug.areYouSure"
        case .debugPremiumGranted: return "debug.premiumGranted"
        case .debugTemporaryPremiumGranted: return "debug.temporaryPremiumGranted"
        case .debugPremiumRevoked: return "debug.premiumRevoked"
        case .debugAllFlagsReset: return "debug.allFlagsReset"
        case .debugAllDataCleared: return "debug.allDataCleared"
        case .debugFlagResetTemplate: return "debug.flagResetTemplate"
        case .debugSyncFailedTemplate: return "debug.syncFailedTemplate"

        // Performance Monitor
        case .perfMonitorTitle: return "perfMonitor.title"
        case .perfMonitorClear: return "perfMonitor.clear"
        case .perfMonitorExport: return "perfMonitor.export"
        case .perfMonitorExportedEvents: return "perfMonitor.exportedEvents"
        case .perfMonitorMetrics: return "perfMonitor.metrics"
        case .perfMonitorTotalEvents: return "perfMonitor.totalEvents"
        case .perfMonitorAverageDuration: return "perfMonitor.averageDuration"
        case .perfMonitorSlowestEvent: return "perfMonitor.slowestEvent"
        case .perfMonitorFastestEvent: return "perfMonitor.fastestEvent"
        case .perfMonitorFilterByCategory: return "perfMonitor.filterByCategory"
        case .perfMonitorCategory: return "perfMonitor.category"
        case .perfMonitorAll: return "perfMonitor.all"
        case .perfMonitorEvents: return "perfMonitor.events"
        case .perfMonitorNoEventsRecorded: return "perfMonitor.noEventsRecorded"

        // Ads Debug
        case .adsDebugTitle: return "adsDebug.title"
        case .adsDebugAdaptiveBanner: return "adsDebug.adaptiveBanner"
        case .adsDebugBannerAd: return "adsDebug.bannerAd"
        case .adsDebugBannerDescription: return "adsDebug.bannerDescription"
        case .adsDebugNativeAd: return "adsDebug.nativeAd"
        case .adsDebugNativeDescription: return "adsDebug.nativeDescription"
        case .adsDebugLoad: return "adsDebug.load"
        case .adsDebugShow: return "adsDebug.show"
        case .adsDebugReadyToShow: return "adsDebug.readyToShow"
        case .adsDebugInterstitialAd: return "adsDebug.interstitialAd"
        case .adsDebugInterstitialDescription: return "adsDebug.interstitialDescription"
        case .adsDebugRewardedAd: return "adsDebug.rewardedAd"
        case .adsDebugRewardedDescription: return "adsDebug.rewardedDescription"
        case .adsDebugRewardedInterstitial: return "adsDebug.rewardedInterstitial"
        case .adsDebugRewardedInterstitialDescription: return "adsDebug.rewardedInterstitialDescription"
        case .adsDebugPreload: return "adsDebug.preload"
        case .adsDebugAppOpenAd: return "adsDebug.appOpenAd"
        case .adsDebugAppOpenDescription: return "adsDebug.appOpenDescription"
        case .adsDebugDeveloperTools: return "adsDebug.developerTools"
        case .adsDebugLaunchAdInspector: return "adsDebug.launchAdInspector"
        case .adsDebugAdInspectorDescription: return "adsDebug.adInspectorDescription"
        case .adsDebugEventLog: return "adsDebug.eventLog"
        case .adsDebugNoEventsYet: return "adsDebug.noEventsYet"
        case .adsDebugClearLog: return "adsDebug.clearLog"

        // Ad Loading
        case .adLoadingText: return "adLoading.text"
        case .adLoadingFailed: return "adLoading.failed"
        case .adLoadingRetry: return "adLoading.retry"

        // Theme Settings (NEW)
        case .themeSettingsTitle: return "themeSettings.title"
        case .themeSettingsAppearanceTitle: return "themeSettings.appearance.title"
        case .themeSettingsColorThemeTitle: return "themeSettings.colorTheme.title"

        case .appearanceSystem: return "appearance.system"
        case .appearanceLight:  return "appearance.light"
        case .appearanceDark:   return "appearance.dark"
        case .appearanceDescSystem: return "appearance.description.system"
        case .appearanceDescLight:  return "appearance.description.light"
        case .appearanceDescDark:   return "appearance.description.dark"

        case .themeNameDefault:    return "theme.name.default"
        case .themeNameOcean:      return "theme.name.ocean"
        case .themeNameSunset:     return "theme.name.sunset"
        case .themeNameForest:     return "theme.name.forest"
        case .themeNameLavender:   return "theme.name.lavender"
        case .themeNameCherry:     return "theme.name.cherry"
        case .themeNameMidnight:   return "theme.name.midnight"
        case .themeNameMonochrome: return "theme.name.monochrome"

        case .widgetTitle:   return "widget.title"
        case .widgetHomeTitle:   return "widget.home.title"
        case .widgetHomeSubtitle:   return "widget.home.subtitle"
        case .widgetEnabled:         return "widget.enabled"
        case .widgetAccess:          return "widget.access"
        case .widgetStatusTitle:     return "widget.status.title"
        case .widgetEnabledTitle:    return "widget.enabled.title"
        case .widgetAccessDescription: return "widget.access.description"
        case .widgetInstructionStep1: return "widget.instruction.step1"
        case .widgetInstructionStep2: return "widget.instruction.step2"
        case .widgetInstructionStep3: return "widget.instruction.step3"
        case .widgetInstructionStep4: return "widget.instruction.step4"
        case .widgetTypeSmallTitle: return "widget.type.small.title"
        case .widgetTypeSmallDescription: return "widget.type.small.description"
        case .widgetTypeMediumTitle: return "widget.type.medium.title"
        case .widgetTypeMediumDescription: return "widget.type.medium.description"
        case .widgetTypeLargeTitle: return "widget.type.large.title"
        case .widgetTypeLargeDescription: return "widget.type.large.description"
        case .widgetTypeLiveTitle: return "widget.type.live.title"
        case .widgetTypeLiveDescription: return "widget.type.live.description"
        case .relativeAgo: return "relative.ago"
        case .widgetTroubleNoDataTitle: return "widget.troubleshoot.noData.title"
        case .widgetTroubleNoDataSolution: return "widget.troubleshoot.noData.solution"
        case .widgetTroubleNotUpdatingTitle: return "widget.troubleshoot.notUpdating.title"
        case .widgetTroubleNotUpdatingSolution: return "widget.troubleshoot.notUpdating.solution"
        case .widgetTroubleWrongThemeTitle: return "widget.troubleshoot.wrongTheme.title"
        case .widgetTroubleWrongThemeSolution: return "widget.troubleshoot.wrongTheme.solution"
        case .widgetTroubleshooting: return "widget.troubleshooting"
        case .widgetNeverUpdated: return "widget.never.updated"
        case .widgetHowToAdd: return "widget.how.to.add"
        case .widgetConfigure: return "widget.configure"
        case .widgetAvailable: return "widget.available"
        case .widgetSettingsSubtitle: return "widget.settings.subtitle"
        case .settingsRefresh: return "settings.refresh"
        case .widgetFooterReloadHint: return "widget.footer.reloadHint"
        case .featureTeachersTab: return "feature.teachersTab"
        case .featureSubjectsTab: return "feature.subjectsTab"
        case .featureThemeSettings: return "feature.themeSettings"
        case .featureTeachersTabDescription: return "feature.teachersTab.description"
        case .featureSubjectsTabDescription: return "feature.subjectsTab.description"
        case .featureThemeSettingsDescription: return "feature.themeSettings.description"
        case .featureWidgetSettings: return "feature.widgetSettings"
        case .widgetNameTimetable: return "widget.name.timetable"
        case .widgetDescriptionTimetable: return "widget.description.timetable"

        case .controlOpenScheduleDisplayName: return "widget.control.openSchedule.displayName"
        case .controlOpenScheduleDescription: return "widget.control.openSchedule.description"
        case .controlOpenScheduleLabel: return "widget.control.openSchedule.label"

        case .controlToggleDisplayName: return "widget.control.toggle.displayName"
        case .controlToggleDescription: return "widget.control.toggle.description"
        case .controlToggleLabel: return "widget.control.toggle.label"

        case .statusActive: return "widget.status.active"
        case .statusNoClasses: return "widget.status.noClasses"

        case .intentOpenTimetableTitle: return "widget.intent.openTimetable.title"
        case .intentOpenTimetableDescription: return "widget.intent.openTimetable.description"
        case .intentTodayScheduleTitle: return "widget.intent.todaySchedule.title"
        case .intentTodayScheduleDescription: return "widget.intent.todaySchedule.description"
        case .intentNextClassTitle: return "widget.intent.nextClass.title"
        case .intentNextClassDescription: return "widget.intent.nextClass.description"
        case .intentRefreshScheduleTitle: return "widget.intent.refreshSchedule.title"
        case .intentRefreshScheduleParameterEnabled: return "widget.intent.refreshSchedule.parameter.enabled"
        case .intentConfigurationTitle: return "widget.intent.configuration.title"

        case .liveEnds: return "widget.live.ends"
        case .livePercentCompleteSuffix: return "widget.live.percentCompleteSuffix"

        case .commonNow: return "widget.common.now"
        case .commonNext: return "widget.common.next"
        case .commonUntil: return "widget.common.until"
        case .commonNoClasses: return "widget.common.noClasses"
        case .commonNoClassesToday: return "widget.common.noClassesToday"
        case .commonEnjoyFreeDay: return "widget.common.enjoyFreeDay"
        case .commonToday: return "widget.common.today"
        case .commonThisWeek: return "widget.common.thisWeek"
        case .commonWeek: return "widget.common.week"
        case .commonClasses: return "widget.common.classes"
        case .commonMoreSuffix: return "widget.common.moreSuffix"

        case .configTitle: return "widget.config.title"
        case .configDescription: return "widget.config.description"
        case .configViewTypeTitle: return "widget.config.viewType.title"
        case .configViewTypeToday: return "widget.config.viewType.today"
        case .configViewTypeWeek: return "widget.config.viewType.week"
        case .configShowOnlineStatusTitle: return "widget.config.showOnlineStatus.title"
        }
    }

    // Helper for theme names by id
    static func themeName(for id: String) -> String {
        switch id {
        case "default":    return LocalizedString.themeNameDefault.localized
        case "ocean":      return LocalizedString.themeNameOcean.localized
        case "sunset":     return LocalizedString.themeNameSunset.localized
        case "forest":     return LocalizedString.themeNameForest.localized
        case "lavender":   return LocalizedString.themeNameLavender.localized
        case "cherry":     return LocalizedString.themeNameCherry.localized
        case "midnight":   return LocalizedString.themeNameMidnight.localized
        case "monochrome": return LocalizedString.themeNameMonochrome.localized
        default:           return LocalizedString.themeNameDefault.localized
        }
    }

    var localized: String {
            NSLocalizedString(self.key, bundle: .main, comment: "")
        }

    var resource: LocalizedStringResource {
            LocalizedStringResource(String.LocalizationValue(self.key), table: nil, bundle: .main)
        }
}

// ===== FILE: Timetable DSW/Core/Protocols/ComponentConfiguration.swift =====
import Foundation

// MARK: - Component Configuration Protocol

protocol ComponentConfiguration {
    associatedtype Constants
    static var constants: Constants { get }
}

// ===== FILE: Timetable DSW/Core/Protocols/EventsProviderProtocol.swift =====
import Foundation

protocol EventsProviderProtocol {
    func eventsForDate(_ date: Date) -> [ScheduleEvent]
    func hasEventsOn(date: Date) -> Bool
    func eventType(on date: Date) -> EventDayType
}

// ===== FILE: Timetable DSW/Core/Shared/AppGroupManager.swift =====
import Foundation

struct AppGroupManager {
    // ВАЖНО: Замените на свой App Group ID из Xcode
    static let appGroupIdentifier = "group.org.laptenok.Timetable-DSW.rl"

    static var sharedDefaults: UserDefaults? {
        UserDefaults(suiteName: appGroupIdentifier)
    }

    // Keys для хранения данных
    struct Keys {
        static let semesterSchedule = "widget_semester_schedule"
        static let selectedGroupId = "widget_selected_group_id"
        static let selectedThemeId = "widget_selected_theme_id"
        static let appearanceMode = "widget_appearance_mode"
        static let lastUpdated = "widget_last_updated"
    }

    // MARK: - Save Methods

    static func saveSemesterSchedule(_ schedule: GroupScheduleResponse) {
        guard let data = try? JSONEncoder().encode(schedule) else { return }
        sharedDefaults?.set(data, forKey: Keys.semesterSchedule)
    }

    static func saveSelectedGroupId(_ groupId: Int) {
        sharedDefaults?.set(groupId, forKey: Keys.selectedGroupId)
    }

    static func saveSelectedTheme(id: String, appearanceMode: String) {
        sharedDefaults?.set(id, forKey: Keys.selectedThemeId)
        sharedDefaults?.set(appearanceMode, forKey: Keys.appearanceMode)
    }

    static func saveLastUpdated(_ date: Date) {
        sharedDefaults?.set(date, forKey: Keys.lastUpdated)
    }

    // MARK: - Load Methods

    static func loadSemesterSchedule() -> GroupScheduleResponse? {
        guard let data = sharedDefaults?.data(forKey: Keys.semesterSchedule),
              let schedule = try? JSONDecoder().decode(GroupScheduleResponse.self, from: data) else {
            return nil
        }
        return schedule
    }

    static func loadSelectedGroupId() -> Int? {
        guard let groupId = sharedDefaults?.integer(forKey: Keys.selectedGroupId), groupId > 0 else {
            return nil
        }
        return groupId
    }

    static func loadSelectedThemeId() -> String? {
        sharedDefaults?.string(forKey: Keys.selectedThemeId)
    }

    static func loadAppearanceMode() -> String? {
        sharedDefaults?.string(forKey: Keys.appearanceMode)
    }

    static func loadLastUpdated() -> Date? {
        sharedDefaults?.object(forKey: Keys.lastUpdated) as? Date
    }
}

// ===== FILE: Timetable DSW/Data/Cache/CacheManager.swift =====
import Combine
import Foundation

actor CacheManager {
    // MARK: - Properties
    
    private let fileManager = FileManager.default
    private let cacheDirectory: URL
    
    // MARK: - Initialization
    
    init() {
        let paths = fileManager.urls(for: .documentDirectory, in: .userDomainMask)
        cacheDirectory = paths[0].appendingPathComponent("ScheduleCache")
        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
    }
    
    // MARK: - Public Methods
    
    func save<T: Encodable>(_ value: T, forKey key: String) async throws {
        let url = cacheDirectory.appendingPathComponent(key)
        let data = try await MainActor.run { try JSONEncoder().encode(value) }
        try data.write(to: url)
    }
    
    func load<T: Decodable>(forKey key: String) async throws -> T {
        let url = cacheDirectory.appendingPathComponent(key)
        let data = try Data(contentsOf: url)
        return try await MainActor.run { try JSONDecoder().decode(T.self, from: data) }
    }
    
    func exists(forKey key: String) -> Bool {
        let url = cacheDirectory.appendingPathComponent(key)
        return fileManager.fileExists(atPath: url.path)
    }
    
    func remove(forKey key: String) async throws {
        let url = cacheDirectory.appendingPathComponent(key)
        try? fileManager.removeItem(at: url)
    }
}

// ===== FILE: Timetable DSW/Data/Network/NetworkError.swift =====
import Foundation

enum NetworkError: Error, LocalizedError {
    case invalidURL
    case invalidResponse
    case httpError(statusCode: Int)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return LocalizedString.errorInvalidURL.localized
        case .invalidResponse:
            return LocalizedString.errorInvalidResponse.localized
        case .httpError(let code):
            return "\(LocalizedString.errorServer.localized) (\(code))"
        }
    }
}

// ===== FILE: Timetable DSW/Data/Network/NetworkManager.swift =====
import Combine
import Foundation

actor NetworkManager {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            let requestTimeout: TimeInterval = 300 //70
            let resourceTimeout: TimeInterval = 300 //90
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    private let baseURL: String
    private let session: URLSession
    
    // MARK: - Initialization
    
    init(baseURL: String = "https://api.dsw.wtf") {
        self.baseURL = baseURL
        
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = Configuration.constants.requestTimeout
        config.timeoutIntervalForResource = Configuration.constants.resourceTimeout
        self.session = URLSession(configuration: config)
    }
    
    // MARK: - Public Methods
    
    func fetch<T: Decodable>(endpoint: String) async throws -> T {
        let url = try buildURL(for: endpoint)
        let request = buildRequest(for: url)
        
        let (data, response) = try await session.data(for: request)
        try validateResponse(response)
        
        return try await MainActor.run { try JSONDecoder().decode(T.self, from: data) }
    }
    
    // MARK: - Private Methods
    
    private func buildURL(for endpoint: String) throws -> URL {
        let urlString = "\(baseURL)\(endpoint)"
        guard let url = URL(string: urlString) else {
            throw NetworkError.invalidURL
        }
        return url
    }
    
    private func buildRequest(for url: URL) -> URLRequest {
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.timeoutInterval = Configuration.constants.requestTimeout
        return request
    }
    
    private func validateResponse(_ response: URLResponse) throws {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        guard (200..<300).contains(httpResponse.statusCode) else {
            throw NetworkError.httpError(statusCode: httpResponse.statusCode)
        }
    }
}

// ===== FILE: Timetable DSW/Data/Repositories/ScheduleRepository.swift =====
import Foundation

actor ScheduleRepository {
    // MARK: - Configuration
    
    struct Configuration {
        struct CacheKey {
            static let schedule = "schedule_cache"
            static let groups = "groups_cache"
            static let semesterSchedule = "semester_schedule_cache"
        }

        struct Endpoint {
            static func aggregate(groupId: Int, from: String, to: String) -> String {
                "/api/groups/\(groupId)/aggregate?from=\(from)&to=\(to)&type=3"
            }

            static func semesterSchedule(groupId: Int, from: String, to: String) -> String {
                "/api/groups/\(groupId)/schedule?from=\(from)&to=\(to)&type=3"
            }

            static let groupsSearch = "/groups/search"
        }
    }
    
    // MARK: - Properties
    
    private let networkManager: NetworkManager
    private let cacheManager: CacheManager
    
    // MARK: - Initialization
    
    init(networkManager: NetworkManager, cacheManager: CacheManager) {
        self.networkManager = networkManager
        self.cacheManager = cacheManager
    }
    
    // MARK: - Schedule Methods
    
    @MainActor func getSchedule(groupId: Int, from: String, to: String) async throws -> AggregateResponse {
        do {
            let fresh: AggregateResponse = try await networkManager.fetch(
                endpoint: Configuration.Endpoint.aggregate(groupId: groupId, from: from, to: to)
            )
            try await cacheManager.save(fresh, forKey: Configuration.CacheKey.schedule)
            return fresh
        } catch {
            if let cached: AggregateResponse = try? await cacheManager.load(forKey: Configuration.CacheKey.schedule) {
                return cached
            }
            throw error
        }
    }
    
    @MainActor func getCachedSchedule() async -> AggregateResponse? {
        try? await cacheManager.load(forKey: Configuration.CacheKey.schedule)
    }
    
    func clearScheduleCache() async throws {
        try await cacheManager.remove(forKey: Configuration.CacheKey.schedule)
    }

    // MARK: - Semester Schedule Methods

    @MainActor func getSemesterSchedule(groupId: Int, from: String, to: String) async throws -> GroupScheduleResponse {
        let response: GroupScheduleResponse = try await networkManager.fetch(
            endpoint: Configuration.Endpoint.semesterSchedule(groupId: groupId, from: from, to: to)
        )
        try await cacheManager.save(response, forKey: Configuration.CacheKey.semesterSchedule)
        return response
    }

    @MainActor func getCachedSemesterSchedule() async -> GroupScheduleResponse? {
        try? await cacheManager.load(forKey: Configuration.CacheKey.semesterSchedule)
    }

    // MARK: - Parallel Loading Methods

    @MainActor func getScheduleWithRace(groupId: Int, from: String, to: String, existingTeachers: [Teacher], onSemesterSchedule: @escaping (GroupScheduleResponse) -> Void) async throws -> AggregateResponse {
        // Launch semester schedule request in parallel task
        Task { @MainActor in
            if let semesterSchedule = try? await self.getSemesterSchedule(groupId: groupId, from: from, to: to) {
                // Call callback immediately when semester data arrives
                let aggregate = AggregateResponse(from: semesterSchedule, teachers: existingTeachers)
                try await cacheManager.save(aggregate, forKey: Configuration.CacheKey.schedule)
                onSemesterSchedule(semesterSchedule)
            }
        }

        // Meanwhile, fetch aggregate (this is the main flow)
        do {
            let aggregate: AggregateResponse = try await networkManager.fetch(
                endpoint: Configuration.Endpoint.aggregate(groupId: groupId, from: from, to: to)
            )
            // Save aggregate to cache
            try await cacheManager.save(aggregate, forKey: Configuration.CacheKey.schedule)
            return aggregate
        } catch {
            // If aggregate fails, try cached version
            if let cached: AggregateResponse = try? await cacheManager.load(forKey: Configuration.CacheKey.schedule) {
                return cached
            }
            throw error
        }
    }

    // MARK: - Groups Methods
    
    @MainActor func getGroups() async throws -> [GroupInfo] {
        do {
            let fresh: [GroupInfo] = try await networkManager.fetch(endpoint: Configuration.Endpoint.groupsSearch)
            try await cacheManager.save(fresh, forKey: Configuration.CacheKey.groups)
            return fresh
        } catch {
            if let cached: [GroupInfo] = try? await cacheManager.load(forKey: Configuration.CacheKey.groups),
               !cached.isEmpty {
                return cached
            }
            throw error
        }
    }
    
    @MainActor func getCachedGroups() async -> [GroupInfo]? {
        try? await cacheManager.load(forKey: Configuration.CacheKey.groups)
    }
}

// ===== FILE: Timetable DSW/Features/Common/Components/ScaleButtonStyle.swift =====
import SwiftUI

struct ScaleButtonStyle: ButtonStyle {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            let pressedScale: Double = 0.95
            let springResponse: Double = 0.3
            let springDamping: Double = 0.6
        }
        
        static let constants = Constants()
    }
    
    // MARK: - ButtonStyle
    
    func makeBody(configuration: ButtonStyleConfiguration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? Configuration.constants.pressedScale : 1.0)
            .animation(
                .spring(
                    response: Configuration.constants.springResponse,
                    dampingFraction: Configuration.constants.springDamping
                ),
                value: configuration.isPressed
            )
    }
}

// ===== FILE: Timetable DSW/Features/Common/GradientTitleBar.swift =====
import SwiftUI

/// Центрированный градиентный заголовок + кнопка "Gotowe" справа
/// со "системной" подложкой под навбар при скролле.
struct GradientTitleBar: View {
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let hPadding: AppSpacing = .large
            let vPadding: AppSpacing = .medium
            let doneHitSlop: CGFloat = 8
            let separatorHeight: CGFloat = 0.5
        }
        static let constants = Constants()
    }

    let title: String
    let onDone: () -> Void
    let showsBackground: Bool = true

    @Environment(\.colorScheme) private var colorScheme

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }

    var body: some View {
        ZStack {
            // Центрированный градиентный заголовок
            Text(title)
                .font(AppTypography.title2.font)
                .fontWeight(.semibold)
                .multilineTextAlignment(.center)
                .frame(maxWidth: .infinity)
                .overlay(
                    LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing)
                )
                .mask(
                    Text(title)
                        .font(AppTypography.title2.font)
                        .fontWeight(.semibold)
                )
                .accessibilityAddTraits(.isHeader)

            // "Gotowe" справа
            HStack {
                Spacer()
                Button(action: onDone) {
                    Text(LocalizedString.generalDone.localized) // "Gotowe"
                        .font(AppTypography.subheadline.font)
                        .fontWeight(.semibold)
                        .overlay(
                            LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing)
                        )
                        .mask(
                            Text(LocalizedString.generalDone.localized)
                                .font(AppTypography.subheadline.font)
                                .fontWeight(.semibold)
                        )
                        .contentShape(Rectangle())
                        .padding(.horizontal, Configuration.constants.doneHitSlop)
                        .padding(.vertical, Configuration.constants.doneHitSlop / 2)
                }
                .buttonStyle(.plain)
            }
        }
        .padding(.horizontal, Configuration.constants.hPadding.value)
        .padding(.vertical, Configuration.constants.vPadding.value)
        .background(
            Group {
                if showsBackground {
                    // Системная подложка + нижний сепаратор
                    ZStack(alignment: .bottom) {
                        Rectangle().fill(.ultraThinMaterial)
                        Rectangle()
                            .fill(AppColor.background.color(for: colorScheme).opacity(0.65)) // или AppColor.separator
                            .frame(height: Configuration.constants.separatorHeight)
                    }
                    .transition(.opacity)
                } else {
                    Color.clear
                }
            }
            .ignoresSafeArea(edges: .top)
            .animation(.easeInOut(duration: 0.2), value: showsBackground)
        )
    }
}

// ===== FILE: Timetable DSW/Features/Common/Models/EventDayType.swift =====
import Foundation

/// Тип содержимого дня: нет занятий, только онлайн, или обычные (в т.ч. смешанные).
enum EventDayType: Equatable {
    case none
    case onlineOnly
    case regular
}

// ===== FILE: Timetable DSW/Features/Common/Models/TabBarItem.swift =====
import Foundation

struct TabBarItem: Identifiable {
    let id = UUID()
    let icon: AppIcon
    let title: LocalizedString
    let tag: Int
}

// ===== FILE: Timetable DSW/Features/Common/Views/ErrorView.swift =====
import SwiftUI

struct ErrorView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let iconSize: CGFloat = AppDimensions.iconXL.value * 2
            let spacing: AppSpacing = .xl
            let buttonPadding: EdgeInsets = .init(
                top: AppSpacing.medium.value,
                leading: AppSpacing.xxl.value,
                bottom: AppSpacing.medium.value,
                trailing: AppSpacing.xxl.value
            )
            let containerPadding: AppSpacing = .xxl
            let shadowRadius: CGFloat = 8
            let shadowY: CGFloat = 4
            let glowOpacity: Double = 0.3
            let gradientOpacity: Double = 0.9
            let glowStartRadius: CGFloat = 5
            let glowEndRadius: CGFloat = 40
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    let message: String
    let onRetry: () -> Void
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        message: String,
        onRetry: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.message = message
        self.onRetry = onRetry
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            iconView
            messageView
            retryButton
        }
        .padding(Configuration.constants.containerPadding.value)
    }
    
    // MARK: - Subviews
    
    private var iconView: some View {
        ZStack {
            // Glow background for liquid glass effect
            Circle()
                .fill(
                    LinearGradient(
                        colors: iconGradientColors.map { $0.opacity(0.15) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: Configuration.constants.iconSize * 1.2, height: Configuration.constants.iconSize * 1.2)
                .blur(radius: 20)

            AppIcon.exclamationTriangleFill.image()
                .font(.system(size: Configuration.constants.iconSize))
                .foregroundStyle(
                    LinearGradient(
                        colors: iconGradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .shadow(
                    color: iconGradientColors.first?.opacity(0.3) ?? .clear,
                    radius: 10,
                    x: 0,
                    y: 4
                )
        }
    }
    
    private var messageView: some View {
        Text(message)
            .font(AppTypography.body.font)
            .multilineTextAlignment(.center)
            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            .fixedSize(horizontal: false, vertical: true)
    }
    
    private var retryButton: some View {
        Button(action: handleRetry) {
            Text(LocalizedString.generalRetry.localized)
                .font(AppTypography.custom(size: 16, weight: .semibold).font)
                .foregroundAppColor(.white, colorScheme: colorScheme)
                .padding(Configuration.constants.buttonPadding)
                .background {
                    buttonBackground
                }
                .shadow(
                    color: iconGradientColors[0].opacity(Configuration.constants.gradientOpacity - 0.5),
                    radius: Configuration.constants.shadowRadius,
                    x: 0,
                    y: Configuration.constants.shadowY
                )
        }
        .buttonStyle(ScaleButtonStyle())
    }
    
    private var buttonBackground: some View {
        ZStack {
            Capsule()
                .fill(.ultraThinMaterial)
            
            Capsule()
                .fill(
                    LinearGradient(
                        colors: iconGradientColors,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .opacity(Configuration.constants.gradientOpacity)
            
            Capsule()
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(Configuration.constants.glowOpacity),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .topLeading,
                        startRadius: Configuration.constants.glowStartRadius,
                        endRadius: Configuration.constants.glowEndRadius
                    )
                )
        }
    }
    
    // MARK: - Computed Properties

    private var gradientColors: [Color] {
        // Use warning gradient (orange-red) to indicate error while maintaining app aesthetic
        // This is less harsh than pure error red but still clearly communicates issue
        GradientStyle.warning.colors(for: colorScheme)
    }

    private var iconGradientColors: [Color] {
        // Icon uses primary gradient for softer, app-consistent look
        GradientStyle.primary.colors(for: colorScheme)
    }
    
    // MARK: - Actions
    
    private func handleRetry() {
        hapticService.impact(style: .medium)
        onRetry()
    }
}

// ===== FILE: Timetable DSW/Features/Common/Views/FloatingTabBar.swift =====
import SwiftUI

// MARK: - Tab Bar Configuration

struct TabBarConfiguration {
    // MARK: - Configuration
    
    struct Constants {
        let gradientStyle: GradientStyle
        let showLabels: Bool
        let iconSize: CGFloat
        let backgroundBlur: Material
        let cornerRadius: AppCornerRadius
        let height: CGFloat
        let horizontalPadding: AppSpacing
        let bottomPadding: AppSpacing
        let showTopBorder: Bool
        let topBorderHeight: CGFloat
        let buttonWidth: CGFloat
        let buttonHeight: CGFloat
        let buttonSpacing: AppSpacing
        let backgroundOpacity: Double
        let scalePressed: Double
        let scaleSelected: Double
        let springResponse: Double
        let springDamping: Double
        let shadowRadius: CGFloat
        let shadowY: CGFloat
        let shadowOpacity: Double
        let rotationDuration: Double
        let blurRadius: CGFloat
        let glowOpacity: Double
        let glowStartRadius: CGFloat
        let glowEndRadius: CGFloat
    }
    
    static func adaptive(colorScheme: ColorScheme) -> Constants {
        Constants(
            gradientStyle: colorScheme == .dark ? .primary : .accent,
            showLabels: false,
            iconSize: AppDimensions.iconLarge.value + 2,
            backgroundBlur: .ultraThinMaterial,
            cornerRadius: .xxl,
            height: AppDimensions.tabBarHeight.value,
            horizontalPadding: .xl,
            bottomPadding: .small, // xxl? cconfig
            showTopBorder: false,
            topBorderHeight: AppDimensions.lineSmall.value,
            buttonWidth: 60,
            buttonHeight: 60,
            buttonSpacing: .xs,
            backgroundOpacity: 0.2,
            scalePressed: 0.95,
            scaleSelected: 1.1,
            springResponse: 0.3,
            springDamping: 0.6,
            shadowRadius: 12,
            shadowY: -2,
            shadowOpacity: 0.1,
            rotationDuration: 3,
            blurRadius: 8,
            glowOpacity: 0.3,
            glowStartRadius: 5,
            glowEndRadius: 30
        )
    }
}

// MARK: - Gradient Blur Background

struct GradientBlurBackground: View {
    // MARK: - Properties
    
    let style: GradientStyle
    
    // MARK: - State
    
    @State private var rotationAngle: Double = 0
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Constants
    
    private struct Constants {
        static let rotationDuration: Double = 3
        static let blurRadius: CGFloat = 8
        static let glowOpacity: Double = 0.3
        static let glowStartRadius: CGFloat = 5
        static let glowEndRadius: CGFloat = 30
    }
    
    // MARK: - Body
    
    var body: some View {
        ZStack {
            Circle()
                .fill(.ultraThinMaterial)
            
            LinearGradient(
                colors: style.colors(for: colorScheme),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .clipShape(Circle())
            .blur(radius: Constants.blurRadius)
            .rotationEffect(.degrees(rotationAngle))
            .onAppear {
                withAnimation(
                    .linear(duration: Constants.rotationDuration)
                    .repeatForever(autoreverses: false)
                ) {
                    rotationAngle = 360
                }
            }
            
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(Constants.glowOpacity),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .center,
                        startRadius: Constants.glowStartRadius,
                        endRadius: Constants.glowEndRadius
                    )
                )
        }
    }
}

// MARK: - Tab Bar Background

struct TabBarBackground: View {
    // MARK: - Properties
    
    let configuration: TabBarConfiguration.Constants
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Body
    
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: configuration.cornerRadius.value)
                .fill(configuration.backgroundBlur)
            
            RoundedRectangle(cornerRadius: configuration.cornerRadius.value)
                .fill(AppColor.background.color(for: colorScheme).opacity(configuration.backgroundOpacity))
            
            if configuration.showTopBorder {
                topBorder
            }
        }
        .shadow(
            color: AppColor.black.color(for: colorScheme).opacity(configuration.shadowOpacity),
            radius: configuration.shadowRadius,
            x: 0,
            y: configuration.shadowY
        )
    }
    
    private var topBorder: some View {
        VStack(spacing: 0) {
            Rectangle()
                .fill(
                    configuration.gradientStyle.linearGradient(
                        for: colorScheme,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .frame(height: configuration.topBorderHeight)
            
            Spacer()
        }
        .clipShape(RoundedRectangle(cornerRadius: configuration.cornerRadius.value))
    }
}

// MARK: - Tab Bar Button

struct TabBarButton: View {
    // MARK: - Properties
    
    let tab: TabBarItem
    let isSelected: Bool
    let configuration: TabBarConfiguration.Constants
    let namespace: Namespace.ID
    let action: () -> Void
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        tab: TabBarItem,
        isSelected: Bool,
        configuration: TabBarConfiguration.Constants,
        namespace: Namespace.ID,
        action: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.tab = tab
        self.isSelected = isSelected
        self.configuration = configuration
        self.namespace = namespace
        self.action = action
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        Button(action: handleTap) {
            VStack(spacing: configuration.buttonSpacing.value) {
                iconView
                
                if configuration.showLabels {
                    labelView
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(ScaleButtonStyle())
    }
    
    // MARK: - Subviews
    
    private var iconView: some View {
        ZStack {
            if isSelected {
                GradientBlurBackground(style: configuration.gradientStyle)
                    .matchedGeometryEffect(id: "TAB_BACKGROUND", in: namespace)
                    .frame(width: configuration.buttonWidth, height: configuration.buttonHeight)
            }
            
            tab.icon.image()
                .font(.system(size: configuration.iconSize, weight: .medium))
                .foregroundAppColor(isSelected ? .white : .secondaryText, colorScheme: colorScheme)
                .scaleEffect(isSelected ? configuration.scaleSelected : 1.0)
        }
        .frame(width: configuration.buttonWidth, height: configuration.buttonHeight)
    }
    
    private var labelView: some View {
        Text(tab.title.localized)
            .font(AppTypography.caption2.font)
            .fontWeight(isSelected ? .semibold : .regular)
            .foregroundAppColor(isSelected ? .primaryText : .secondaryText, colorScheme: colorScheme)
    }
    
    // MARK: - Actions
    
    private func handleTap() {
        hapticService.impact(style: .light)
        action()
    }
}

// MARK: - Floating Tab Bar

struct FloatingTabBar: View {
    // MARK: - Properties

    let tabs: [TabBarItem]
    @Binding var selectedTab: Int

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @Environment(\.bottomInsetService) private var bottomInsetService
    @Environment(\.adCoordinator) private var adCoordinator

    // MARK: - Namespace

    @Namespace private var animation

    // MARK: - Computed Properties

    private var configuration: TabBarConfiguration.Constants {
        TabBarConfiguration.adaptive(colorScheme: colorScheme)
    }

    private var dynamicBottomPadding: CGFloat {
        bottomInsetService?.tabBarBottomPadding ?? configuration.bottomPadding.value
    }

    // MARK: - Body

    var body: some View {
        VStack(spacing: 8) {
            tabBar
            bannerAd
        }
    }

    private var bannerAd: some View {
        VStack(spacing: 0) {
            if adCoordinator?.isAdDisabled() == false {
                AdaptiveBannerView()
                    .background(AppColor.background.color(for: colorScheme))
                    .shadow(color: .black.opacity(0.1), radius: 8, x: 0, y: -2)
            }
        }
        .ignoresSafeArea(edges: .bottom)
    }

    private var tabBar: some View {
        HStack(spacing: 0) {
            ForEach(tabs) { tab in
                TabBarButton(
                    tab: tab,
                    isSelected: selectedTab == tab.tag,
                    configuration: configuration,
                    namespace: animation,
                    action: {
                        withAnimation(.spring(response: configuration.springResponse, dampingFraction: configuration.springDamping)) {
                            selectedTab = tab.tag
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
        }
        .frame(height: configuration.height)
        .background {
            TabBarBackground(configuration: configuration)
        }
        .padding(.horizontal, configuration.horizontalPadding.value)
    }
}

// ===== FILE: Timetable DSW/Features/Common/Views/RoundedCorner.swift =====
import SwiftUI

struct RoundedCorner: Shape {
    // MARK: - Properties
    
    var radius: CGFloat
    var corners: UIRectCorner
    
    // MARK: - Shape
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}

// ===== FILE: Timetable DSW/Features/Common/Views/RoundedShadowContainer.swift =====
import SwiftUI

public struct RoundedShadowContainer<Content: View>: View {
    // MARK: - Constants (без Configuration)

    private let overlayOpacity: Double = 0.3
    private let defaultBlurOpacity: Double = 1.0

    // MARK: - Properties

    private let corners: UIRectCorner
    private let cornerRadius: CGFloat
    private let fill: Color?
    private let blurMaterial: Material?
    private let blurOpacity: Double
    private let shadow: ShadowStyle
    private let contentInsets: EdgeInsets
    private let outerPadding: EdgeInsets
    private let ignoresSafeAreaEdges: Edge.Set?
    private let content: Content

    // MARK: - Initialization

    public init(
        corners: UIRectCorner = .allCorners,
        cornerRadius: CGFloat = AppCornerRadius.large.value,
        fill: Color? = nil,
        blurMaterial: Material? = nil,
        blurOpacity: Double = 1.0,
        shadow: ShadowStyle = ShadowStyle(),
        contentInsets: EdgeInsets = .init(),
        outerPadding: EdgeInsets = .init(),
        ignoresSafeAreaEdges: Edge.Set? = nil,
        @ViewBuilder content: () -> Content
    ) {
        self.corners = corners
        self.cornerRadius = cornerRadius
        self.fill = fill
        self.blurMaterial = blurMaterial
        self.blurOpacity = blurOpacity
        self.shadow = shadow
        self.contentInsets = contentInsets
        self.outerPadding = outerPadding
        self.ignoresSafeAreaEdges = ignoresSafeAreaEdges
        self.content = content()
    }

    // MARK: - Body

    public var body: some View {
        content
            .padding(contentInsets)
            .background {
                backgroundView
            }
            .padding(outerPadding)
    }

    // MARK: - Subviews

    private var backgroundView: some View {
        Group {
            if let material = blurMaterial {
                blurBackground(material: material)
            } else if let fillColor = fill {
                solidBackground(color: fillColor)
            }
        }
        .shadow(color: shadow.color, radius: shadow.radius, x: shadow.x, y: shadow.y)
        .ignoresSafeArea(edges: ignoresSafeAreaEdges ?? [])
    }

    private func blurBackground(material: Material) -> some View {
        RoundedCorner(radius: cornerRadius, corners: corners)
            .fill(material)
            .opacity(blurOpacity)
            .overlay {
                if let fillColor = fill {
                    RoundedCorner(radius: cornerRadius, corners: corners)
                        .fill(fillColor.opacity(overlayOpacity))
                }
            }
    }

    private func solidBackground(color: Color) -> some View {
        RoundedCorner(radius: cornerRadius, corners: corners)
            .fill(color)
    }
}

// ===== FILE: Timetable DSW/Features/Common/Views/ShadowStyle.swift =====
import SwiftUI

public struct ShadowStyle {
    // MARK: - Properties
    
    public var color: Color
    public var radius: CGFloat
    public var x: CGFloat
    public var y: CGFloat
    
    // MARK: - Initialization
    
    public init(
        color: Color = .black.opacity(0.1),
        radius: CGFloat = 4,
        x: CGFloat = 0,
        y: CGFloat = 4
    ) {
        self.color = color
        self.radius = radius
        self.x = x
        self.y = y
    }
}

// ===== FILE: Timetable DSW/Features/Debug/AdsDebugScreen.swift =====
import SwiftUI

struct AdsDebugScreen: View {
    @Environment(\.adCoordinator) private var coordinator
    @State private var logs: [LogEntry] = []
    @State private var isRewardedReady = false
    @State private var isInterstitialReady = false
    @State private var isRewardedInterstitialReady = false

    struct LogEntry: Identifiable {
        let id = UUID()
        let timestamp: Date
        let message: String

        var formattedTime: String {
            let formatter = DateFormatter()
            formatter.timeStyle = .medium
            return formatter.string(from: timestamp)
        }
    }

    var body: some View {
        List {
            bannerSection
            nativeSection
            interstitialSection
            rewardedSection
            rewardedInterstitialSection
            appOpenSection
            adInspectorSection
            logSection
        }
        .navigationTitle(LocalizedString.adsDebugTitle.localized)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            updateReadyStates()
        }
    }

    // MARK: - Sections

    private var bannerSection: some View {
        Section {
            VStack(spacing: 12) {
                Text(LocalizedString.adsDebugAdaptiveBanner.localized)
                    .font(.caption)
                    .foregroundColor(.secondary)

                // Баннер с правильными размерами
                AdaptiveBannerView()
                    .background(Color(uiColor: .secondarySystemBackground))
                    .cornerRadius(8)
            }
            .padding(.vertical, 8)
        } header: {
            Label(LocalizedString.adsDebugBannerAd.localized, systemImage: "rectangle.3.group")
        } footer: {
            Text(LocalizedString.adsDebugBannerDescription.localized)
                .font(.caption2)
        }
    }

    private var nativeSection: some View {
        Section {
            VStack(spacing: 12) {
                Text(LocalizedString.adsDebugNativeAd.localized)
                    .font(.caption)
                    .foregroundColor(.secondary)

                NativeAdViewSui(style: .card)
//                NativeAdViewSui(style: .basic)
//                NativeAdViewSui(style: .banner)
//                NativeAdViewSui(style: .largeBanner)
            }

            .padding(.vertical, 8)
        } header: {
            Label(LocalizedString.adsDebugNativeAd.localized, systemImage: "square.and.pencil")
        } footer: {
            Text(LocalizedString.adsDebugNativeDescription.localized)
                .font(.caption2)
        }
//        .withNativeAds()
    }

    private var interstitialSection: some View {
        Section {
            HStack(spacing: 16) {
                Button {
                    Task {
                        await loadAd(type: .interstitial)
                    }
                } label: {
                    Label(LocalizedString.adsDebugLoad.localized, systemImage: "arrow.down.circle")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)

                Button {
                    Task {
                        await showAd(type: .interstitial)
                    }
                } label: {
                    Label(LocalizedString.adsDebugShow.localized, systemImage: "play.circle.fill")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                .disabled(!isInterstitialReady)
            }

            if isInterstitialReady {
                Label(LocalizedString.adsDebugReadyToShow.localized, systemImage: "checkmark.circle.fill")
                    .font(.caption)
                    .foregroundColor(.green)
            }
        } header: {
            Label(LocalizedString.adsDebugInterstitialAd.localized, systemImage: "square.fill")
        } footer: {
            Text(LocalizedString.adsDebugInterstitialDescription.localized)
                .font(.caption2)
        }
    }

    private var rewardedSection: some View {
        Section {
            HStack(spacing: 16) {
                Button {
                    Task {
                        await loadAd(type: .rewarded)
                    }
                } label: {
                    Label(LocalizedString.adsDebugLoad.localized, systemImage: "arrow.down.circle")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)

                Button {
                    Task {
                        await showAd(type: .rewarded)
                    }
                } label: {
                    Label(LocalizedString.adsDebugShow.localized, systemImage: "gift.circle.fill")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                .disabled(!isRewardedReady)
            }

            if isRewardedReady {
                Label(LocalizedString.adsDebugReadyToShow.localized, systemImage: "checkmark.circle.fill")
                    .font(.caption)
                    .foregroundColor(.green)
            }
        } header: {
            Label(LocalizedString.adsDebugRewardedAd.localized, systemImage: "gift")
        } footer: {
            Text(LocalizedString.adsDebugRewardedDescription.localized)
                .font(.caption2)
        }
    }

    private var rewardedInterstitialSection: some View {
        Section {
            HStack(spacing: 16) {
                Button {
                    Task {
                        await loadAd(type: .rewardedInterstitial)
                    }
                } label: {
                    Label(LocalizedString.adsDebugLoad.localized, systemImage: "arrow.down.circle")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)

                Button {
                    Task {
                        await showAd(type: .rewardedInterstitial)
                    }
                } label: {
                    Label(LocalizedString.adsDebugShow.localized, systemImage: "gift.circle.fill")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                .disabled(!isRewardedInterstitialReady)
            }

            if isRewardedInterstitialReady {
                Label(LocalizedString.adsDebugReadyToShow.localized, systemImage: "checkmark.circle.fill")
                    .font(.caption)
                    .foregroundColor(.green)
            }
        } header: {
            Label(LocalizedString.adsDebugRewardedInterstitial.localized, systemImage: "gift.fill")
        } footer: {
            Text(LocalizedString.adsDebugRewardedInterstitialDescription.localized)
                .font(.caption2)
        }
    }

    private var appOpenSection: some View {
        Section {
            HStack(spacing: 16) {
                Button {
                    Task {
                        await loadAd(type: .appOpen)
                    }
                } label: {
                    Label(LocalizedString.adsDebugPreload.localized, systemImage: "arrow.down.circle")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)

                Button {
                    Task {
                        await showAd(type: .appOpen)
                    }
                } label: {
                    Label(LocalizedString.adsDebugShow.localized, systemImage: "arrow.up.forward.app")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
            }
        } header: {
            Label(LocalizedString.adsDebugAppOpenAd.localized, systemImage: "app.badge")
        } footer: {
            Text(LocalizedString.adsDebugAppOpenDescription.localized)
                .font(.caption2)
        }
    }

    private var adInspectorSection: some View {
        Section {
            Button {
                Task {
                    await coordinator?.presentAdInspector()
                    addLog("Ad Inspector opened")
                }
            } label: {
                Label(LocalizedString.adsDebugLaunchAdInspector.localized, systemImage: "magnifyingglass.circle")
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .tint(.purple)
        } header: {
            Label(LocalizedString.adsDebugDeveloperTools.localized, systemImage: "wrench.and.screwdriver")
        } footer: {
            Text(LocalizedString.adsDebugAdInspectorDescription.localized)
                .font(.caption2)
        }
    }

    private var logSection: some View {
        Section {
            if logs.isEmpty {
                Text(LocalizedString.adsDebugNoEventsYet.localized)
                    .foregroundColor(.secondary)
                    .font(.caption)
            } else {
                ForEach(logs.reversed()) { log in
                    VStack(alignment: .leading, spacing: 4) {
                        Text(log.message)
                            .font(.caption)
                        Text(log.formattedTime)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }

            if !logs.isEmpty {
                Button(LocalizedString.adsDebugClearLog.localized) {
                    logs.removeAll()
                }
                .font(.caption)
                .foregroundColor(.red)
            }
        } header: {
            Label(LocalizedString.adsDebugEventLog.localized, systemImage: "list.bullet.rectangle")
        }
    }

    // MARK: - Actions

    private func loadAd(type: AdType) async {
        guard let coordinator = coordinator else {
            addLog("❌ No coordinator available")
            return
        }

        addLog("⏳ Loading \(type)...")

        do {
            try await coordinator.loadAd(type: type)
            addLog("✅ \(type) loaded successfully")
            updateReadyStates()
        } catch {
            addLog("❌ Failed to load \(type): \(error.localizedDescription)")
        }
    }

    private func showAd(type: AdType) async {
        guard let coordinator = coordinator else {
            addLog("❌ No coordinator available")
            return
        }

        addLog("▶️ Showing \(type)...")

        do {
            try await coordinator.showAd(type: type)
            addLog("✅ \(type) shown successfully")
            updateReadyStates()
        } catch {
            addLog("❌ Failed to show \(type): \(error.localizedDescription)")
        }
    }

    private func updateReadyStates() {
        guard let coordinator = coordinator else { return }

        isInterstitialReady = coordinator.isAdReady(type: .interstitial)
        isRewardedReady = coordinator.isAdReady(type: .rewarded)
        isRewardedInterstitialReady = coordinator.isAdReady(type: .rewardedInterstitial)
    }

    private func addLog(_ message: String) {
        logs.append(LogEntry(timestamp: Date(), message: message))

        // Ограничиваем количество логов
        if logs.count > 50 {
            logs.removeFirst()
        }
    }
}

// MARK: - Preview

struct AdsDebugScreen_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            AdsDebugScreen()
        }
    }
}

// ===== FILE: Timetable DSW/Features/Debug/Views/DebugMenu.swift =====
import SwiftUI
import Combine

// MARK: - Presentation Models (Single Responsibility: Data for UI)

struct PremiumStatusPresentation {
    let statusText: String
    let expirationDate: Date?
    let canRevoke: Bool

    init(status: PremiumStatus) {
        switch status {
        case .free:
            self.statusText = LocalizedString.debugFree.localized
            self.expirationDate = nil
            self.canRevoke = false

        case .premium:
            self.statusText = LocalizedString.debugPremiumLabel.localized
            self.expirationDate = nil
            self.canRevoke = true

        case .temporaryPremium(let expiresAt):
            self.statusText = LocalizedString.debugTrial.localized
            self.expirationDate = expiresAt
            self.canRevoke = true
        }
    }
}

struct FeatureFlagPresentation: Identifiable {
    let id: FeatureFlag
    let flag: FeatureFlag
    let isEnabled: Bool
    let hasLocalOverride: Bool

    var displayName: String { flag.displayName }
    var description: String { flag.description }
}

struct AppStatistics {
    let totalAdsWatched: Int
    let lastAdWatchedDate: Date?
    let premiumPurchaseDate: Date?

    init(from state: AppState) {
        self.totalAdsWatched = state.totalAdsWatched
        self.lastAdWatchedDate = state.lastAdWatchedDate
        self.premiumPurchaseDate = state.premiumPurchaseDate
    }
}

// MARK: - Debug Actions (Single Responsibility: User Actions)

enum DebugAction {
    case grantPremium
    case grantTemporaryPremium
    case revokePremium
    case toggleFlag(FeatureFlag, Bool)
    case resetFlag(FeatureFlag)
    case resetAllFlags
    case syncFlags
    case clearAllData
    case crashApp
}

// MARK: - View State

enum LoadingState: Equatable {
    case idle
    case loading
    case success
    case failure(String)

    var isLoading: Bool {
        if case .loading = self { return true }
        return false
    }
}

// MARK: - ViewModel

@MainActor
final class DebugMenuViewModel: ObservableObject {

    // MARK: - Dependencies

    private let featureFlagService: FeatureFlagService  // ✅ Protocol!
    private let appStateService: AppStateService        // ✅ Protocol!

    // MARK: - Published State

    @Published private(set) var premiumPresentation: PremiumStatusPresentation
    @Published private(set) var featureFlags: [FeatureFlagPresentation] = []
    @Published private(set) var statistics: AppStatistics
    @Published private(set) var syncState: LoadingState = .idle
    @Published private(set) var lastSyncDate: Date?

    // Alert state
    @Published var alertMessage: String?
    @Published var showAlert = false
    @Published var confirmationAction: DebugAction?
    @Published var showConfirmation = false

    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(
        featureFlagService: FeatureFlagService,  // ✅ Protocol!
        appStateService: AppStateService         // ✅ Protocol!
    ) {
        self.featureFlagService = featureFlagService
        self.appStateService = appStateService

        // Initialize presentations
        self.premiumPresentation = PremiumStatusPresentation(
            status: appStateService.premiumStatus
        )
        self.statistics = AppStatistics(from: appStateService.state)

        setupBindings()
        updateFeatureFlags()
    }

    // MARK: - Public Methods

    func handle(_ action: DebugAction) {
        switch action {
        case .grantPremium:
            appStateService.grantPremium()
            showSuccessAlert(LocalizedString.debugPremiumGranted.localized)

        case .grantTemporaryPremium:
            appStateService.grantTemporaryPremium(duration: nil)
            showSuccessAlert(LocalizedString.debugTemporaryPremiumGranted.localized)

        case .revokePremium:
            confirmationAction = action
            showConfirmation = true

        case .toggleFlag(let flag, let enabled):
            featureFlagService.setEnabled(flag, enabled: enabled)

        case .resetFlag(let flag):
            featureFlagService.reset(flag)
            showSuccessAlert("Flag '\(flag.displayName)' reset to default")

        case .resetAllFlags:
            confirmationAction = action
            showConfirmation = true

        case .syncFlags:
            Task { await syncFeatureFlags() }

        case .clearAllData:
            confirmationAction = action
            showConfirmation = true
        case .crashApp:
            let numbers = [0]
            let _ = numbers[1]
        }
    }

    func confirmAction() {
        guard let action = confirmationAction else { return }
        confirmationAction = nil

        switch action {
        case .revokePremium:
            appStateService.revokePremium()
            showSuccessAlert(LocalizedString.debugPremiumRevoked.localized)

        case .resetAllFlags:
            featureFlagService.resetAll()
            showSuccessAlert(LocalizedString.debugAllFlagsReset.localized)

        case .clearAllData:
            featureFlagService.resetAll()
            appStateService.revokePremium()
            showSuccessAlert(LocalizedString.debugAllDataCleared.localized)

        default:
            break
        }
    }

    func binding(for flag: FeatureFlag) -> Binding<Bool> {
        Binding(
            get: { [weak self] in
                self?.featureFlagService.isEnabled(flag) ?? flag.defaultValue
            },
            set: { [weak self] newValue in
                self?.handle(.toggleFlag(flag, newValue))
            }
        )
    }

    // MARK: - Private Methods

    private func setupBindings() {
        // Observe app state changes via publisher
        appStateService.statePublisher
            .sink { [weak self] state in
                self?.premiumPresentation = PremiumStatusPresentation(status: state.premiumStatus)
                self?.statistics = AppStatistics(from: state)
            }
            .store(in: &cancellables)

        // Observe feature flags changes via publisher
        featureFlagService.flagsPublisher
            .sink { [weak self] _ in
                self?.updateFeatureFlags()
            }
            .store(in: &cancellables)
    }

    private func updateFeatureFlags() {
        featureFlags = FeatureFlag.allCases.map { flag in
            FeatureFlagPresentation(
                id: flag,
                flag: flag,
                isEnabled: featureFlagService.isEnabled(flag),
                hasLocalOverride: featureFlagService.hasLocalOverride(for: flag)
            )
        }
    }

    private func syncFeatureFlags() async {
        syncState = .loading

        do {
            try await featureFlagService.syncFromRemote()
            syncState = .success
            lastSyncDate = Date()

            // Reset to idle after delay
            try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
            syncState = .idle

        } catch {
            syncState = .failure(error.localizedDescription)
            showErrorAlert("Sync failed: \(error.localizedDescription)")

            // Reset to idle after delay
            try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            syncState = .idle
        }
    }

    private func showSuccessAlert(_ message: String) {
        alertMessage = message
        showAlert = true
    }

    private func showErrorAlert(_ message: String) {
        alertMessage = message
        showAlert = true
    }
}

// MARK: - Confirmation Dialog Helper

extension DebugAction {
    var confirmationTitle: String {
        switch self {
        case .revokePremium:
            return LocalizedString.debugRevokePremiumQuestion.localized
        case .resetAllFlags:
            return LocalizedString.debugResetAllFlagsQuestion.localized
        case .clearAllData:
            return LocalizedString.debugClearAllDataQuestion.localized
        default:
            return LocalizedString.debugConfirmActionQuestion.localized
        }
    }

    var confirmationMessage: String {
        switch self {
        case .revokePremium:
            return LocalizedString.debugWillRemovePremium.localized
        case .resetAllFlags:
            return LocalizedString.debugWillResetAllFlags.localized
        case .clearAllData:
            return LocalizedString.debugWillResetEverything.localized
        default:
            return LocalizedString.debugAreYouSure.localized
        }
    }
}

// MARK: - Debug Menu View

struct DebugMenuScreen: View {

    @StateObject private var viewModel: DebugMenuViewModel
    @Environment(\.dismiss) var dismiss

    init(
        featureFlagService: FeatureFlagService,  // ✅ Protocol!
        appStateService: AppStateService         // ✅ Protocol!
    ) {
        _viewModel = StateObject(
            wrappedValue: DebugMenuViewModel(
                featureFlagService: featureFlagService,
                appStateService: appStateService
            )
        )
    }

    var body: some View {
        NavigationView {
            List {
                premiumSection
                featureFlagsSection
                actionsSection
                statisticsSection
                aboutSection
            }
            .navigationTitle(LocalizedString.debugMenuTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(LocalizedString.debugDone.localized) { dismiss() }
                }
            }
            .alert(LocalizedString.debugActionResult.localized, isPresented: $viewModel.showAlert) {
                Button(LocalizedString.debugOK.localized, role: .cancel) { }
            } message: {
                if let message = viewModel.alertMessage {
                    Text(message)
                }
            }
            .confirmationDialog(
                viewModel.confirmationAction?.confirmationTitle ?? "",
                isPresented: $viewModel.showConfirmation,
                titleVisibility: .visible
            ) {
                Button(LocalizedString.debugConfirm.localized, role: .destructive) {
                    viewModel.confirmAction()
                }
                Button(LocalizedString.debugCancel.localized, role: .cancel) { }
            } message: {
                Text(viewModel.confirmationAction?.confirmationMessage ?? "")
            }
        }
    }

    // MARK: - Premium Section

    private var premiumSection: some View {
        Section {
            HStack {
                Label(LocalizedString.debugStatus.localized, systemImage: "crown.fill")
                Spacer()
                Text(viewModel.premiumPresentation.statusText)
                    .foregroundColor(.secondary)
                    .fontWeight(.medium)
            }

            if let expiration = viewModel.premiumPresentation.expirationDate {
                HStack {
                    Label(LocalizedString.debugExpires.localized, systemImage: "clock.fill")
                    Spacer()
                    Text(expiration, style: .relative)
                        .foregroundColor(.orange)
                }
            }

            Button {
                viewModel.handle(.grantPremium)
            } label: {
                Label(LocalizedString.debugGrantPremium.localized, systemImage: "star.fill")
            }

            Button {
                viewModel.handle(.grantTemporaryPremium)
            } label: {
                Label(LocalizedString.debugGrantTrial1h.localized, systemImage: "timer")
            }

            if viewModel.premiumPresentation.canRevoke {
                Button(role: .destructive) {
                    viewModel.handle(.revokePremium)
                } label: {
                    Label(LocalizedString.debugRevokePremiumLabel.localized, systemImage: "xmark.circle.fill")
                }
            }
        } header: {
            Label(LocalizedString.debugPremiumManagement.localized, systemImage: "crown")
        }
    }

    // MARK: - Feature Flags Section

    private var featureFlagsSection: some View {
        Section {
            ForEach(viewModel.featureFlags) { presentation in
                VStack(alignment: .leading, spacing: 6) {
                    Toggle(isOn: viewModel.binding(for: presentation.flag)) {
                        VStack(alignment: .leading, spacing: 4) {
                            HStack {
                                Text(presentation.displayName)
                                    .font(.body)

                                if presentation.hasLocalOverride {
                                    Image(systemName: "pencil.circle.fill")
                                        .font(.caption)
                                        .foregroundColor(.orange)
                                }
                            }

                            Text(presentation.description)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    }

                    if presentation.hasLocalOverride {
                        Button {
                            viewModel.handle(.resetFlag(presentation.flag))
                        } label: {
                            Label(LocalizedString.debugResetToDefaultLabel.localized, systemImage: "arrow.counterclockwise")
                                .font(.caption)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding(.vertical, 4)
            }

            Button(role: .destructive) {
                viewModel.handle(.resetAllFlags)
            } label: {
                Label(LocalizedString.debugResetAllFlagsLabel.localized, systemImage: "arrow.counterclockwise.circle.fill")
            }
        } header: {
            Label(LocalizedString.debugFeatureFlagsTitle.localized, systemImage: "flag.fill")
        } footer: {
            VStack(alignment: .leading, spacing: 4) {
                Text(LocalizedString.debugLocalOverrides.localized)
                if let lastSync = viewModel.lastSyncDate {
                    Text("\(LocalizedString.debugLastSynced.localized): \(lastSync, style: .relative)")
                        .foregroundColor(.secondary)
                }
            }
            .font(.caption2)
        }
    }

    // MARK: - Actions Section

    private var actionsSection: some View {
        Section {
            Button {
                viewModel.handle(.syncFlags)
            } label: {
                HStack {
                    Label(LocalizedString.debugSyncFromServer.localized, systemImage: "arrow.triangle.2.circlepath")

                    Spacer()

                    if viewModel.syncState.isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else if case .success = viewModel.syncState {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                    } else if case .failure = viewModel.syncState {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .foregroundColor(.red)
                    }
                }
            }
            .disabled(viewModel.syncState.isLoading)

            Button(role: .destructive) {
                viewModel.handle(.clearAllData)
            } label: {
                Label(LocalizedString.debugClearAllData.localized, systemImage: "trash.fill")
            }

            Button(role: .destructive) {
                viewModel.handle(.crashApp)
            } label: {
                Label("💥", systemImage: "ladybug.fill")
            }
        } header: {
            Label(LocalizedString.debugActionsTitle.localized, systemImage: "gearshape.fill")
        }
    }

    // MARK: - Statistics Section

    private var statisticsSection: some View {
        Section {
            HStack {
                Label(LocalizedString.debugAdsWatched.localized, systemImage: "play.rectangle.fill")
                Spacer()
                Text("\(viewModel.statistics.totalAdsWatched)")
                    .foregroundColor(.secondary)
                    .monospacedDigit()
            }

            if let lastAdDate = viewModel.statistics.lastAdWatchedDate {
                HStack {
                    Label(LocalizedString.debugLastAd.localized, systemImage: "clock.fill")
                    Spacer()
                    Text(lastAdDate, style: .relative)
                        .foregroundColor(.secondary)
                }
            }

            if let purchaseDate = viewModel.statistics.premiumPurchaseDate {
                HStack {
                    Label(LocalizedString.debugPremiumSince.localized, systemImage: "calendar")
                    Spacer()
                    Text(purchaseDate, style: .date)
                        .foregroundColor(.secondary)
                }
            }
        } header: {
            Label(LocalizedString.debugStatistics.localized, systemImage: "chart.bar.fill")
        }
    }

    // MARK: - About Section

    private var aboutSection: some View {
        Section {
            HStack {
                Text(LocalizedString.debugEnvironment.localized)
                Spacer()
                #if DEBUG
                Text(LocalizedString.debugDebug.localized)
                    .foregroundColor(.orange)
                    .fontWeight(.medium)
                #else
                Text(LocalizedString.debugRelease.localized)
                    .foregroundColor(.green)
                    .fontWeight(.medium)
                #endif
            }

            HStack {
                Text(LocalizedString.debugBuild.localized)
                Spacer()
                Text(Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "Unknown")
                    .foregroundColor(.secondary)
                    .monospacedDigit()
            }
        } header: {
            Label(LocalizedString.debugAbout.localized, systemImage: "info.circle.fill")
        } footer: {
            Text(LocalizedString.debugOnlyInDebugBuilds.localized)
                .font(.caption2)
        }
    }
}

// MARK: - Preview

#if DEBUG
struct DebugMenuScreen_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            // Free user
            DebugMenuScreen(
                featureFlagService: MockFeatureFlagService(),
                appStateService: MockAppStateService()
            )
            .previewDisplayName("Free User")

            // Premium user
            DebugMenuScreen(
                featureFlagService: MockFeatureFlagService(),
                appStateService: MockAppStateService(
                    initialState: AppState(
                        premiumStatus: .premium,
                        premiumPurchaseDate: Date(),
                        lastAdWatchedDate: nil,
                        totalAdsWatched: 0
                    )
                )
            )
            .previewDisplayName("Premium User")

            // Trial user with stats
            DebugMenuScreen(
                featureFlagService: MockFeatureFlagService(defaultFlags: [
                    .showAds: true,
                    .showDebugMenu: true
                ]),
                appStateService: MockAppStateService(
                    initialState: AppState(
                        premiumStatus: .temporaryPremium(
                            expiresAt: Date().addingTimeInterval(AppStateConfiguration.temporaryPremiumDuration)
                        ),
                        premiumPurchaseDate: nil,
                        lastAdWatchedDate: Date().addingTimeInterval(-300),
                        totalAdsWatched: 15
                    )
                )
            )
            .previewDisplayName("Trial User with Stats")
        }
    }
}
#endif

// ===== FILE: Timetable DSW/Features/Debug/Views/PerformanceMonitorView.swift =====
import SwiftUI

struct PerformanceMonitorView: View {
    // MARK: - Properties

    @ObservedObject var logger = PerformanceLogger.shared
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.dismiss) var dismiss

    @State private var selectedCategory: PerformanceCategory?
    @State private var showingExportSheet = false
    @State private var exportedJSON: String = ""

    // MARK: - Body

    var body: some View {
        NavigationView {
            List {
                metricsSection
                categoryFilterSection
                eventsSection
            }
            .navigationTitle(LocalizedString.perfMonitorTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(LocalizedString.perfMonitorClear.localized) {
                        logger.clear()
                    }
                    .foregroundAppColor(.error, colorScheme: colorScheme)
                }

                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(LocalizedString.perfMonitorExport.localized) {
                        if let json = logger.exportJSON() {
                            exportedJSON = json
                            showingExportSheet = true
                        }
                    }
                }

                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(LocalizedString.debugDone.localized) {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showingExportSheet) {
                NavigationView {
                    ScrollView {
                        Text(exportedJSON)
                            .font(.system(.caption, design: .monospaced))
                            .padding()
                    }
                    .navigationTitle(LocalizedString.perfMonitorExportedEvents.localized)
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .navigationBarTrailing) {
                            Button(LocalizedString.debugDone.localized) {
                                showingExportSheet = false
                            }
                        }
                    }
                }
            }
        }
    }

    // MARK: - Sections

    private var metricsSection: some View {
        Section(LocalizedString.perfMonitorMetrics.localized) {
            HStack {
                Text(LocalizedString.perfMonitorTotalEvents.localized)
                Spacer()
                Text("\(logger.metrics.totalEvents)")
                    .fontWeight(.bold)
            }

            HStack {
                Text(LocalizedString.perfMonitorAverageDuration.localized)
                Spacer()
                Text(formatDuration(logger.metrics.averageDuration))
                    .fontWeight(.bold)
            }

            if let slowest = logger.metrics.slowestEvent {
                VStack(alignment: .leading, spacing: 4) {
                    Text(LocalizedString.perfMonitorSlowestEvent.localized)
                        .font(.caption)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    HStack {
                        Text(slowest.name)
                        Spacer()
                        Text(slowest.formattedDuration)
                            .fontWeight(.bold)
                            .foregroundColor(slowest.severityLevel.color)
                    }
                }
            }

            if let fastest = logger.metrics.fastestEvent {
                VStack(alignment: .leading, spacing: 4) {
                    Text(LocalizedString.perfMonitorFastestEvent.localized)
                        .font(.caption)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    HStack {
                        Text(fastest.name)
                        Spacer()
                        Text(fastest.formattedDuration)
                            .fontWeight(.bold)
                            .foregroundColor(.green)
                    }
                }
            }
        }
    }

    private var categoryFilterSection: some View {
        Section(LocalizedString.perfMonitorFilterByCategory.localized) {
            Picker(LocalizedString.perfMonitorCategory.localized, selection: $selectedCategory) {
                Text(LocalizedString.perfMonitorAll.localized).tag(nil as PerformanceCategory?)
                ForEach(PerformanceCategory.allCases, id: \.self) { category in
                    HStack {
                        Text(category.rawValue)
                        if let count = logger.metrics.eventsByCategory[category] {
                            Text("(\(count))")
                                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        }
                    }
                    .tag(category as PerformanceCategory?)
                }
            }
            .pickerStyle(.menu)
        }
    }

    private var eventsSection: some View {
        Section("\(LocalizedString.perfMonitorEvents.localized) (\(filteredEvents.count))") {
            if filteredEvents.isEmpty {
                Text(LocalizedString.perfMonitorNoEventsRecorded.localized)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .italic()
            } else {
                ForEach(filteredEvents.reversed()) { event in
                    EventRow(event: event)
                }
            }
        }
    }

    // MARK: - Computed Properties

    private var filteredEvents: [PerformanceEvent] {
        if let category = selectedCategory {
            return logger.events.filter { $0.category == category }
        }
        return logger.events
    }

    // MARK: - Helpers

    private func formatDuration(_ duration: TimeInterval) -> String {
        if duration < 0.001 {
            return String(format: "%.0f μs", duration * 1_000_000)
        } else if duration < 1.0 {
            return String(format: "%.1f ms", duration * 1000)
        } else {
            return String(format: "%.2f s", duration)
        }
    }
}

// MARK: - Event Row

private struct EventRow: View {
    let event: PerformanceEvent

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            HStack {
                Text(event.severityLevel.rawValue)
                Text(event.name)
                    .fontWeight(.semibold)
                Spacer()
                if let duration = event.duration {
                    Text(event.formattedDuration)
                        .font(.system(.caption, design: .monospaced))
                        .fontWeight(.bold)
                        .foregroundColor(event.severityLevel.color)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(
                            event.severityLevel.color.opacity(0.15),
                            in: RoundedRectangle(cornerRadius: 4)
                        )
                }
            }

            HStack {
                Text(event.category.rawValue)
                    .font(.caption)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(
                        AppColor.themeAccent.color(for: colorScheme).opacity(0.15),
                        in: RoundedRectangle(cornerRadius: 4)
                    )

                Text(formatTimestamp(event.timestamp))
                    .font(.caption)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)

                Spacer()
            }

            if !event.metadata.isEmpty {
                VStack(alignment: .leading, spacing: 2) {
                    ForEach(Array(event.metadata.keys.sorted()), id: \.self) { key in
                        HStack {
                            Text(key + ":")
                                .font(.caption2)
                                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                            Text(event.metadata[key] ?? "")
                                .font(.caption2)
                                .fontWeight(.medium)
                        }
                    }
                }
                .padding(.top, 2)
            }
        }
        .padding(.vertical, 4)
    }

    private func formatTimestamp(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss.SSS"
        return formatter.string(from: date)
    }
}

// ===== FILE: Timetable DSW/Features/Premium/PremiumFeature.swift =====
import Foundation

// MARK: - Premium Features

enum PremiumFeature: String, CaseIterable, Codable, Sendable {
    case teachersTab = "teachers_tab"
    case subjectsTab = "subjects_tab"
    case themeSettings = "theme_settings"
    case widgetSettings = "widget_settings"
//    case advancedFilters = "advanced_filters"
//    case exportSchedule = "export_schedule"

    var displayName: String {
        switch self {
        case .teachersTab: return LocalizedString.featureTeachersTab.localized
        case .subjectsTab: return LocalizedString.featureSubjectsTab.localized
        case .themeSettings: return LocalizedString.featureThemeSettings.localized
        case .widgetSettings: return LocalizedString.featureWidgetSettings.localized
//        case .advancedFilters: return "Advanced Filters"
//        case .exportSchedule: return "Export Schedule"
        }
    }

    var description: String {
        switch self {
        case .teachersTab:
            return LocalizedString.featureTeachersTabDescription.localized
        case .subjectsTab:
            return LocalizedString.featureSubjectsTabDescription.localized
        case .themeSettings:
            return LocalizedString.featureThemeSettingsDescription.localized
        case .widgetSettings:
            return LocalizedString.widgetConfigure.localized
//        case .advancedFilters:
//            return "Advanced filtering options"
//        case .exportSchedule:
//            return "Export your schedule to calendar"
        }
    }

    var icon: String {
        switch self {
        case .teachersTab: return "person.2.fill"
        case .subjectsTab: return "book.fill"
        case .themeSettings: return "paintpalette.fill"
        case .widgetSettings: return "square.grid.2x2.fill"
//        case .advancedFilters: return "line.3.horizontal.decrease.circle.fill"
//        case .exportSchedule: return "square.and.arrow.up.fill"
        }
    }
}

// MARK: - Premium Access

struct PremiumAccess: Sendable {
    let isPremium: Bool
    let status: PremiumStatus
    let expiresAt: Date?

    var timeRemaining: TimeInterval? {
        guard case .temporaryPremium(let expiresAt) = status else {
            return nil
        }
        let remaining = expiresAt.timeIntervalSince(Date())
        return remaining > 0 ? remaining : 0
    }

    var formattedTimeRemaining: String? {
        guard let remaining = timeRemaining else { return nil }

        let hours = Int(remaining) / AppStateConfiguration.secondsInHour
        let minutes = (Int(remaining) % AppStateConfiguration.secondsInHour) / 60
        let seconds = Int(remaining) % 60

        if hours > 0 {
            return String(format: "%dh %dm", hours, minutes)
        } else if minutes > 0 {
            return String(format: "%dm %ds", minutes, seconds)
        } else {
            return String(format: "%ds", seconds)
        }
    }

    static func from(appState: AppState) -> PremiumAccess {
        let expiresAt: Date?
        if case .temporaryPremium(let date) = appState.premiumStatus {
            expiresAt = date
        } else {
            expiresAt = nil
        }

        return PremiumAccess(
            isPremium: appState.premiumStatus.isPremium,
            status: appState.premiumStatus,
            expiresAt: expiresAt
        )
    }

    func hasAccess(to feature: PremiumFeature) -> Bool {
        return isPremium
    }
}

// ===== FILE: Timetable DSW/Features/Premium/Views/ConfettiView.swift =====
import SwiftUI

// MARK: - Confetti Particle

struct ConfettiParticle: Identifiable {
    let id = UUID()
    let color: Color
    let x: CGFloat
    let y: CGFloat
    let rotation: Double
    let scale: CGFloat
}

// MARK: - Confetti View

struct ConfettiView: View {
    // MARK: - Configuration

    struct Configuration {
        let particleCount: Int
        let animationDuration: Double
        let colors: [Color]

        static let `default` = Configuration(
            particleCount: 50,
            animationDuration: 3.0,
            colors: GradientStyle.primary.colors(for: .light)
        )

        static let rainbow = Configuration(
            particleCount: 60,
            animationDuration: 3.5,
            colors: [
                .red, .orange, .yellow,
                .green, .cyan, .blue,
                .purple, .pink
            ]
        )
    }

    // MARK: - Properties

    let configuration: Configuration
    let onComplete: () -> Void

    @State private var particles: [ConfettiParticle] = []
    @State private var isAnimating = false

    @Environment(\.colorScheme) var colorScheme

    // MARK: - Body

    var body: some View {
        ZStack {
            // Background
            Color.black.opacity(0.3)
                .ignoresSafeArea()
                .onTapGesture {
                    complete()
                }

            // Particles
            ForEach(particles) { particle in
                Circle()
                    .fill(particle.color)
                    .frame(width: 10 * particle.scale, height: 10 * particle.scale)
                    .rotationEffect(.degrees(isAnimating ? particle.rotation + 720 : particle.rotation))
                    .offset(
                        x: particle.x,
                        y: isAnimating ? UIScreen.main.bounds.height : particle.y
                    )
                    .opacity(isAnimating ? 0 : 1)
            }

            // Center message
            VStack(spacing: AppSpacing.large.value) {
                Text("🎉")
                    .font(.system(size: 100))
                    .scaleEffect(isAnimating ? 1.0 : 0.5)

                Text(LocalizedString.premiumUnlocked.localized)
                    .font(AppTypography.title.font)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .shadow(color: .black.opacity(0.3), radius: 10)
                    .scaleEffect(isAnimating ? 1.0 : 0.5)
                    .opacity(isAnimating ? 1.0 : 0)
            }
        }
        .onAppear {
            generateParticles()
            withAnimation(.easeOut(duration: configuration.animationDuration)) {
                isAnimating = true
            }

            // Auto-dismiss
            DispatchQueue.main.asyncAfter(deadline: .now() + configuration.animationDuration) {
                complete()
            }
        }
    }

    // MARK: - Private Methods

    private func generateParticles() {
        let screenWidth = UIScreen.main.bounds.width
        let screenHeight = UIScreen.main.bounds.height

        particles = (0..<configuration.particleCount).map { _ in
            ConfettiParticle(
                color: configuration.colors.randomElement() ?? .blue,
                x: CGFloat.random(in: -screenWidth/2...screenWidth/2),
                y: CGFloat.random(in: (-screenHeight)/2...(-100)),
                rotation: Double.random(in: 0...360),
                scale: CGFloat.random(in: 0.5...1.5)
            )
        }
    }

    private func complete() {
        onComplete()
    }
}

// MARK: - Confetti Modifier

struct ConfettiModifier: ViewModifier {
    @Binding var isShowing: Bool
    let configuration: ConfettiView.Configuration

    func body(content: Content) -> some View {
        ZStack {
            content

            if isShowing {
                ConfettiView(configuration: configuration) {
                    isShowing = false
                }
                .transition(.opacity)
                .zIndex(999)
            }
        }
    }
}

extension View {
    func confetti(
        isShowing: Binding<Bool>,
        configuration: ConfettiView.Configuration = .rainbow
    ) -> some View {
        modifier(
            ConfettiModifier(
                isShowing: isShowing,
                configuration: configuration
            )
        )
    }
}

// ===== FILE: Timetable DSW/Features/Premium/Views/PremiumContentModifier.swift =====
import SwiftUI

// MARK: - Premium Content Modifier

struct PremiumContentModifier: ViewModifier {
    let feature: PremiumFeature
    let premiumAccess: PremiumAccess
    let onWatchAd: () -> Void
    let onPurchase: () -> Void

    @State private var showingPaywall = false

    func body(content: Content) -> some View {
        ZStack {
            content
                .blur(radius: premiumAccess.hasAccess(to: feature) ? 0 : 8)
                .disabled(!premiumAccess.hasAccess(to: feature))

            if !premiumAccess.hasAccess(to: feature) {
                premiumOverlay
                    .onTapGesture {
                        showingPaywall = true
                    }
            }
        }
        .sheet(isPresented: $showingPaywall) {
            PremiumPaywallView(
                feature: feature,
                onWatchAd: onWatchAd,
                onPurchase: onPurchase
            )
            .presentationDetents([.medium, .large])
        }
    }

    @ViewBuilder
    private var premiumOverlay: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(0.3)
                .ignoresSafeArea()

            // Lock icon and text
            VStack(spacing: AppSpacing.large.value) {
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: gradientColors.map { $0.opacity(0.2) },
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 80, height: 80)
                        .blur(radius: 20)

                    Image(systemName: "lock.fill")
                        .font(.system(size: 40))
                        .foregroundStyle(
                            LinearGradient(
                                colors: gradientColors,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }

                Text(LocalizedString.premiumFeatureTitle.localized)
                    .font(AppTypography.title3.font)
                    .fontWeight(.bold)
                    .foregroundColor(.white)

                Text(LocalizedString.premiumTapToUnlock.localized)
                    .font(AppTypography.body.font)
                    .foregroundColor(.white.opacity(0.8))
            }
        }
    }

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: .dark)
    }
}

// MARK: - View Extension

extension View {
    @ViewBuilder
    func premiumContent(
        feature: PremiumFeature,
        premiumAccess: PremiumAccess,
        coordinator: AdCoordinator?,
        onWatchAd: @escaping () -> Void,
        onPurchase: @escaping () -> Void
    ) -> some View {
        if coordinator?.isAdDisabled() ?? true {
            self
        } else {
            self.modifier(
                PremiumContentModifier(
                    feature: feature,
                    premiumAccess: premiumAccess,
                    onWatchAd: onWatchAd,
                    onPurchase: onPurchase
                )
            )
        }
    }
}

// ===== FILE: Timetable DSW/Features/Premium/Views/PremiumPaywallView.swift =====
import SwiftUI

struct PremiumPaywallView: View {
    // MARK: - Configuration

    struct Configuration: ComponentConfiguration {
        struct Constants {
            let iconSize: CGFloat = 80
            let spacing: AppSpacing = .xl
            let padding: AppSpacing = .xxl
            let buttonPadding: EdgeInsets = .init(
                top: AppSpacing.medium.value,
                leading: AppSpacing.xxxl.value,
                bottom: AppSpacing.medium.value,
                trailing: AppSpacing.xxxl.value
            )
            let cornerRadius: AppCornerRadius = .xl
            let shadowRadius: CGFloat = 20
            let shadowY: CGFloat = 8
            let glowOpacity: Double = 0.3
        }

        static let constants = Constants()
    }

    // MARK: - Properties

    let feature: PremiumFeature
    let onWatchAd: () -> Void
    let onPurchase: () -> Void

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @Environment(\.dismiss) var dismiss

    // MARK: - Body

    var body: some View {
        ZStack {
            // Blur background
            AppColor.background.color(for: colorScheme)
                .opacity(0.95)
                .ignoresSafeArea()

            VStack(spacing: Configuration.constants.spacing.value) {
                Spacer()

                iconView
                titleView
                descriptionView

                Spacer()

                actionButtons

                Spacer()
            }
            .padding(Configuration.constants.padding.value)
        }
        .onTapGesture {
            // Dismiss on background tap
            dismiss()
        }
    }

    // MARK: - Subviews

    private var iconView: some View {
        ZStack {
            // Glow effect
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(0.2) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: Configuration.constants.iconSize * 1.5, height: Configuration.constants.iconSize * 1.5)
                .blur(radius: 30)

            // Icon
            Image(systemName: feature.icon)
                .font(.system(size: Configuration.constants.iconSize))
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .shadow(
                    color: gradientColors.first?.opacity(0.5) ?? .clear,
                    radius: 20,
                    x: 0,
                    y: 10
                )
        }
    }

    private var titleView: some View {
        Text(LocalizedString.premiumFeatureTitle.localized)
            .font(AppTypography.title.font)
            .fontWeight(.bold)
            .themedForeground(.primary, colorScheme: colorScheme)
            .multilineTextAlignment(.center)
    }

    private var descriptionView: some View {
        VStack(spacing: AppSpacing.small.value) {
            Text(feature.displayName)
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
                .themedForeground(.header, colorScheme: colorScheme)
                .multilineTextAlignment(.center)

            Text(feature.description)
                .font(AppTypography.body.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
        }
    }

    private var actionButtons: some View {
        VStack(spacing: AppSpacing.medium.value) {
            // Watch ad button
            Button(action: {
                dismiss()
                onWatchAd()
            }) {
                HStack {
                    Image(systemName: "play.rectangle.fill")
                    Text(LocalizedString.premiumWatchAdButton.localized)
                        .fontWeight(.semibold)
                }
                .font(AppTypography.body.font)
                .foregroundAppColor(.white, colorScheme: colorScheme)
                .padding(Configuration.constants.buttonPadding)
                .frame(maxWidth: .infinity)
                .background {
                    primaryButtonBackground
                }
                .shadow(
                    color: gradientColors[0].opacity(0.4),
                    radius: Configuration.constants.shadowRadius,
                    x: 0,
                    y: Configuration.constants.shadowY
                )
            }
            .buttonStyle(ScaleButtonStyle())

            // Purchase button
//            Button(action: {
//                dismiss()
//                onPurchase()
//            }) {
//                HStack {
//                    Image(systemName: "cart.fill")
//                    Text("Purchase Premium")
//                        .fontWeight(.semibold)
//                }
//                .font(AppTypography.body.font)
//                .foregroundStyle(
//                    LinearGradient(
//                        colors: gradientColors,
//                        startPoint: .leading,
//                        endPoint: .trailing
//                    )
//                )
//                .padding(Configuration.constants.buttonPadding)
//                .frame(maxWidth: .infinity)
//                .background {
//                    RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
//                        .strokeBorder(
//                            LinearGradient(
//                                colors: gradientColors,
//                                startPoint: .leading,
//                                endPoint: .trailing
//                            ),
//                            lineWidth: 2
//                        )
//                }
//            }
//            .buttonStyle(ScaleButtonStyle())

            // Close button
            Button(LocalizedString.premiumMaybeLater.localized) {
                dismiss()
            }
            .font(AppTypography.subheadline.font)
            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    private var primaryButtonBackground: some View {
        ZStack {
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(.ultraThinMaterial)

            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .opacity(0.9)

            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(Configuration.constants.glowOpacity),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .topLeading,
                        startRadius: 5,
                        endRadius: 100
                    )
                )
        }
    }

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }
}

// ===== FILE: Timetable DSW/Features/Premium/Views/PremiumStatusButton.swift =====
import SwiftUI

struct PremiumStatusButton: View {
    // MARK: - Properties

    let premiumAccess: PremiumAccess
    let onTap: () -> Void

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme

    // MARK: - Body

    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 6) {
                icon
                if case .temporaryPremium = premiumAccess.status {
                    timerText
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(backgroundView)
        }
        .buttonStyle(ScaleButtonStyle())
    }

    // MARK: - Subviews

    @ViewBuilder
    private var icon: some View {
        if premiumAccess.isPremium {
            Image(systemName: "crown.fill")
                .font(.system(size: 16, weight: .semibold))
                .themedForeground(.header, colorScheme: colorScheme)
        } else {
            Image(systemName: "lock.fill")
                .font(.system(size: 16))
                .themedForeground(.header, colorScheme: colorScheme)
        }
    }

    @ViewBuilder
    private var timerText: some View {
        if let timeRemaining = premiumAccess.formattedTimeRemaining {
            Text(timeRemaining)
                .font(.system(size: 12, weight: .medium, design: .monospaced))
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
        }
    }

    private var backgroundView: some View {
        ZStack {
            if premiumAccess.isPremium {
                RoundedRectangle(cornerRadius: 12)
                    .fill(.ultraThinMaterial)

                RoundedRectangle(cornerRadius: 12)
                    .fill(
                        LinearGradient(
                            colors: gradientColors.map { $0.opacity(0.15) },
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )

                RoundedRectangle(cornerRadius: 12)
                    .strokeBorder(
                        LinearGradient(
                            colors: gradientColors.map { $0.opacity(0.3) },
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            } else {
                RoundedRectangle(cornerRadius: 12)
                    .fill(AppColor.secondaryBackground.color(for: colorScheme).opacity(0.3))
            }
        }
    }

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }
}

// ===== FILE: Timetable DSW/Features/Premium/Views/PremiumStatusScreen.swift =====
import SwiftUI

struct PremiumStatusScreen: View {
    // MARK: - Configuration

    struct Configuration: ComponentConfiguration {
        struct Constants {
            let iconSize: CGFloat = 70
            let spacing: AppSpacing = .xl
            let padding: AppSpacing = .xxl
            let timerFont: Font = .system(size: 48, weight: .bold, design: .rounded)
            let buttonPadding: EdgeInsets = .init(
                top: AppSpacing.medium.value,
                leading: AppSpacing.xxxl.value,
                bottom: AppSpacing.medium.value,
                trailing: AppSpacing.xxxl.value
            )
        }

        static let constants = Constants()
    }

    // MARK: - Properties

    let premiumAccess: PremiumAccess
    let onWatchAd: () -> Void
    let onPurchase: () -> Void

    @State private var timeRemaining: String = ""
    @State private var timer: Timer?

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @Environment(\.dismiss) var dismiss

    // MARK: - Body

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: Configuration.constants.spacing.value) {
                    iconView
                    statusContent

                    Spacer()

                    if !premiumAccess.isPremium {
                        actionButtons
                    }

                    Spacer()
                }
                .padding(Configuration.constants.padding.value)
            }
            .onAppear {
                startTimer()
            }
            .onDisappear {
                stopTimer()
            }
        }
    }

    // MARK: - Subviews

    private var iconView: some View {
        ZStack {
            // Glow effect
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(0.2) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: Configuration.constants.iconSize * 1.5, height: Configuration.constants.iconSize * 1.5)
                .blur(radius: 40)

            // Icon
            if premiumAccess.isPremium {
                Image(systemName: "crown.fill")
                    .font(.system(size: Configuration.constants.iconSize))
                    .foregroundStyle(
                        LinearGradient(
                            colors: gradientColors,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .shadow(
                        color: gradientColors.first?.opacity(0.5) ?? .clear,
                        radius: 20,
                        x: 0,
                        y: 10
                    )
            } else {
                Image(systemName: "lock.fill")
                    .font(.system(size: Configuration.constants.iconSize))
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            }
        }
    }

    @ViewBuilder
    private var statusContent: some View {
        if premiumAccess.isPremium {
            premiumContent
        } else {
            nonPremiumContent
        }
    }

    private var premiumContent: some View {
        VStack(spacing: AppSpacing.large.value) {
            Text(LocalizedString.premiumActive.localized)
                .font(AppTypography.title.font)
                .fontWeight(.bold)
                .themedForeground(.primary, colorScheme: colorScheme)

            switch premiumAccess.status {
            case .premium:
                permanentPremiumView
            case .temporaryPremium:
                temporaryPremiumView
            case .free:
                EmptyView()
            }
        }
    }

    private var permanentPremiumView: some View {
        VStack(spacing: AppSpacing.medium.value) {
            Text(LocalizedString.premiumThankYou.localized)
                .font(AppTypography.body.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .multilineTextAlignment(.center)

            Text(LocalizedString.premiumEnjoyFeatures.localized)
                .font(AppTypography.headline.font)
                .fontWeight(.semibold)
                .themedForeground(.header, colorScheme: colorScheme)
                .multilineTextAlignment(.center)
                .padding(.top, AppSpacing.small.value)

            // Features list
            VStack(alignment: .leading, spacing: AppSpacing.small.value) {
                ForEach(PremiumFeature.allCases, id: \.self) { feature in
                    featureRow(feature)
                }
            }
            .padding(.top, AppSpacing.large.value)
        }
    }

    private var temporaryPremiumView: some View {
        VStack(spacing: AppSpacing.large.value) {
            Text(LocalizedString.premiumTimeRemaining.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)

            Text(timeRemaining)
                .font(Configuration.constants.timerFont)
                .fontWeight(.bold)
                .themedForeground(.primary, colorScheme: colorScheme)
                .monospacedDigit()

            Text(LocalizedString.premiumWatchOrPurchase.localized)
                .font(AppTypography.body.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .multilineTextAlignment(.center)
                .padding(.top, AppSpacing.medium.value)
        }
    }

    private var nonPremiumContent: some View {
        VStack(spacing: AppSpacing.large.value) {
            Text(LocalizedString.premiumUnlockTitle.localized)
                .font(AppTypography.title.font)
                .fontWeight(.bold)
                .themedForeground(.primary, colorScheme: colorScheme)

            Text(LocalizedString.premiumGetAccess.localized)
                .font(AppTypography.body.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .multilineTextAlignment(.center)

            // Features list
            VStack(alignment: .leading, spacing: AppSpacing.medium.value) {
                ForEach(PremiumFeature.allCases, id: \.self) { feature in
                    featureRow(feature)
                }
            }
            .padding(.top, AppSpacing.large.value)
        }
    }

    private func featureRow(_ feature: PremiumFeature) -> some View {
        HStack(spacing: AppSpacing.medium.value) {
            Image(systemName: feature.icon)
                .font(.system(size: 24))
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 40)

            VStack(alignment: .leading, spacing: 4) {
                Text(feature.displayName)
                    .font(AppTypography.subheadline.font)
                    .fontWeight(.semibold)
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                Text(feature.description)
                    .font(AppTypography.caption.font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            }

            Spacer()
        }
    }

    private var actionButtons: some View {
        VStack(spacing: AppSpacing.medium.value) {
            // Watch ad button
            Button(action: {
//                dismiss()
                onWatchAd()
            }) {
                HStack {
                    Image(systemName: "play.rectangle.fill")
                    Text(LocalizedString.premiumWatchAdButton.localized)
                        .fontWeight(.semibold)
                }
                .font(AppTypography.body.font)
                .foregroundAppColor(.white, colorScheme: colorScheme)
                .padding(Configuration.constants.buttonPadding)
                .frame(maxWidth: .infinity)
                .background {
                    primaryButtonBackground
                }
            }
            .buttonStyle(ScaleButtonStyle())

            // Purchase button
//            Button(action: {
////                dismiss()
//                onPurchase()
//            }) {
//                HStack {
//                    Image(systemName: "cart.fill")
//                    Text(LocalizedString.premiumPurchaseButton.localized)
//                        .fontWeight(.semibold)
//                }
//                .font(AppTypography.body.font)
//                .foregroundStyle(
//                    LinearGradient(
//                        colors: gradientColors,
//                        startPoint: .leading,
//                        endPoint: .trailing
//                    )
//                )
//                .padding(Configuration.constants.buttonPadding)
//                .frame(maxWidth: .infinity)
//                .background {
//                    RoundedRectangle(cornerRadius: AppCornerRadius.xl.value)
//                        .strokeBorder(
//                            LinearGradient(
//                                colors: gradientColors,
//                                startPoint: .leading,
//                                endPoint: .trailing
//                            ),
//                            lineWidth: 2
//                        )
//                }
//            }
//            .buttonStyle(ScaleButtonStyle())
        }
    }

    private var primaryButtonBackground: some View {
        ZStack {
            RoundedRectangle(cornerRadius: AppCornerRadius.xl.value)
                .fill(.ultraThinMaterial)

            RoundedRectangle(cornerRadius: AppCornerRadius.xl.value)
                .fill(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .opacity(0.9)

            RoundedRectangle(cornerRadius: AppCornerRadius.xl.value)
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(0.3),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .topLeading,
                        startRadius: 5,
                        endRadius: 100
                    )
                )
        }
    }

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }

    // MARK: - Timer

    private func startTimer() {
        updateTimeRemaining()

        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            updateTimeRemaining()
        }
    }

    private func stopTimer() {
        timer?.invalidate()
        timer = nil
    }

    private func updateTimeRemaining() {
        guard case .temporaryPremium(let expiresAt) = premiumAccess.status else {
            timeRemaining = ""
            return
        }

        let remaining = expiresAt.timeIntervalSince(Date())
        guard remaining > 0 else {
            timeRemaining = "00:00:00"
            stopTimer()
            return
        }

        let hours = Int(remaining) / AppStateConfiguration.secondsInHour
        let minutes = (Int(remaining) % AppStateConfiguration.secondsInHour) / 60
        let seconds = Int(remaining) % 60

        timeRemaining = String(format: "%02d:%02d:%02d", hours, minutes, seconds)
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Utilities/SimultaneousDragGesture.swift =====
import SwiftUI

// MARK: - Simultaneous Drag Gesture (iOS 18 fix)

struct SimultaneousDragGesture: UIGestureRecognizerRepresentable {
    // MARK: - Properties
    
    let onChanged: (DragValue) -> Void
    let onEnded: (DragValue) -> Void
    
    // MARK: - Drag Value
    
    struct DragValue {
        let translation: CGSize
        let location: CGPoint
    }
    
    // MARK: - UIGestureRecognizerRepresentable
    
    func makeUIGestureRecognizer(context: Context) -> UIPanGestureRecognizer {
        let recognizer = UIPanGestureRecognizer()
        recognizer.delegate = context.coordinator
        return recognizer
    }
    
    func handleUIGestureRecognizerAction(_ recognizer: UIPanGestureRecognizer, context: Context) {
        let translation = recognizer.translation(in: recognizer.view)
        let location = recognizer.location(in: recognizer.view)
        
        let value = DragValue(
            translation: CGSize(width: translation.x, height: translation.y),
            location: location
        )
        
        switch recognizer.state {
        case .began, .changed:
            onChanged(value)
        case .ended, .cancelled:
            onEnded(value)
        default:
            break
        }
    }
    
    func updateUIGestureRecognizer(_ recognizer: UIPanGestureRecognizer, context: Context) {
        // No updates needed
    }
    
    func makeCoordinator(converter: CoordinateSpaceConverter) -> Coordinator {
        Coordinator()
    }
    
    // MARK: - Coordinator
    
    class Coordinator: NSObject, UIGestureRecognizerDelegate {
        func gestureRecognizer(
            _ gestureRecognizer: UIGestureRecognizer,
            shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer
        ) -> Bool {
            return true
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/ViewModels/ScheduleViewModel.swift =====
import Combine
import Foundation

@MainActor
final class ScheduleViewModel: ObservableObject {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            // Константы если понадобятся
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Published Properties
    
    @Published var navigation = WeekNavigationController()
    @Published var selectedTeacherId: Int?
    
    // MARK: - Properties

    private var cancellables = Set<AnyCancellable>()
    weak var appViewModel: AppViewModel?
    let interstitialCooldown = InterstitialCooldownManager(configuration: .weekSwitch)

    // MARK: - Computed Properties
    
    var selectedTeacher: Teacher? {
        guard let teacherId = selectedTeacherId,
              let scheduleData = appViewModel?.scheduleData else {
            return nil
        }
        return scheduleData.teachers.first { $0.id == teacherId }
    }
    
    // MARK: - Initialization
    
    init() {
        setupNavigationObserver()
    }
    
    private func setupNavigationObserver() {
        navigation.objectWillChange
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Teacher Selection

    func showTeacherDetail(teacherId: Int) {
        selectedTeacherId = teacherId
    }

    // MARK: - Week Navigation with Ads

    func handleWeekChange(coordinator: AdCoordinator?) async {
        interstitialCooldown.recordAction()

        guard interstitialCooldown.shouldShowAd() else { return }

        do {
            try await coordinator?.loadAd(type: .interstitial)
            try await coordinator?.showAd(type: .interstitial)
            interstitialCooldown.recordAdShown()
        } catch {
            print("[ScheduleViewModel] Failed to show interstitial: \(error)")
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/ViewModels/WeekNavigationController.swift =====
import Foundation
import Combine
import SwiftUI

@MainActor
final class WeekNavigationController: ObservableObject {
    // MARK: - Configuration
    struct Configuration {
        struct Constants {}
        static let constants = Constants()
    }

    // MARK: - Published
    @Published var selectedDate: Date
    @Published var weekStart: Date
    @Published var showingDatePicker = false

    // MARK: - Deps
    private let dateService: DateService
    private let calendar: Calendar

    // MARK: - Computed
    var daysInWeek: [Date] {
        dateService.daysInWeek(startingFrom: weekStart)
    }

    // MARK: - Init
    init(
        initialDate: Date = Date(),
        dateService: DateService = DefaultDateService.shared,
        calendar: Calendar = .current
    ) {
        self.dateService = dateService
        self.calendar = calendar
        let normalized = calendar.startOfDay(for: initialDate)
        self.selectedDate = normalized
        self.weekStart = dateService.startOfWeek(for: normalized)
    }

    // MARK: - Date Selection
    private var selectionApplyCount = 0

    func selectDate(_ date: Date) {
        let normalized = calendar.startOfDay(for: date)
        // печать — по желанию:
        // print("selectDate applied: \(normalized)")
        guard !calendar.isDate(selectedDate, inSameDayAs: normalized) else { return }

        var txn = Transaction(); txn.disablesAnimations = true          // 👈 без анимаций
        withTransaction(txn) { selectedDate = normalized }
        updateWeekStartIfNeeded(for: normalized)
    }

    private func updateWeekStartIfNeeded(for date: Date) {
        let newWeekStart = dateService.startOfWeek(for: date)
        guard !calendar.isDate(weekStart, equalTo: newWeekStart, toGranularity: .weekOfYear) else { return }
        weekStart = newWeekStart
    }

    // MARK: - Week Navigation (Slider / TabView)
    func nextWeekFromSlider()    { moveWeek(by: 1, selectFirst: true) }
    func previousWeekFromSlider(){ moveWeek(by: -1, selectFirst: true) }
    func nextWeekFromTabView()   { moveWeek(by: 1, selectFirst: true) }
    func previousWeekFromTabView(){ moveWeek(by: -1, selectFirst: false) }

    // MARK: - Private
    private func moveWeek(by value: Int, selectFirst: Bool) {
        guard let newWeekStart = calendar.date(byAdding: .weekOfYear, value: value, to: weekStart) else { return }
        weekStart = newWeekStart

        if selectFirst {
            selectDate(newWeekStart)
        } else {
            let last = calendar.date(byAdding: .day, value: 6, to: newWeekStart) ?? newWeekStart
            selectDate(last)
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/DatePickerSheet.swift =====
import SwiftUI
import UIKit

struct DatePickerSheet: View {
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .small
            let dayHeight: CGFloat = AppDimensions.buttonHeight.value
            let dayEmptyHeight: CGFloat = AppDimensions.buttonHeight.value
            let headerHeight: CGFloat = 28
            let monthNavPadding: AppSpacing = .large
            let gridPadding: AppSpacing = .large
            let weekdayToGridSpacing: AppSpacing = .medium
            let dotSize: CGFloat = AppDimensions.dotMedium.value
            let circleSize: CGFloat = AppDimensions.dotLarge.value
            let legendSpacing: CGFloat = 24
            let legendItemSpacing: AppSpacing = .xs
            let legendPadding: AppSpacing = .small
            let circleStrokeWidth: CGFloat = AppDimensions.lineSmall.value
            let gridTopPadding: AppSpacing = .xs
            let springResponse: Double = 0.3
            let springDamping: Double = 0.7

            // Для бейджа "только онлайн"
            let onlineBadgeHeight: CGFloat = 10
            let onlineBadgeMinWidth: CGFloat = 20
            let onlineBadgeHorizontalPadding: CGFloat = 6
        }
        static let constants = Constants()
    }

    // MARK: - Input
    @Binding var selectedDate: Date
    var onDateSelected: ((Date) -> Void)?
    let eventTypeForDate: (Date) -> EventDayType

    // MARK: - Environment
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme

    // MARK: - State
    @State private var currentMonth: Date = Date()
    @State private var measuredHeight: CGFloat = 520
    @State private var preferredDetent: CGFloat = 520

    // MARK: - Deps
    private let calendar: Calendar
    private let hapticService: HapticFeedbackService
    private let dateService: DateService

    // MARK: - Layout
    private let columns = Array(repeating: GridItem(.flexible(minimum: 0, maximum: .infinity)), count: 7)

    init(
        selectedDate: Binding<Date>,
        onDateSelected: ((Date) -> Void)? = nil,
        eventTypeForDate: @escaping (Date) -> EventDayType,
        calendar: Calendar = .current,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService(),
        dateService: DateService = DefaultDateService.shared
    ) {
        self._selectedDate = selectedDate
        self.onDateSelected = onDateSelected
        self.eventTypeForDate = eventTypeForDate
        self.calendar = calendar
        self.hapticService = hapticService
        self.dateService = dateService
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                monthNavigationHeader
                    .padding(.bottom, Configuration.constants.spacing.value)

                weekdayHeaders
                    .padding(.bottom, Configuration.constants.weekdayToGridSpacing.value)

                calendarGrid

                legend
                    .padding(.top, Configuration.constants.spacing.value)
            }
            .background(
                GeometryReader { geo in
                    Color.clear
                        .onAppear { updateDetent(with: geo.size.height) }
                        .onChange(of: geo.size.height) { updateDetent(with: $0) }
                }
            )
            .navigationTitle(LocalizedString.scheduleSelectDate.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) { todayButton }
                ToolbarItem(placement: .confirmationAction) { doneButton }
            }
        }
        // Важно: выставляем detent здесь, чтобы он динамически подстраивался.
//        .presentationDetents([.height(preferredDetent), .large])
        .presentationDetents([.medium])
//        .presentationDragIndicator(.visible)
    }

    // MARK: - Header
    private var monthNavigationHeader: some View {
        HStack(spacing: AppSpacing.xl.value) {
            Button(action: previousMonth) {
                AppIcon.chevronLeftCircleFill.image()
                    .font(AppTypography.title2.font)
                    .themedForeground(.header, colorScheme: colorScheme)
            }
            Spacer()
            Text(monthYearString(currentMonth))
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
            Spacer()
            Button(action: nextMonth) {
                AppIcon.chevronRightCircleFill.image()
                    .font(AppTypography.title2.font)
                    .themedForeground(.header, colorScheme: colorScheme)
            }
        }
        .padding(.horizontal, Configuration.constants.monthNavPadding.value)
    }

    private var weekdayHeaders: some View {
        LazyVGrid(columns: columns, spacing: 0) {
            ForEach(weekdaySymbols, id: \.self) { weekday in
                Text(weekday)
                    .font(AppTypography.caption.font)
                    .fontWeight(.semibold)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .frame(height: Configuration.constants.headerHeight)
                    .frame(maxWidth: .infinity)
            }
        }
        .padding(.horizontal, Configuration.constants.gridPadding.value)
    }

    // MARK: - Grid
    private var calendarGrid: some View {
        // Скролл остаётся как fallback, но при нормальном размере не потребуется
        ScrollView(showsIndicators: false) {
            LazyVGrid(columns: columns, spacing: Configuration.constants.spacing.value) {
                ForEach(Array(daysInMonth.enumerated()), id: \.offset) { _, maybeDate in
                    if let date = maybeDate {
                        DayCell(
                            date: date,
                            isSelected: calendar.isDate(date, inSameDayAs: selectedDate),
                            isToday: calendar.isDateInToday(date),
                            eventType: eventTypeForDate(date),
                            isCurrentMonth: calendar.isDate(date, equalTo: currentMonth, toGranularity: .month)
                        ) {
                            selectDate(date)
                        }
                    } else {
                        AppColor.clear.color(for: colorScheme)
                            .frame(height: Configuration.constants.dayEmptyHeight)
                            .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal, Configuration.constants.gridPadding.value)
            .padding(.top, Configuration.constants.gridTopPadding.value)
        }
    }

    // MARK: - Legend
    private var legend: some View {
        HStack(spacing: Configuration.constants.legendSpacing) {
            legendItem(text: LocalizedString.scheduleHasClasses.localized, kind: .regular)    // точка
            legendItem(text: LocalizedString.scheduleOnlineOnly.localized, kind: .onlineOnly) // зелёный бейдж
            legendItem(text: LocalizedString.generalToday.localized, kind: .today)            // обводка
        }
        .padding(.horizontal, Configuration.constants.gridPadding.value)
        .padding(.bottom, Configuration.constants.legendPadding.value)
    }

    private enum LegendKind { case regular, onlineOnly, today }

    private func legendItem(text: String, kind: LegendKind) -> some View {
        HStack(spacing: Configuration.constants.legendItemSpacing.value) {
            switch kind {
            case .regular:
                Circle()
                    .fill(LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing))
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)

            case .onlineOnly:
                Circle()
                    .fill(LinearGradient(colors: onlineGradient, startPoint: .topLeading, endPoint: .bottomTrailing))
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)
            case .today:
                Circle()
                    .strokeBorder(LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing),
                                  lineWidth: Configuration.constants.circleStrokeWidth)
                    .frame(width: Configuration.constants.circleSize, height: Configuration.constants.circleSize)
            }

            Text(text)
                .font(AppTypography.caption.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    // MARK: - Toolbar
    private var todayButton: some View {
        Button(action: { selectDate(Date()) }) {
            Text(LocalizedString.generalToday.localized).fontWeight(.medium)
        }
        .themedForeground(.header, colorScheme: colorScheme)
    }

    private var doneButton: some View {
        Button(LocalizedString.generalDone.localized) { dismiss() }
            .fontWeight(.medium)
            .themedForeground(.header, colorScheme: colorScheme)
    }

    // MARK: - Helpers
    private var gradientColors: [Color] {
        GradientStyle.header.colors(for: colorScheme)
    }

    private var onlineGradient: [Color] {
        GradientStyle.online.colors(for: colorScheme)
    }

    private var weekdaySymbols: [String] {
        let formatter = DateFormatter()
        formatter.locale = .current
        let symbols = formatter.shortWeekdaySymbols ?? []
        var result = symbols
        if calendar.firstWeekday == 2 { result = Array(symbols[1...]) + [symbols[0]] }
        return result.map { String($0.prefix(3)).uppercased() }
    }

    private var daysInMonth: [Date?] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: currentMonth) else { return [] }

        let days = CalendarHelper.generateDates(
            in: calendar,
            inside: monthInterval,
            matching: DateComponents(hour: 0, minute: 0, second: 0)
        )

        var offset = calendar.component(.weekday, from: monthInterval.start) - calendar.firstWeekday
        if offset < 0 { offset += 7 }

        var result: [Date?] = Array(repeating: nil, count: offset)
        result.append(contentsOf: days.map { $0 as Date? })
        return result
    }

    private func monthYearString(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy LLLL"
        formatter.locale = .current
        return formatter.string(from: date)
    }

    private func previousMonth() {
        guard let newMonth = calendar.date(byAdding: .month, value: -1, to: currentMonth) else { return }
        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
            currentMonth = newMonth
        }
    }

    private func nextMonth() {
        guard let newMonth = calendar.date(byAdding: .month, value: 1, to: currentMonth) else { return }
        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
            currentMonth = newMonth
        }
    }

    private func selectDate(_ date: Date) {
        hapticService.impact(style: .light)
        onDateSelected?(date)
        if !calendar.isDate(date, equalTo: currentMonth, toGranularity: .month) {
            withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
                currentMonth = date
            }
        }
    }

    // MARK: - Dynamic detent
    private func updateDetent(with contentHeight: CGFloat) {
        measuredHeight = contentHeight

        // Нормируем: оставим небольшой отступ и ограничим долей экрана
        let screenH = UIScreen.main.bounds.height
        let maxAllowed = screenH * 0.88  // чтобы не упираться в низ/верх
        let minAllowed: CGFloat = 360

        let clamped = min(max(contentHeight + 8, minAllowed), maxAllowed)
        if abs(clamped - preferredDetent) > 0.5 {
            preferredDetent = clamped
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/DayCell.swift =====
import SwiftUI

struct DayCell: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let height: CGFloat = AppDimensions.buttonHeight.value
            let cornerRadius: AppCornerRadius = .medium
            let borderWidth: CGFloat = AppDimensions.lineSmall.value
            let dotSize: CGFloat = AppDimensions.dotSmall.value
            let spacing: AppSpacing = .xxs
            let tapThreshold: CGFloat = 10
            let backgroundOpacity: Double = 0.5
            let inactiveBackgroundOpacity: Double = 0.2
            let selectedOpacity: Double = 0.9
            let selectedScale: Double = 1.05
            let shadowRadius: CGFloat = 6
            let shadowY: CGFloat = 3
            let shadowOpacity: Double = 0.4
            let glowOpacity: Double = 0.3
            let glowStartRadius: CGFloat = 5
            let glowEndRadius: CGFloat = 30
            let inactiveTextOpacity: Double = 0.3
            let dotOpacity: Double = 0.9
        }
        static let constants = Constants()
    }

    // MARK: - Props
    let date: Date
    let isSelected: Bool
    let isToday: Bool
    let eventType: EventDayType
    let isCurrentMonth: Bool
    let action: () -> Void

    @Environment(\.colorScheme) private var colorScheme
    private let hapticService: HapticFeedbackService

    @State private var dragStart: CGPoint?

    init(
        date: Date,
        isSelected: Bool,
        isToday: Bool,
        eventType: EventDayType,
        isCurrentMonth: Bool,
        action: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.date = date
        self.isSelected = isSelected
        self.isToday = isToday
        self.eventType = eventType
        self.isCurrentMonth = isCurrentMonth
        self.action = action
        self.hapticService = hapticService
    }

    var body: some View {
        contentView
            .contentShape(Rectangle())
            .disabled(!isCurrentMonth)
            .simultaneousGesture(
                DragGesture(minimumDistance: 0)
                    .onChanged(handleDragChanged)
                    .onEnded(handleDragEnded)
            )
    }

    private var contentView: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            dayNumberText
            indicator
        }
        .frame(maxWidth: .infinity)
        .frame(height: Configuration.constants.height)
        .background { backgroundView }
        .overlay(borderOverlay)
        // Убираем масштабирование, чтобы сетка не «гуляла» и не налезала
        .scaleEffect(isSelected ? Configuration.constants.selectedScale : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }

    // MARK: - Subviews

    private var dayNumberText: some View {
        Text("\(Calendar.current.component(.day, from: date))")
            .font(AppTypography.body.font)
            .fontWeight(isSelected ? .bold : .medium)
            .foregroundColor(textColor)
            .animation(nil, value: isSelected)
    }

    private var indicator: some View {
        Group {
            switch eventType {
            case .regular, .onlineOnly:
                Circle()
                    .fill(dotColor)
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)
            case .none:
                AppColor.clear.color(for: colorScheme)
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)
            }
        }
        .animation(nil, value: isSelected)
    }

    private var backgroundView: some View {
        Group {
            if isSelected { selectedBackground } else { unselectedBackground }
        }
    }

    private var selectedBackground: some View {
        ZStack {
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(.ultraThinMaterial)
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing))
                .opacity(Configuration.constants.selectedOpacity)
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(Configuration.constants.glowOpacity),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .topLeading,
                        startRadius: Configuration.constants.glowStartRadius,
                        endRadius: Configuration.constants.glowEndRadius
                    )
                )
        }
        .shadow(color: gradientColors[0].opacity(Configuration.constants.shadowOpacity),
                radius: Configuration.constants.shadowRadius, x: 0, y: Configuration.constants.shadowY)
    }

    private var unselectedBackground: some View {
        RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
            .fill(
                AppColor.background.color(for: colorScheme).opacity(
                    isCurrentMonth ? Configuration.constants.backgroundOpacity : Configuration.constants.inactiveBackgroundOpacity
                )
            )
    }

    private var borderOverlay: some View {
        RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
            .strokeBorder(
                isToday && !isSelected
                ? LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing)
                : LinearGradient(colors: [AppColor.clear.color(for: colorScheme)], startPoint: .topLeading, endPoint: .bottomTrailing),
                lineWidth: Configuration.constants.borderWidth
            )
    }

    // MARK: - Colors/Computed

    private var textColor: Color {
        if !isCurrentMonth {
            return AppColor.secondaryText.color(for: colorScheme).opacity(Configuration.constants.inactiveTextOpacity)
        }
        return isSelected ? AppColor.white.color(for: colorScheme) : AppColor.primaryText.color(for: colorScheme)
    }

    private var dotColor: Color {
        if isSelected {
            return AppColor.white.color(for: colorScheme).opacity(Configuration.constants.dotOpacity)
        }
        return gradientColors[0]
    }

    private var gradientColors: [Color] {
        switch eventType {
        case .none, .regular:
            GradientStyle.primary.colors(for: colorScheme)
        case .onlineOnly:
            GradientStyle.online.colors(for: colorScheme)
        }
    }

    // MARK: - Gesture

    private func handleDragChanged(_ value: DragGesture.Value) {
        if dragStart == nil { dragStart = value.startLocation }
    }

    private func handleDragEnded(_ value: DragGesture.Value) {
        defer { dragStart = nil }
        guard let start = dragStart else { return }
        let distance = hypot(value.location.x - start.x, value.location.y - start.y)
        if distance < Configuration.constants.tapThreshold {
            hapticService.impact(style: .light)
            action()
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/DayChip.swift =====
import SwiftUI

struct DayChip: View {
    // MARK: - Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let cornerRadius: AppCornerRadius = .medium
            let dotSize: CGFloat = AppDimensions.dotSmall.value
            let spacing: AppSpacing = .xs

            let compactWeekdaySize: CGFloat = 11
            let compactDaySize: CGFloat = 17
            let regularWeekdaySize: CGFloat = 11
            let regularDaySize: CGFloat = 20

            let selectedScale: Double = 1.05
            let shadowRadius: CGFloat = 4
            let shadowY: CGFloat = 2
            let chipCompactHeight: CGFloat = AppDimensions.chipCompactHeight.value
            let chipBackgroundOpacity: Double = 0.5
            let blurOpacity: Double = 0.3
            let gradientOpacity: Double = 0.9
            let dotOpacity: Double = 0.9
            let glowOpacity: Double = 0.3
            let glowStartRadius: CGFloat = 5
            let glowWidthMultiplier: CGFloat = 0.8
            let outerPaddingTop: CGFloat = AppSpacing.small.value
            let outerPaddingHorizontal: CGFloat = 1
            let outerPaddingBottom: CGFloat = AppSpacing.small.value
            let minimumScaleFactor: CGFloat = 0.8
        }
        
        static let constants = Constants()
    }

    // MARK: - Properties
    
    let date: Date
    let isSelected: Bool
    let eventDayType: EventDayType
    let action: () -> Void
    let size: CGSize

    // MARK: - Environment
    @Environment(\.colorScheme) private var colorScheme

    // MARK: - Dependencies
    private let hapticService: HapticFeedbackService
    private let dateService: DateService

    // MARK: - Inits
    init(
        date: Date,
        isSelected: Bool,
        eventDayType: EventDayType,
        action: @escaping () -> Void,
        size: CGSize,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService(),
        dateService: DateService = DefaultDateService.shared
    ) {
        self.date = date
        self.isSelected = isSelected
        self.eventDayType = eventDayType
        self.action = action
        self.size = size
        self.hapticService = hapticService
        self.dateService = dateService
    }
    
    // MARK: - Body
    var body: some View {
        return Button(action: handleTap) {
            contentView
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(isSelected ? Configuration.constants.selectedScale : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
        .accessibilityLabel(accessibilityText)
        .accessibilityAddTraits(isSelected ? [.isSelected] : [])
    }

    // MARK: - Subviews
    private var contentView: some View {
        let isCompact = size.height <= Configuration.constants.chipCompactHeight
        let isToday = Calendar.current.isDateInToday(date)

        return RoundedShadowContainer(
            corners: .allCorners,
            cornerRadius: Configuration.constants.cornerRadius.value,
            fill: chipFillColor,
            blurMaterial: isSelected ? .ultraThinMaterial : nil,
            blurOpacity: isSelected ? Configuration.constants.blurOpacity : 0,
            shadow: chipShadow,
            contentInsets: .init(),
            outerPadding: .init(
                top: Configuration.constants.outerPaddingTop,
                leading: Configuration.constants.outerPaddingHorizontal,
                bottom: Configuration.constants.outerPaddingBottom,
                trailing: Configuration.constants.outerPaddingHorizontal
            )
        ) {
            chipContent(isCompact: isCompact)
                .overlay(
                    RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value, style: .continuous)
                        .strokeBorder(
                            LinearGradient(colors: chipGradientColors,
                                           startPoint: .topLeading,
                                           endPoint: .bottomTrailing),
                            lineWidth: 2
                        )
                        .opacity(isToday ? 1 : 0)
                )
        }
    }

    private func chipContent(isCompact: Bool) -> some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            weekdayText(isCompact: isCompact)
            dayNumberText(isCompact: isCompact)
            indicator // ← точка / капсула / пусто
        }
        .frame(width: size.width, height: size.height)
        .background {
            if isSelected { selectedBackground }
        }
    }

    private func weekdayText(isCompact: Bool) -> some View {
        let fontSize = isCompact ? Configuration.constants.compactWeekdaySize : Configuration.constants.regularWeekdaySize

        return Text(dateService.weekdayShort(date))
            .font(AppTypography.custom(size: fontSize, weight: .medium).font)
            .lineLimit(1)
            .minimumScaleFactor(Configuration.constants.minimumScaleFactor)
            .foregroundAppColor(isSelected ? .white : .secondaryText, colorScheme: colorScheme)
    }

    private func dayNumberText(isCompact: Bool) -> some View {
        let fontSize = isCompact ? Configuration.constants.compactDaySize : Configuration.constants.regularDaySize

        return Text(dateService.dayNumber(date))
            .font(AppTypography.custom(size: fontSize, weight: .bold).font)
            .lineLimit(1)
            .minimumScaleFactor(Configuration.constants.minimumScaleFactor)
            .foregroundAppColor(isSelected ? .white : .primaryText, colorScheme: colorScheme)
    }

    private var indicator: some View {
        Group {
            switch eventDayType {
            case .regular, .onlineOnly:
                Circle()
                    .fill(isSelected
                          ? AppColor.white.color(for: colorScheme).opacity(Configuration.constants.dotOpacity)
                          : chipGradientColors[0])
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)
            case .none:
                AppColor.clear.color(for: colorScheme)
                    .frame(width: Configuration.constants.dotSize, height: Configuration.constants.dotSize)
            }
        }
        .animation(nil, value: isSelected)
    }

    private var selectedBackground: some View {
        ZStack {
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(
                    LinearGradient(
                        colors: chipGradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            RoundedRectangle(cornerRadius: Configuration.constants.cornerRadius.value)
                .fill(
                    RadialGradient(
                        colors: [
                            AppColor.white.color(for: colorScheme).opacity(Configuration.constants.glowOpacity),
                            AppColor.clear.color(for: colorScheme)
                        ],
                        center: .topLeading,
                        startRadius: Configuration.constants.glowStartRadius,
                        endRadius: size.width * Configuration.constants.glowWidthMultiplier
                    )
                )
        }
    }

    // MARK: - Computed
    private var chipGradientColors: [Color] {
        switch eventDayType {
        case .onlineOnly:
            GradientStyle.online.colors(for: colorScheme)
        case .regular, .none:
            GradientStyle.primary.colors(for: colorScheme)
        }
    }

    private var chipFillColor: Color {
        isSelected
        ? (colorScheme == .dark
           ? AppColor.custom(Color.purple, opacity: 0.2).color(for: colorScheme)
           : AppColor.custom(Color.pink, opacity: 0.15).color(for: colorScheme))
        : AppColor.background.color(for: colorScheme).opacity(Configuration.constants.chipBackgroundOpacity)
    }

    private var chipShadow: ShadowStyle {
        isSelected
        ? ShadowStyle(
            color: shadowColor,
            radius: Configuration.constants.shadowRadius,
            x: 0,
            y: Configuration.constants.shadowY
        )
        : ShadowStyle(color: .clear, radius: 0, x: 0, y: 0)
    }

    private var shadowColor: Color {
        let baseColor = chipGradientColors[0]
        let opacity = colorScheme == .dark ? 0.5 : 0.4
        return baseColor.opacity(opacity)
    }

    private var accessibilityText: String {
        let base = "\(dateService.weekdayShort(date)) \(dateService.dayNumber(date))"
        switch eventDayType {
        case .none: return base
        case .regular: return base + ", " + LocalizedString.scheduleHasClasses.localized
        case .onlineOnly: return base + ", " + LocalizedString.scheduleOnlineOnly.localized
        }
    }

    // MARK: - Actions
    private func handleTap() {
        hapticService.impact(style: .light)
        action()
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/DayEventsView.swift =====
import SwiftUI
import Combine

/// Экран списка событий за выбранный день.
/// Оптимизация:
/// - Полный отказ от `Calendar.autoupdatingCurrent` в рантайме рендера (дорогие DST-переходы).
/// - Предвычисление дневного диапазона в `init` (start/end) и повторное использование.
/// - Единичная фильтрация/сортировка за рендер, без повторных проходов и аллокаций.
/// - Таймер тикает только для «сегодня».
struct DayEventsView: View {

    // MARK: - Configuration

    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .medium
            let padding: AppSpacing = .large
        }
        static let constants = Constants()
    }

    // MARK: - Input

    let date: Date
    let events: [ScheduleEvent]
    let showTeacherName: Bool
    let onTeacherTap: ((Int) -> Void)?

    /// Вертикальные отступы скролла (под хедер/табы/нижнюю панель)
    let topScrollInset: CGFloat
    let bottomScrollInset: CGFloat

    // MARK: - State

    @State private var now: Date = Date()
    @State private var subjectSheet: Subject? = nil

    // MARK: - Dependencies

    private let dateService: DateService

    // MARK: - Calendar & Day Interval (предвычислено)

    /// Фиксированный календарь (без автоподстановки) — убираем лишние проверки DST при каждом доступе.
    private static let calendar: Calendar = {
        var cal = Calendar(identifier: .gregorian)
        cal.locale = Locale.current
        cal.timeZone = TimeZone.current
        return cal
    }()

    /// Начало дня (локальной даты)
    private let dayStart: Date
    /// Начало следующего дня
    private let nextDayStart: Date
    /// Флаг «сегодня»
    private let isToday: Bool

    // MARK: - Init

    init(
        date: Date,
        events: [ScheduleEvent],
        showTeacherName: Bool,
        onTeacherTap: ((Int) -> Void)?,
        topScrollInset: CGFloat,
        bottomScrollInset: CGFloat,
        dateService: DateService = DefaultDateService.shared
    ) {
        self.date = date
        self.events = events
        self.showTeacherName = showTeacherName
        self.onTeacherTap = onTeacherTap
        self.topScrollInset = topScrollInset
        self.bottomScrollInset = bottomScrollInset
        self.dateService = dateService

        // Предвычисляем границы дня ровно один раз.
        let cal = Self.calendar
        let start = cal.startOfDay(for: date)
        self.dayStart = start
        self.nextDayStart = cal.date(byAdding: .day, value: 1, to: start)!
        self.isToday = cal.isDateInToday(date)
    }

    // MARK: - Body

    var body: some View {
        // Фиксируем вычисления на фазу рендера.
        let todaysEvents = filteredAndSortedEvents(dayStart: dayStart, nextDayStart: nextDayStart)

        ScrollView {
            if todaysEvents.isEmpty {
                emptyCentered
            } else {
                eventsList(todaysEvents)
            }
        }
        .scrollContentBackground(.hidden)
        .contentShape(Rectangle())
        .contentMargins(.top, topScrollInset, for: .scrollContent)
        .contentMargins(.bottom, bottomScrollInset, for: .scrollContent)
        .ignoresSafeArea(.container, edges: .top)
        .background(AppColor.background.color(for: .light))
        .id(scrollIdentity(hasEvents: !todaysEvents.isEmpty)) // сбрасывает положение только при смене дня/пустоты
        .onReceive(minuteTickerIfToday) { tick in
            now = tick
        }
    }

    // MARK: - Views

    private func eventsList(_ todaysEvents: [ScheduleEvent]) -> some View {
        // Индекс по заголовку строим один раз и только когда он нужен.
        let titleIndex = Dictionary(grouping: events, by: { $0.title })

        return LazyVStack(spacing: Configuration.constants.spacing.value) {
            ForEach(todaysEvents) { event in
                EventCard(
                    event: event,
                    showTeacherName: showTeacherName,
                    onTeacherTap: {
                        if let id = event.teacherId { onTeacherTap?(id) }
                    },
                    onCardTap: {
                        let related = titleIndex[event.title] ?? []
                        subjectSheet = Subject(name: event.title, schedule: related)
                    },
                    now: now
                )
            }
        }
        .padding(Configuration.constants.padding.value)
        .sheet(item: $subjectSheet) { subject in
            SubjectDetailView(subject: subject)
        }
    }

    private var emptyCentered: some View {
        // Центрируем с учётом insets и избегаем полу-пикселей
        let delta = (topScrollInset - bottomScrollInset)
        let scale = UIScreen.main.scale
        let snappedDelta = (delta * scale).rounded() / scale

        return VStack {
            Spacer(minLength: 0)
            EmptyDayView(date: date, dateService: dateService)
                .padding(Configuration.constants.padding.value)
            Spacer(minLength: 0)
        }
        .frame(maxWidth: .infinity)
        .frame(maxHeight: .infinity, alignment: .center)
        .offset(y: snappedDelta)
    }

    // MARK: - Data processing

    /// Отфильтровать по [dayStart, nextDayStart) и отсортировать по startDate.
    /// Все границы переданы параметрами, чтобы исключить повторный доступ к Calendar.
    private func filteredAndSortedEvents(dayStart: Date, nextDayStart: Date) -> [ScheduleEvent] {
        // Один проход + сортировка.
        var result = [ScheduleEvent]()
        result.reserveCapacity(events.count)

        for e in events {
            if let d = e.startDate, d >= dayStart, d < nextDayStart {
                result.append(e)
            }
        }

        result.sort { (a, b) in
            guard let d1 = a.startDate, let d2 = b.startDate else { return false }
            return d1 < d2
        }
        return result
    }

    // MARK: - Helpers

    /// Ключ для сброса позиции скролла зависит только от календарного дня и факта пустоты/наличия событий.
    private func scrollIdentity(hasEvents: Bool) -> String {
        let key = Int(dayStart.timeIntervalSince1970)
        return (hasEvents ? "events-" : "empty-") + String(key)
    }

    /// Таймер тикает раз в минуту только для текущего дня (не создаём никаких паблишеров для прошлых/будущих дат).
    private var minuteTickerIfToday: AnyPublisher<Date, Never> {
        guard isToday else {
            return Empty<Date, Never>(completeImmediately: false).eraseToAnyPublisher()
        }
        return Timer.publish(every: 60, on: .main, in: .common)
            .autoconnect()
            .eraseToAnyPublisher()
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/DayScheduleTabView.swift =====
import SwiftUI

struct DayScheduleTabView: View {
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let minimumDistance: CGFloat = 0
            let arrowThreshold: CGFloat = 50
            let weekChangeThreshold: CGFloat = AppDimensions.weekChangeThreshold.value
            let verticalToHorizontalRatio: CGFloat = 1.5
            let minimumHorizontalMovement: CGFloat = 20
            let arrowSize: CGFloat = 64
            let arrowBlurSize: CGFloat = 80
            let arrowPadding: AppSpacing = .xxxl
            let arrowIconSize: CGFloat = 32
            let arrowShadowRadius: CGFloat = 20
            let arrowShadowY: CGFloat = 8
            let arrowShadowOpacity: Double = 0.5
            let arrowGlowOpacity: Double = 0.4
            let arrowGlowStartRadius: CGFloat = 5
            let arrowGlowRadiusMultiplier: CGFloat = 0.6
            let baseScale: CGFloat = 0.7
            let scaleMultiplier: CGFloat = 0.3
            let hideSpringResponse: Double = 0.25
            let hideSpringDamping: Double = 0.8
        }
        static let constants = Constants()
    }

    // MARK: - Input
    let events: [ScheduleEvent]
    let daysInWeek: [Date]
    let selectedDate: Date                     // read-only
    let onSelectDate: (Date) -> Void           // единая точка записи
    let showTeacherName: Bool
    let topInset: CGFloat
    let bottomInset: CGFloat
    let onTeacherTap: ((Int) -> Void)?
    let onNextWeekFromTabView: () -> Void
    let onPreviousWeekFromTabView: () -> Void

    // MARK: - State
    @State private var dragTranslation: CGFloat = 0
    @State private var nextWeekArrowProgress: CGFloat = 0
    @State private var prevWeekArrowProgress: CGFloat = 0
    @State private var hasTriggeredLightHapticNext = false
    @State private var hasTriggeredLightHapticPrev = false
    @State private var applyingSelection = false // анти-реэнтрант

    // MARK: - Env & Deps
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.calendar) private var calendar
    private let hapticService: HapticFeedbackService

    init(
        events: [ScheduleEvent],
        daysInWeek: [Date],
        selectedDate: Date,
        onSelectDate: @escaping (Date) -> Void,
        showTeacherName: Bool,
        topInset: CGFloat,
        bottomInset: CGFloat,
        onTeacherTap: ((Int) -> Void)?,
        onNextWeekFromTabView: @escaping () -> Void,
        onPreviousWeekFromTabView: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.events = events
        self.daysInWeek = daysInWeek
        self.selectedDate = selectedDate
        self.onSelectDate = onSelectDate
        self.showTeacherName = showTeacherName
        self.topInset = topInset
        self.bottomInset = bottomInset
        self.onTeacherTap = onTeacherTap
        self.onNextWeekFromTabView = onNextWeekFromTabView
        self.onPreviousWeekFromTabView = onPreviousWeekFromTabView
        self.hapticService = hapticService
    }

    private var selectedDayIndex: Int {
        daysInWeek.firstIndex { calendar.isDate($0, inSameDayAs: selectedDate) } ?? 0
    }

    private var weekIdentifier: String {
        let base = daysInWeek.first ?? selectedDate
        let comps = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: base)
        return "\(comps.yearForWeekOfYear ?? 0)-\(comps.weekOfYear ?? 0)"
    }

    var body: some View {
        ZStack {
            tabView
            arrowOverlays
        }
        #if DEBUG
        .measurePerformance(name: "DayScheduleTabView", category: .viewAppear)
        #endif
    }

    private var tabView: some View {
        TabView(selection: createSelectionBinding()) {
            ForEach(Array(daysInWeek.enumerated()), id: \.element) { index, date in
                // Убрали ненужный GeometryReader — снижает стоимость layout
                DayEventsView(
                    date: date,
                    events: events,
                    showTeacherName: showTeacherName,
                    onTeacherTap: onTeacherTap,
                    topScrollInset: topInset,
                    bottomScrollInset: bottomInset
                )
                .tag(index)
                .gesture(
                    SimultaneousDragGesture(
                        onChanged: { value in
                            handleDragChanged(translation: value.translation, index: index)
                        },
                        onEnded: { value in
                            handleDragEnded(translation: value.translation, index: index)
                        }
                    )
                )
            }
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .transaction { $0.animation = nil } // без implicit-анимаций при программной синхронизации
        .id(weekIdentifier)
    }

    private var arrowOverlays: some View {
        Group {
            if nextWeekArrowProgress > 0 {
                arrowView(isNext: true)
                    .opacity(nextWeekArrowProgress)
                    .scaleEffect(Configuration.constants.baseScale + nextWeekArrowProgress * Configuration.constants.scaleMultiplier)
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.8).combined(with: .opacity),
                        removal: .scale(scale: 0.8).combined(with: .opacity)
                    ))
            }
            if prevWeekArrowProgress > 0 {
                arrowView(isNext: false)
                    .opacity(prevWeekArrowProgress)
                    .scaleEffect(Configuration.constants.baseScale + prevWeekArrowProgress * Configuration.constants.scaleMultiplier)
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.8).combined(with: .opacity),
                        removal: .scale(scale: 0.8).combined(with: .opacity)
                    ))
            }
        }
        .allowsHitTesting(false)
    }

    private func arrowView(isNext: Bool) -> some View {
        HStack {
            if !isNext {
                arrowContent(icon: .chevronLeft)
                    .padding(.leading, Configuration.constants.arrowPadding.value)
                Spacer()
            } else {
                Spacer()
                arrowContent(icon: .chevronRight)
                    .padding(.trailing, Configuration.constants.arrowPadding.value)
            }
        }
    }

    private func arrowContent(icon: AppIcon) -> some View {
        VStack {
            Spacer()
            ZStack {
                Circle()
                    .fill(.ultraThinMaterial)
                    .frame(width: Configuration.constants.arrowBlurSize, height: Configuration.constants.arrowBlurSize)
                Circle()
                    .fill(LinearGradient(colors: gradientColors, startPoint: .topLeading, endPoint: .bottomTrailing))
                    .frame(width: Configuration.constants.arrowBlurSize, height: Configuration.constants.arrowBlurSize)
                    .opacity(0.9)
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [AppColor.white.color(for: colorScheme).opacity(Configuration.constants.arrowGlowOpacity),
                                     AppColor.clear.color(for: colorScheme)],
                            center: .topLeading,
                            startRadius: Configuration.constants.arrowGlowStartRadius,
                            endRadius: Configuration.constants.arrowBlurSize * Configuration.constants.arrowGlowRadiusMultiplier
                        )
                    )
                    .frame(width: Configuration.constants.arrowBlurSize, height: Configuration.constants.arrowBlurSize)
                icon.image()
                    .font(AppTypography.custom(size: Configuration.constants.arrowIconSize, weight: .bold).font)
                    .foregroundAppColor(.white, colorScheme: colorScheme)
            }
            .shadow(color: gradientColors[0].opacity(Configuration.constants.arrowShadowOpacity),
                    radius: Configuration.constants.arrowShadowRadius, x: 0, y: Configuration.constants.arrowShadowY)
            Spacer()
        }
    }

    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }

    // MARK: - Selection binding with reentrancy guard
    private func createSelectionBinding() -> Binding<Int> {
        Binding(
            get: { selectedDayIndex },
            set: { newIndex in
                #if DEBUG
                let startTime = CFAbsoluteTimeGetCurrent()
                #endif

                guard !applyingSelection else { return }
                guard daysInWeek.indices.contains(newIndex) else { return }

                let newDate = daysInWeek[newIndex]
                guard !calendar.isDate(selectedDate, inSameDayAs: newDate) else { return }

                applyingSelection = true
                DispatchQueue.main.async { applyingSelection = false }

                var txn = Transaction(); txn.disablesAnimations = true
                withTransaction(txn) {
                    onSelectDate(newDate)
                }

                #if DEBUG
                let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000
                print("[TabView] ⏱ Tab selection took: \(String(format: "%.2f", elapsed))ms")
                #endif
            }
        )
    }

    // MARK: - Gesture / arrows
    private func isHorizontalSwipe(_ t: CGSize) -> Bool {
        let ax = abs(t.width), ay = abs(t.height)
        guard ax > Configuration.constants.minimumHorizontalMovement else { return false }
        return ay < ax * Configuration.constants.verticalToHorizontalRatio
    }

    private func handleDragChanged(translation: CGSize, index: Int) {
        #if DEBUG
        let startTime = CFAbsoluteTimeGetCurrent()
        #endif

        guard isHorizontalSwipe(translation) else {
            hideArrowsIfNeeded()
            return
        }

        dragTranslation = translation.width

        let isFirst = index == 0
        let isLast  = index == daysInWeek.count - 1

        if isLast && dragTranslation < 0 {
            let p = min(abs(dragTranslation) / Configuration.constants.weekChangeThreshold, 1.0)
            updateArrowProgress(&nextWeekArrowProgress, to: p)
            if p >= 0.5 && !hasTriggeredLightHapticNext {
                triggerLightHaptic()
                hasTriggeredLightHapticNext = true
            }
        } else {
            updateArrowProgress(&nextWeekArrowProgress, to: 0)
            hasTriggeredLightHapticNext = false
        }

        if isFirst && dragTranslation > 0 {
            let p = min(dragTranslation / Configuration.constants.weekChangeThreshold, 1.0)
            updateArrowProgress(&prevWeekArrowProgress, to: p)
            if p >= 0.5 && !hasTriggeredLightHapticPrev {
                triggerLightHaptic()
                hasTriggeredLightHapticPrev = true
            }
        } else {
            updateArrowProgress(&prevWeekArrowProgress, to: 0)
            hasTriggeredLightHapticPrev = false
        }

        #if DEBUG
        let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000
        print("[TabView] ⏱ handleDragChanged took: \(String(format: "%.2f", elapsed))ms")
        #endif
    }

    private func handleDragEnded(translation: CGSize, index: Int) {
        #if DEBUG
        let startTime = CFAbsoluteTimeGetCurrent()
        print("[TabView] 🏁 Drag ended - Index: \(index), Translation: \(String(format: "%.1f", translation.width))px, Threshold: \(Configuration.constants.weekChangeThreshold)px")
        #endif

        guard isHorizontalSwipe(translation) else {
            resetDragState()
            return
        }

        let isFirst = index == 0
        let isLast  = index == daysInWeek.count - 1

        if isLast && translation.width < -Configuration.constants.weekChangeThreshold {
            triggerHaptic()
            onNextWeekFromTabView()
        } else if isFirst && translation.width > Configuration.constants.weekChangeThreshold {
            triggerHaptic()
            onPreviousWeekFromTabView()
        }

        resetDragState()

        #if DEBUG
        let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000
        print("[TabView] ⏱ handleDragEnded took: \(String(format: "%.2f", elapsed))ms")
        #endif
    }

    private let progressEpsilon: CGFloat = 0.02
    private func updateArrowProgress(_ p: inout CGFloat, to v: CGFloat) {
        let clamped = min(max(v, 0), 1)
        guard abs(p - clamped) > progressEpsilon else { return }
        p = clamped
    }

    private func hideArrowsIfNeeded() {
        guard nextWeekArrowProgress > 0 || prevWeekArrowProgress > 0 else { return }
        withAnimation(.easeOut(duration: 0.15)) {
            nextWeekArrowProgress = 0
            prevWeekArrowProgress = 0
        }
    }

    private func resetDragState() {
        withAnimation(.easeOut(duration: 0.15)) {
            dragTranslation = 0
            nextWeekArrowProgress = 0
            prevWeekArrowProgress = 0
            hasTriggeredLightHapticNext = false
            hasTriggeredLightHapticPrev = false
        }
    }

    private func triggerLightHaptic() { hapticService.impact(style: .light) }
    private func triggerHaptic()      { hapticService.impact(style: .medium) }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/EmptyDayView.swift =====
import SwiftUI

struct EmptyDayView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let iconSize: CGFloat = AppDimensions.iconXL.value * 2.5
            let spacing: AppSpacing = .large
            let messageSpacing: AppSpacing = .small
            let circleExtraSize: CGFloat = 40
            let backgroundOpacity: Double = 0.1
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    let date: Date
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let dateService: DateService
    
    // MARK: - Initialization
    
    init(
        date: Date,
        dateService: DateService = DefaultDateService.shared
    ) {
        self.date = date
        self.dateService = dateService
    }
    
    // MARK: - Body
    
    var body: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            illustrationView
            messageView
        }
        .frame(maxWidth: .infinity, alignment: .center)   // ← только по ширине
           .multilineTextAlignment(.center)
        .contentShape(Rectangle())
    }
    
    // MARK: - Subviews
    
    private var illustrationView: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(Configuration.constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(
                    width: Configuration.constants.iconSize + Configuration.constants.circleExtraSize,
                    height: Configuration.constants.iconSize + Configuration.constants.circleExtraSize
                )
            
            AppIcon.calendarBadgeCheckmark.image()
                .font(.system(size: Configuration.constants.iconSize))
                .themedForeground(.success, colorScheme: colorScheme)
        }
    }
    
    private var messageView: some View {
        VStack(spacing: Configuration.constants.messageSpacing.value) {
            Text(dateService.weekdayFull(date))
                .font(AppTypography.title2.font)
                .fontWeight(.bold)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
            
            Text(LocalizedString.scheduleNoClasses.localized)
                .font(AppTypography.headline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            
            Text(LocalizedString.scheduleEnjoyFreeTime.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.tertiaryText, colorScheme: colorScheme)
        }
    }
    
    // MARK: - Computed Properties
    
    private var gradientColors: [Color] {
        GradientStyle.success.colors(for: colorScheme)
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/EventCard.swift =====
import SwiftUI

// MARK: - Lightweight props for Equatable comparison

struct EventCardProps: Equatable, Identifiable {
    let id: String
    let title: String
    let type: String?
    let start: Date?
    let end: Date?
    let room: String
    let grading: String?
    let remarks: String?
    let studyTrack: String?
    let groups: String?
    let teacherId: Int?
    let teacherName: String?

    static func from(_ e: ScheduleEvent) -> EventCardProps {
        .init(
            id: e.id,
            title: e.title,
            type: e.type,
            start: e.startDate,
            end: e.endDate,
            room: e.displayRoom,
            grading: e.grading,
            remarks: e.remarks,
            studyTrack: e.studyTrack,
            groups: e.groups,
            teacherId: e.teacherId,
            teacherName: e.teacherName
        )
    }
}

// MARK: - Event Style Configuration

struct EventStyle {
    let accentColor: Color
    let gradientColors: [Color]
    let isOnline: Bool
    let isCancelled: Bool
    let eventKind: EventType

    private let eventTypeDetector: EventTypeDetector

    init(
        from event: ScheduleEvent,
        colorScheme: ColorScheme,
        eventTypeDetector: EventTypeDetector = DefaultEventTypeDetector()
    ) {
        self.eventTypeDetector = eventTypeDetector

        let kind = eventTypeDetector.detectEventType(from: event.type)
        self.eventKind = kind
        self.accentColor = Self.accentColor(for: kind)
        self.gradientColors = Self.gradientColors(for: kind, colorScheme: colorScheme)
        self.isOnline = eventTypeDetector.isOnline(remarks: event.remarks)
        self.isCancelled = eventTypeDetector.isCancelled(remarks: event.remarks)
    }

    private static func accentColor(for type: EventType) -> Color {
        switch type {
        case .lecture: return .orange
        case .exercise: return .blue
        case .laboratory: return .purple
        case .other: return .orange
        }
    }

    private static func gradientColors(for type: EventType, colorScheme: ColorScheme) -> [Color] {
        let style: GradientStyle
        switch type {
        case .lecture: style = .lecture
        case .exercise: style = .exercise
        case .laboratory: style = .laboratory
        case .other: style = .lecture
        }
        return style.colors(for: colorScheme)
    }
}

// MARK: - Event Card

struct EventCard: View {
    // MARK: - Configuration

    struct Configuration: ComponentConfiguration {
        struct Constants {
            let cornerRadius: AppCornerRadius = .large
            let verticalLineWidth: CGFloat = AppDimensions.lineMedium.value
            let containerPadding: AppSpacing = .large
            let verticalLineSpacing: AppSpacing = .medium
            let contentSpacing: AppSpacing = .medium
            let timeLineWidth: CGFloat = AppDimensions.lineSmall.value
            let timeLineHeight: CGFloat = AppDimensions.buttonHeight.value
            let avatarSize: CGFloat = AppDimensions.avatarMedium.value
            let onlineIndicatorSize: CGFloat = AppDimensions.dotLarge.value
            let shadowRadius: CGFloat = 8
            let shadowY: CGFloat = 2
            let shadowOpacity: Double = 0.2
            let blurOpacity: Double = 0.7
            let darkFillOpacity: Double = 0.08
            let lightFillOpacity: Double = 0.16

            let pastOverlayLightOpacity: Double = 0.08
            let pastOverlayDarkOpacity: Double = 0.14
            let pastSaturation: Double = 0.80
            let pastOpacity: Double = 0.80

            let cancelledOverlayLightOpacity: Double = 0.22
            let cancelledOverlayDarkOpacity: Double = 0.28
        }

        static let constants = Constants()
    }

    // MARK: - Properties

    let event: ScheduleEvent
    let showTeacherName: Bool
    let onTeacherTap: (() -> Void)?
    let onCardTap: (() -> Void)?
    let now: Date

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme

    // MARK: - Dependencies

    private let dateService: DateService

    // MARK: - Computed Properties

    private var style: EventStyle {
        EventStyle(from: event, colorScheme: colorScheme)
    }

    private var isPast: Bool {
        guard let end = event.endDate else { return false }
        return end < now
    }

    private var props: EventCardProps {
        EventCardProps.from(event)
    }

    // MARK: - Initialization

    init(
        event: ScheduleEvent,
        showTeacherName: Bool,
        onTeacherTap: (() -> Void)? = nil,
        onCardTap: (() -> Void)? = nil,
        now: Date = Date(),
        dateService: DateService = DefaultDateService.shared
    ) {
        self.event = event
        self.showTeacherName = showTeacherName
        self.onTeacherTap = onTeacherTap
        self.onCardTap = onCardTap
        self.now = now
        self.dateService = dateService
    }

    // MARK: - Body

    var body: some View {
        RoundedShadowContainer(
            corners: .allCorners,
            cornerRadius: Configuration.constants.cornerRadius.value,
            fill: cardFillColor,
            blurMaterial: .ultraThinMaterial,
            blurOpacity: Configuration.constants.blurOpacity,
            shadow: .init(
                color: style.gradientColors[0].opacity(Configuration.constants.shadowOpacity),
                radius: Configuration.constants.shadowRadius,
                x: 0,
                y: Configuration.constants.shadowY
            ),
            contentInsets: .init(
                top: Configuration.constants.containerPadding.value,
                leading: Configuration.constants.containerPadding.value,
                bottom: Configuration.constants.containerPadding.value,
                trailing: Configuration.constants.containerPadding.value
            )
        ) {
            HStack(alignment: .top, spacing: Configuration.constants.verticalLineSpacing.value) {
                AccentLine(gradientColors: style.gradientColors)

                VStack(alignment: .leading, spacing: Configuration.constants.contentSpacing.value) {
                    MainInfoRow(
                        event: event,
                        style: style,
                        startTime: startTime,
                        endTime: endTime,
                        roomAndGrading: roomAndGrading,
                        showLargeOnlineBadge: style.isOnline,
                        showCancelledBadge: style.isCancelled
                    )

                    if hasMiddleSection {
                        PersonOrGroupSection(
                            showTeacherName: showTeacherName,
                            teacherName: event.teacherName,
                            groups: event.groups,
                            gradientColors: style.gradientColors,
                            onTeacherTap: onTeacherTap
                        )
                    }

                    if hasBottomSection {
                        AdditionalInfoSection(
                            studyTrack: event.studyTrack,
                            remarks: event.remarks
                        )
                    }
                }
            }
        }
        .modifier(StatusDimModifier(isPast: isPast, isCancelled: style.isCancelled))
        .onTapGesture { onCardTap?() }
        .equatable(by: props) // не перестраивать без изменения входных пропсов
    }

    // MARK: - Computed Properties

    private var cardFillColor: Color {
        let opacity = colorScheme == .dark ? Configuration.constants.darkFillOpacity : Configuration.constants.lightFillOpacity
        return style.gradientColors[0].opacity(opacity)
    }

    private var hasMiddleSection: Bool {
        (showTeacherName && event.teacherName != nil) ||
        (!showTeacherName && event.groups != nil)
    }

    private var hasBottomSection: Bool {
        event.studyTrack != nil || (event.remarks != nil && event.remarks != "Brak")
    }

    private var startTime: String {
        guard let start = event.startDate else { return "" }
        return dateService.formatTime(start)
    }

    private var endTime: String {
        guard let end = event.endDate else { return "" }
        return dateService.formatTime(end)
    }

    private var roomAndGrading: String {
        var result = event.displayRoom
        let separator = result.isEmpty ? "" : ", "
        if let grading = event.grading {
            result += "\(separator)\(grading)"
        }
        return result
    }
}

// MARK: - Status Dim Modifier (past & cancelled)

private struct StatusDimModifier: ViewModifier {
    @Environment(\.colorScheme) private var colorScheme
    let isPast: Bool
    let isCancelled: Bool

    func body(content: Content) -> some View {
        content
            .saturation((isPast || isCancelled) ? EventCard.Configuration.constants.pastSaturation : 1.0)
            .opacity((isPast || isCancelled) ? EventCard.Configuration.constants.pastOpacity : 1.0)
            .overlay(
                Group {
                     if isCancelled {
                        RoundedRectangle(cornerRadius: EventCard.Configuration.constants.cornerRadius.value)
                            .fill(
                                LinearGradient(
                                    colors: GradientStyle.cancelled
                                        .colors(for: colorScheme)
                                        .map { $0.opacity(colorScheme == .dark
                                                          ? EventCard.Configuration.constants.cancelledOverlayDarkOpacity
                                                          : EventCard.Configuration.constants.cancelledOverlayLightOpacity) },
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .allowsHitTesting(false)
                    } else if isPast {
                        RoundedRectangle(cornerRadius: EventCard.Configuration.constants.cornerRadius.value)
                            .fill(
                                Color.black.opacity(
                                    colorScheme == .dark
                                    ? EventCard.Configuration.constants.pastOverlayDarkOpacity
                                    : EventCard.Configuration.constants.pastOverlayLightOpacity
                                )
                            )
                            .allowsHitTesting(false)
                    }
                }
            )
    }
}

// MARK: - Accent Line

private struct AccentLine: View {
    let gradientColors: [Color]

    var body: some View {
        RoundedRectangle(cornerRadius: EventCard.Configuration.constants.verticalLineWidth / 2)
            .fill(
                LinearGradient(
                    colors: gradientColors,
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
            .frame(width: EventCard.Configuration.constants.verticalLineWidth)
            .frame(maxHeight: .infinity)
    }
}

// MARK: - Main Info Row

private struct MainInfoRow: View {
    let event: ScheduleEvent
    let style: EventStyle
    let startTime: String
    let endTime: String
    let roomAndGrading: String
    let showLargeOnlineBadge: Bool
    let showCancelledBadge: Bool

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.medium.value) {
            LeftSideInfo(
                title: event.title,
                roomAndGrading: roomAndGrading
            )

            Spacer(minLength: AppSpacing.medium.value)

            RightSideInfo(
                type: event.type,
                startTime: startTime,
                endTime: endTime,
                gradientColors: style.gradientColors,
                showLargeOnlineBadge: showLargeOnlineBadge,
                showCancelledBadge: showCancelledBadge
            )
        }
    }
}

// MARK: - Left Side Info

private struct LeftSideInfo: View {
    struct Constants {
        let titleSize: CGFloat = 18
        let roomSize: CGFloat = 14
        let spacing: AppSpacing = .xs
        let rowSpacing: AppSpacing = .small
    }
    private let constants = Constants()

    let title: String
    let roomAndGrading: String

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(alignment: .leading, spacing: constants.spacing.value) {
            Text(title)
                .font(AppTypography.custom(size: constants.titleSize, weight: .semibold).font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                .fixedSize(horizontal: false, vertical: true)

            HStack(alignment: .top, spacing: constants.rowSpacing.value) {
                Text(roomAndGrading)
                    .font(AppTypography.custom(size: constants.roomSize, weight: .regular).font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .lineLimit(2)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }
}

// MARK: - Online Indicator

private struct OnlineIndicator: View {
    struct Constants {
        let circleSize: CGFloat = 5
        let fontSize: CGFloat = 11
        let horizontalPadding: AppSpacing = .xs
        let verticalPadding: AppSpacing = .xxs
        let backgroundOpacity: Double = 0.15
    }
    private let constants = Constants()

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        HStack(spacing: AppSpacing.xxs.value) {
            Circle()
                .fill(AppColor.success.color(for: colorScheme))
                .frame(width: constants.circleSize, height: constants.circleSize)

            Text(LocalizedString.generalOnline.localized)
                .font(AppTypography.custom(size: constants.fontSize, weight: .medium).font)
                .foregroundAppColor(.success, colorScheme: colorScheme)
        }
        .padding(.horizontal, constants.horizontalPadding.value)
        .padding(.vertical, constants.verticalPadding.value)
        .background(
            Capsule()
                .fill(AppColor.success.color(for: colorScheme).opacity(constants.backgroundOpacity))
        )
    }
}

// MARK: - Right Side Info

private struct RightSideInfo: View {
    struct Constants {
        let typeSize: CGFloat = 16
        let spacing: AppSpacing = .xs
        let badgeSpacing: AppSpacing = .xs
    }
    private let constants = Constants()

    let type: String?
    let startTime: String
    let endTime: String
    let gradientColors: [Color]
    let showLargeOnlineBadge: Bool
    let showCancelledBadge: Bool

    var body: some View {
        VStack(alignment: .trailing, spacing: constants.spacing.value) {
            if type != nil || showLargeOnlineBadge || showCancelledBadge {
                HStack(spacing: constants.badgeSpacing.value) {
                    if showCancelledBadge {
                        LargeBage(
                            style: .cancelled,
                            text: LocalizedString.generalCancelled.localized
                        )
                    } else if showLargeOnlineBadge {
                        LargeBage()
                    }
                    if let type = type {
                        Text(type)
                            .font(AppTypography.custom(size: constants.typeSize, weight: .semibold).font)
                            .foregroundStyle(
                                LinearGradient(colors: gradientColors, startPoint: .leading, endPoint: .trailing)
                            )
                            .lineLimit(1)
                    }
                }
            }

            TimeBlock(
                startTime: startTime,
                endTime: endTime,
                gradientColors: gradientColors
            )
        }
        .fixedSize(horizontal: true, vertical: false)
    }
}

// MARK: - Time Block

private struct TimeBlock: View {
    struct Constants {
        let timeSize: CGFloat = 16
        let spacing: AppSpacing = .small
        let verticalSpacing: AppSpacing = .xs
    }
    private let constants = Constants()

    let startTime: String
    let endTime: String
    let gradientColors: [Color]

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        HStack(spacing: constants.spacing.value) {
            VStack(alignment: .trailing, spacing: constants.verticalSpacing.value) {
                Text(startTime)
                    .font(AppTypography.custom(size: constants.timeSize, weight: .medium).font)
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                Text(endTime)
                    .font(AppTypography.custom(size: constants.timeSize, weight: .medium).font)
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)
            }

            RoundedRectangle(cornerRadius: EventCard.Configuration.constants.timeLineWidth / 2)
                .fill(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .frame(
                    width: EventCard.Configuration.constants.timeLineWidth,
                    height: EventCard.Configuration.constants.timeLineHeight
                )
        }
    }
}

// MARK: - Person Or Group Section

private struct PersonOrGroupSection: View {
    let showTeacherName: Bool
    let teacherName: String?
    let groups: String?
    let gradientColors: [Color]
    let onTeacherTap: (() -> Void)?

    var body: some View {
        if showTeacherName, let teacherName = teacherName {
            TeacherView(
                name: teacherName,
                gradientColors: gradientColors,
                onTap: onTeacherTap
            )
        } else if !showTeacherName, let groups = groups {
            GroupView(groups: groups, gradientColors: gradientColors)
        }
    }
}

// MARK: - Teacher View

private struct TeacherView: View {
    struct Constants {
        let spacing: AppSpacing = .medium
        let titleSize: CGFloat = 12
        let nameSize: CGFloat = 14
        let initialsSize: CGFloat = 14
        let nameSpacing: CGFloat = 1
        let backgroundOpacity: Double = 0.15
        let iconSpacing: AppSpacing = .xs
    }
    private let constants = Constants()

    let name: String
    let gradientColors: [Color]
    let onTap: (() -> Void)?

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        Group {
            if let _ = onTap {
                content(isInteractive: true)
            } else {
                content(isInteractive: false)
            }
        }
    }

    private func content(isInteractive: Bool) -> some View {
        HStack(spacing: constants.spacing.value) {
            if isInteractive, let onTap {
                Button(action: onTap) {
                    avatarView
                    nameContent(isInteractive: isInteractive)
                }
            } else {
                avatarView
                nameContent(isInteractive: isInteractive)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    private var avatarView: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(
                    width: EventCard.Configuration.constants.avatarSize,
                    height: EventCard.Configuration.constants.avatarSize
                )

            Text(initials)
                .font(AppTypography.custom(size: constants.initialsSize, weight: .semibold).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        }
    }

    private func nameContent(isInteractive: Bool) -> some View {
        VStack(alignment: .leading, spacing: constants.nameSpacing) {
            if let title = parsedName.title {
                HStack(spacing: constants.iconSpacing.value) {
                    Text(title)
                        .font(AppTypography.custom(size: constants.titleSize, weight: .medium).font)
                        .foregroundColor(
                            isInteractive
                                ? gradientColors[0].opacity(0.7)
                                : AppColor.secondaryText.color(for: colorScheme)
                        )

                    Text(parsedName.firstName)
                        .font(AppTypography.custom(size: constants.nameSize, weight: .medium).font)
                        .foregroundStyle(nameGradient(isInteractive: isInteractive))
                }
            } else {
                Text(parsedName.firstName)
                    .font(AppTypography.custom(size: constants.nameSize, weight: .medium).font)
                    .foregroundStyle(nameGradient(isInteractive: isInteractive))
            }

            if let lastName = parsedName.lastName {
                Text(lastName)
                    .font(AppTypography.custom(size: constants.nameSize, weight: .medium).font)
                    .foregroundStyle(nameGradient(isInteractive: isInteractive))
            }
        }
    }

    private func nameGradient(isInteractive: Bool) -> LinearGradient {
        LinearGradient(
            colors: isInteractive ? gradientColors : [AppColor.primaryText.color(for: colorScheme)],
            startPoint: .leading,
            endPoint: .trailing
        )
    }

    private var parsedName: (title: String?, firstName: String, lastName: String?) {
        let components = name.split(separator: " ").map(String.init)
        let titles = ["mgr", "dr", "prof", "inż", "hab"]

        var titleParts: [String] = []
        var nameParts: [String] = []

        for component in components {
            let lowercased = component.lowercased().replacingOccurrences(of: ".", with: "")
            if titles.contains(lowercased) {
                titleParts.append(component)
            } else {
                nameParts.append(component)
            }
        }

        let title = titleParts.isEmpty ? nil : titleParts.joined(separator: " ")
        let firstName = nameParts.first ?? name
        let lastName = nameParts.count > 1 ? nameParts[1] : nil

        return (title, firstName, lastName)
    }

    private var initials: String {
        let name = parsedName
        if let lastName = name.lastName {
            let firstInitial = name.firstName.prefix(1)
            let lastInitial = lastName.prefix(1)
            return "\(firstInitial)\(lastInitial)".uppercased()
        } else {
            return String(name.firstName.prefix(1)).uppercased()
        }
    }
}

// MARK: - Group View

private struct GroupView: View {
    struct Constants {
        let iconSize: CGFloat = 14
        let textSize: CGFloat = 14
        let spacing: AppSpacing = .medium
    }
    private let constants = Constants()

    let groups: String
    let gradientColors: [Color]

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        HStack(spacing: constants.spacing.value) {
            AppIcon.person3Fill.image()
                .font(AppTypography.custom(size: constants.iconSize, weight: .regular).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )

            Text(groups)
                .font(AppTypography.custom(size: constants.textSize, weight: .regular).font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
        }
    }
}

// MARK: - Additional Info Section

private struct AdditionalInfoSection: View {
    struct Constants {
        let textSize: CGFloat = 12
        let spacing: AppSpacing = .xxs
    }
    private let constants = Constants()

    let studyTrack: String?
    let remarks: String?

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(alignment: .leading, spacing: constants.spacing.value) {
            if let track = studyTrack {
                Text(track)
                    .font(AppTypography.custom(size: constants.textSize, weight: .regular).font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .lineLimit(2)
            }

            if let remarks = remarks, remarks != "Brak" {
                Text(remarks)
                    .font(AppTypography.custom(size: constants.textSize, weight: .regular).font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .italic()
                    .lineLimit(1)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

// MARK: - Reusable Large Badge (online / cancelled)

private struct LargeBage: View {
    struct Constants {
        let fontSize: CGFloat = 12
        let hPad: AppSpacing = .small
        let vPad: AppSpacing = .xxs
        let strokeWidth: CGFloat = AppDimensions.lineSmall.value
        let glowOpacity: Double = 0.28
        let glowRadius: CGFloat = 10
    }
    private let c = Constants()

    var style: GradientStyle = .online
    var text: String? = nil

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        ZStack {
            Capsule(style: .continuous)
                .fill(style.linearGradient(for: colorScheme))

            Capsule(style: .continuous)
                .fill(
                    RadialGradient(
                        colors: [Color.white.opacity(0.28), .clear],
                        center: .topLeading,
                        startRadius: 2,
                        endRadius: 22
                    )
                )

            Text((text ?? LocalizedString.generalOnline.localized).uppercased())
                .font(AppTypography.custom(size: c.fontSize, weight: .semibold).font)
                .foregroundColor(.white)
                .padding(.horizontal, c.hPad.value)
                .padding(.vertical, c.vPad.value)
        }
        .overlay(
            Capsule(style: .continuous)
                .stroke(Color.white.opacity(0.18), lineWidth: c.strokeWidth)
        )
        .shadow(
            color: style.colors(for: colorScheme).first?.opacity(c.glowOpacity) ?? .clear,
            radius: c.glowRadius, x: 0, y: 1
        )
        .fixedSize()
    }
}

// MARK: - Equatable helper

extension View {
    /// Оборачивает в EquatableView, сравнивая по предоставленному значению.
    func equatable<T: Equatable>(by value: T) -> some View {
        EquatableWrapper(content: self, value: value)
    }
}

private struct EquatableWrapper<Content: View, Value: Equatable>: View, Equatable {
    let content: Content
    let value: Value

    static func == (l: Self, r: Self) -> Bool { l.value == r.value }
    var body: some View { content }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/ScheduleHeaderView.swift =====
import SwiftUI

struct ScheduleHeaderView: View {
    // MARK: - Configuration

    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .medium
            let statusSpacing: AppSpacing = .medium
            let dateSpacing: AppSpacing = .xs
            let horizontalPadding: AppSpacing = .large
            let verticalPadding: AppSpacing = .small
            let progressScale: CGFloat = 0.7
        }

        static let constants = Constants()
    }

    // MARK: - Properties

    let selectedDate: Date
    let isRefreshing: Bool
    let isOffline: Bool
    let lastUpdated: Date?
    let onCalendarTap: () -> Void
    let onPremiumTap: (() -> Void)?
    let onTodayTap: (() -> Void)?

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @EnvironmentObject var appStateService: DefaultAppStateService
    @Environment(\.adCoordinator) private var coordinator

    // MARK: - Dependencies

    private let dateService: DateService

    // MARK: - Initialization

    init(
        selectedDate: Date,
        isRefreshing: Bool,
        isOffline: Bool,
        lastUpdated: Date?,
        onCalendarTap: @escaping () -> Void,
        onPremiumTap: (() -> Void)? = nil,
        onTodayTap: (() -> Void)? = nil,
        dateService: DateService = DefaultDateService.shared
    ) {
        self.selectedDate = selectedDate
        self.isRefreshing = isRefreshing
        self.isOffline = isOffline
        self.lastUpdated = lastUpdated
        self.onCalendarTap = onCalendarTap
        self.onPremiumTap = onPremiumTap
        self.onTodayTap = onTodayTap
        self.dateService = dateService
    }
    
    // MARK: - Body
    
    var body: some View {
        HStack(alignment: .center, spacing: Configuration.constants.spacing.value) {
            leftSection
            Spacer()
            rightSection
        }
        .padding(.horizontal, Configuration.constants.horizontalPadding.value)
        .padding(.vertical, Configuration.constants.verticalPadding.value)
    }
    
    // MARK: - Subviews

    private var formattedSelectedDate: String {
        let formatter = DateFormatter()
        formatter.locale = .current
        formatter.dateFormat = "dd.MM.yyyy"
        return formatter.string(from: selectedDate)
    }

    private var leftSection: some View {
        VStack(alignment: .leading, spacing: 1) {
            Text(dateService.greeting(for: Date()))
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
            
            HStack(spacing: Configuration.constants.dateSpacing.value) {
                Text(formattedSelectedDate)
                    .font(AppTypography.caption.font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                
                if let lastUpdated = lastUpdated {
                    Text("• \(lastUpdated, style: .relative)")
                        .font(AppTypography.caption2.font)
                        .foregroundAppColor(.tertiaryText, colorScheme: colorScheme)
                }
            }
        }
    }
    
    private var rightSection: some View {
        HStack(spacing: Configuration.constants.statusSpacing.value) {
            if isRefreshing {
                ProgressView()
                    .scaleEffect(Configuration.constants.progressScale)
            }

            if isOffline {
                AppIcon.wifiSlash.image()
                    .font(AppTypography.caption.font)
                    .foregroundAppColor(.warning, colorScheme: colorScheme)
            }

//            if let onPremiumTap = onPremiumTap, !(coordinator?.isAdDisabled() ?? true) {
//                PremiumStatusButton(
//                    premiumAccess: PremiumAccess.from(appState: appStateService.state),
//                    onTap: onPremiumTap
//                )
//            }

            // Return to today button (only show if not on today)
            if let onTodayTap = onTodayTap, !Calendar.current.isDateInToday(selectedDate) {
                Button(action: onTodayTap) {
                    AppIcon.arrowClockwise.image()
                        .font(AppTypography.title3.font)
                        .themedForeground(.header, colorScheme: colorScheme)
                }
            }

            Button(action: onCalendarTap) {
                AppIcon.calendar.image()
                    .font(AppTypography.title3.font)
                    .themedForeground(.header, colorScheme: colorScheme)
            }
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/ScheduleView.swift =====
import SwiftUI

struct ScheduleView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let headerSpacing: AppSpacing = .small
            let headerCornerRadius: AppCornerRadius = .xl
            let headerShadowRadius: CGFloat = 12
            let headerShadowY: CGFloat = 4
            let headerBlurOpacity: Double = 0.98
            let headerContentPadding: AppSpacing = .medium
            let detentHeightDivider: CGFloat = 1.75
            let maxDetentHeight: CGFloat = 500
            let bottomInset: CGFloat = 110
            let defaultSafeAreaTop: CGFloat = 47
            let darkFillOpacity: Double = 0.15
            let lightFillOpacity: Double = 0.12
            let darkShadowOpacity: Double = 0.3
            let lightShadowOpacity: Double = 0.25
            let springResponse: Double = 0.3
            let springDamping: Double = 0.7
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    @StateObject private var viewModel = ScheduleViewModel()
    @EnvironmentObject var appViewModel: AppViewModel
    @EnvironmentObject var appStateService: DefaultAppStateService
    @Environment(\.bottomInsetService) private var bottomInsetService
    @Environment(\.adCoordinator) private var coordinator
    @State private var headerHeight: CGFloat = 0
    @State private var headerHeightMax: CGFloat = 0
    @State private var safeAreaTop: CGFloat = Configuration.constants.defaultSafeAreaTop
    @State private var bannerHeight: CGFloat = 0
    @State private var showPremiumStatus = false

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @Environment(\.adCoordinator) private var adCoordinator

    // MARK: - Computed Properties
    
    private var headerGradientFill: Color {
        let opacity = colorScheme == .dark ? Configuration.constants.darkFillOpacity : Configuration.constants.lightFillOpacity
        return (colorScheme == .dark ? AppColor.purple : AppColor.pink).color(for: colorScheme).opacity(opacity)
    }
    
    private var headerShadowColor: Color {
        let opacity = colorScheme == .dark ? Configuration.constants.darkShadowOpacity : Configuration.constants.lightShadowOpacity
        return (colorScheme == .dark ? AppColor.purple : AppColor.pink).color(for: colorScheme).opacity(opacity)
    }
    
    private var detentHeight: CGFloat {
        let screenHeight = UIScreen.main.bounds.height
        return min(Configuration.constants.maxDetentHeight, screenHeight / Configuration.constants.detentHeightDivider)
    }
    
    // MARK: - Body
    
    var body: some View {
        NavigationView {
            ZStack {
                contentView
                    .frame(maxWidth: .infinity, maxHeight: .infinity)

                VStack(spacing: 0) {
                    floatingHeader
                    Spacer()
                }
                .zIndex(1)
            }
            .ignoresSafeArea()
            .navigationBarHidden(true)
            .navigationBarTitleDisplayMode(.inline)
            .sheet(isPresented: $viewModel.navigation.showingDatePicker) {
                datePickerSheet
            }
            .sheet(item: selectedTeacherBinding) { teacher in
                TeacherDetailView(viewModel: TeacherDetailViewModel(teacher: teacher))
            }
            .sheet(isPresented: $showPremiumStatus) {
                PremiumStatusScreen(
                    premiumAccess: PremiumAccess.from(appState: appStateService.state),
                    onWatchAd: {
                        Task {
                            do {
                                try await coordinator?.loadAd(type: .rewarded)
                                try await coordinator?.showAd(type: .rewarded)
                                appStateService.grantTemporaryPremium()
                            } catch {
                                print("[Premium] Failed to show rewarded ad: \(error)")
                            }
                        }
                    },
                    onPurchase: {
                        appStateService.grantPremium()
                    }
                )
            }
            .onAppear {
                viewModel.appViewModel = appViewModel
                if appViewModel.scheduleData == nil {
                    Task { await appViewModel.loadSchedule() }
                }

                safeAreaTop = UIApplication.shared.connectedScenes
                    .compactMap { $0 as? UIWindowScene }
                    .first?.windows.first?.safeAreaInsets.top ?? Configuration.constants.defaultSafeAreaTop
            }
            #if DEBUG
            .measurePerformance(name: "ScheduleView", category: .viewAppear)
            #endif
        }
    }
    
    // MARK: - Subviews
    
    private var floatingHeader: some View {
        RoundedShadowContainer(
            corners: [.bottomLeft, .bottomRight],
            cornerRadius: Configuration.constants.headerCornerRadius.value,
            fill: headerGradientFill,
            blurMaterial: .ultraThinMaterial,
            blurOpacity: Configuration.constants.headerBlurOpacity,
            shadow: ShadowStyle(
                color: headerShadowColor,
                radius: Configuration.constants.headerShadowRadius,
                x: 0,
                y: Configuration.constants.headerShadowY
            ),
            contentInsets: .init(
                top: 0,
                leading: Configuration.constants.headerContentPadding.value,
                bottom: Configuration.constants.headerSpacing.value,
                trailing: Configuration.constants.headerContentPadding.value
            ),
            outerPadding: .init(top: 0, leading: 0, bottom: 0, trailing: 0),
            ignoresSafeAreaEdges: .top
        ) {
            VStack(spacing: Configuration.constants.headerSpacing.value) {
                AppColor.clear.color(for: colorScheme)
                    .frame(height: safeAreaTop)
                
                ScheduleHeaderView(
                    selectedDate: viewModel.navigation.selectedDate,
                    isRefreshing: appViewModel.isRefreshing,
                    isOffline: appViewModel.isOffline,
                    lastUpdated: appViewModel.lastUpdated,
                    onCalendarTap: { viewModel.navigation.showingDatePicker = true },
                    onPremiumTap: { showPremiumStatus = true },
                    onTodayTap: { viewModel.navigation.selectDate(Date()) }
                )
                
                WeekSlider(
                    days: viewModel.navigation.daysInWeek,
                    selectedDate: viewModel.navigation.selectedDate,
                    eventDayType: { appViewModel.eventType(on: $0) },
                    onSelectDate: { viewModel.navigation.selectDate($0) },
                    onNextWeekFromSlider: {
                        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
                            viewModel.navigation.nextWeekFromSlider()
                        }
                        Task { await viewModel.handleWeekChange(coordinator: adCoordinator) }
                    },
                    onPreviousWeekFromSlider: {
                        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
                            viewModel.navigation.previousWeekFromSlider()
                        }
                        Task { await viewModel.handleWeekChange(coordinator: adCoordinator) }
                    }
                )
            }
            .overlay(
                GeometryReader { headerGeo in
                    AppColor.clear.color(for: colorScheme)
                        .preference(key: HeaderHeightKey.self, value: headerGeo.size.height + Configuration.constants.headerSpacing.value)
                }
            )
        }
        .onPreferenceChange(HeaderHeightKey.self) { value in
            guard value > 0 else { return }
            headerHeight = value
            let clamped = ceil(value)
            if clamped > headerHeightMax {
                headerHeightMax = clamped
            }
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        if appViewModel.isLoading {
            loadingView
        } else if let error = appViewModel.errorMessage, appViewModel.scheduleData == nil {
            ErrorView(message: error) {
                Task { await appViewModel.refresh() }
            }
        } else if let scheduleData = appViewModel.scheduleData {
            let topInset: CGFloat = headerHeightMax > 0 ? headerHeightMax : AppDimensions.headerMinHeight.value
            let bottomInset = bottomInsetService?.bottomInset ?? Configuration.constants.bottomInset

            DayScheduleTabView(
                events: scheduleData.groupSchedule,
                daysInWeek: viewModel.navigation.daysInWeek,
                selectedDate: viewModel.navigation.selectedDate,
                onSelectDate: { viewModel.navigation.selectDate($0) },
                showTeacherName: true,
                topInset: topInset,
                bottomInset: bottomInset,
                onTeacherTap: { viewModel.showTeacherDetail(teacherId: $0) },
                onNextWeekFromTabView: {
                    viewModel.navigation.nextWeekFromTabView()
                    Task { await viewModel.handleWeekChange(coordinator: adCoordinator) }
                },
                onPreviousWeekFromTabView: {
                    viewModel.navigation.previousWeekFromTabView()
                    Task { await viewModel.handleWeekChange(coordinator: adCoordinator) }
                }
            )
        }
    }

    private var loadingView: some View {
        VStack(spacing: AppSpacing.large.value) {
            Spacer()
            ProgressView()
            Text(LocalizedString.scheduleLoading.localized)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            Spacer()
        }
    }
    
    private var datePickerSheet: some View {
        DatePickerSheet(
            selectedDate: $viewModel.navigation.selectedDate,
            onDateSelected: { viewModel.navigation.selectDate($0) },
            eventTypeForDate: { appViewModel.eventType(on: $0) }
        )
    }

    private var selectedTeacherBinding: Binding<Teacher?> {
        Binding(
            get: { viewModel.selectedTeacher },
            set: { _ in viewModel.selectedTeacherId = nil }
        )
    }

    // MARK: - Preference Key
    
    struct HeaderHeightKey: PreferenceKey {
        static var defaultValue: CGFloat = 0
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
            value = nextValue()
        }
    }
}

// ===== FILE: Timetable DSW/Features/Schedule/Views/WeekSlider.swift =====
import SwiftUI

struct WeekSlider: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let horizontalPadding: AppSpacing = .large
            let baseSpacing: AppSpacing = .medium
            let minSpacing: AppSpacing = .xs
            let preferredMinChipWidth: CGFloat = 44
            let absoluteMinChipWidth: CGFloat = 36
            let preferredMaxChipWidth: CGFloat = 64
            let chipAspect: CGFloat = 1.35
            let maxChipHeight: CGFloat = AppDimensions.chipMaxHeight.value
            let minChipHeight: CGFloat = AppDimensions.chipMinHeight.value
            let minimumSwipeDistance: CGFloat = AppDimensions.minimumSwipeDistance.value
            let weekChangeThreshold: CGFloat = AppDimensions.weekChangeThreshold.value
            let verticalToHorizontalRatio: CGFloat = 1.5
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    let days: [Date]
    let selectedDate: Date
    let eventDayType: (Date) -> EventDayType
    let onSelectDate: (Date) -> Void
    let onNextWeekFromSlider: () -> Void
    let onPreviousWeekFromSlider: () -> Void
    
    // MARK: - State
    
    @State private var hasTriggeredNextWeekHaptic = false
    @State private var hasTriggeredPreviousWeekHaptic = false
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        days: [Date],
        selectedDate: Date,
        eventDayType: @escaping (Date) -> EventDayType,
        onSelectDate: @escaping (Date) -> Void,
        onNextWeekFromSlider: @escaping () -> Void,
        onPreviousWeekFromSlider: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.days = days
        self.selectedDate = selectedDate
        self.eventDayType = eventDayType
        self.onSelectDate = onSelectDate
        self.onNextWeekFromSlider = onNextWeekFromSlider
        self.onPreviousWeekFromSlider = onPreviousWeekFromSlider
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        GeometryReader { proxy in
            let containerWidth = proxy.size.width
            let availableWidth = max(0, containerWidth - Configuration.constants.horizontalPadding.value * 2)

            let (chipW, spacing) = adaptiveMetrics(availableWidth: availableWidth, count: days.count)
            let chipH = clampHeight(chipW * Configuration.constants.chipAspect)
            let sliderHeight = chipH

            ScrollView(.horizontal) {
                HStack(spacing: spacing) {
                    ForEach(days, id: \.self) { date in
                        DayChip(
                            date: date,
                            isSelected: Calendar.current.isDate(date, inSameDayAs: selectedDate),
                            eventDayType: eventDayType(date),
                            action: { onSelectDate(date) },
                            size: CGSize(width: chipW, height: chipH),
                            hapticService: hapticService
                        )
                    }
                }
                .frame(width: availableWidth, alignment: .center)
                .padding(.horizontal, Configuration.constants.horizontalPadding.value)
            }
            .frame(height: sliderHeight)
            .background(AppColor.clear.color(for: colorScheme))
        }
        .frame(height: idealSliderHeight)
        .contentShape(Rectangle())
        .gesture(
            SimultaneousDragGesture(
                onChanged: { value in
                    handleSwipeProgress(translation: value.translation)
                },
                onEnded: { value in
                    handleSwipeEnd(translation: value.translation)
                }
            )
        )
    }

    // MARK: - Computed Properties
    
    private var idealSliderHeight: CGFloat {
        clampHeight(Configuration.constants.preferredMaxChipWidth * Configuration.constants.chipAspect)
    }
    
    // MARK: - Helper Methods
    
    private func clampHeight(_ raw: CGFloat) -> CGFloat {
        min(max(raw, Configuration.constants.minChipHeight), Configuration.constants.maxChipHeight)
    }
    
    private func adaptiveMetrics(availableWidth: CGFloat, count: Int) -> (chipWidth: CGFloat, spacing: CGFloat) {
        guard count > 0 else {
            return (Configuration.constants.preferredMinChipWidth, Configuration.constants.baseSpacing.value)
        }
        
        if let fit = solve(width: availableWidth, chips: count, spacing: Configuration.constants.baseSpacing.value) {
            return fit
        }
        
        if let fit = solve(width: availableWidth, chips: count, spacing: Configuration.constants.minSpacing.value) {
            return fit
        }
        
        return solve(
            width: availableWidth,
            chips: count,
            spacing: Configuration.constants.minSpacing.value,
            allowBelowPreferredMin: true
        )!
    }
    
    private func solve(
        width availableWidth: CGFloat,
        chips: Int,
        spacing: CGFloat,
        allowBelowPreferredMin: Bool = false
    ) -> (chipWidth: CGFloat, spacing: CGFloat)? {
        let free = max(0, availableWidth - spacing * CGFloat(max(0, chips - 1)))
        let idealW = free / CGFloat(chips)
        
        let minW = allowBelowPreferredMin ? Configuration.constants.absoluteMinChipWidth : Configuration.constants.preferredMinChipWidth
        let clampedW = min(max(idealW, minW), Configuration.constants.preferredMaxChipWidth)
        
        let total = clampedW * CGFloat(chips) + spacing * CGFloat(max(0, chips - 1))
        if total <= availableWidth + 0.5 {
            return (clampedW, spacing)
        }
        return allowBelowPreferredMin ? (clampedW, spacing) : nil
    }
    
    private func isHorizontalSwipe(_ translation: CGSize) -> Bool {
        let absHorizontal = abs(translation.width)
        let absVertical = abs(translation.height)
        
        guard absHorizontal > Configuration.constants.minimumSwipeDistance else {
            return false
        }
        
        return absVertical < absHorizontal * Configuration.constants.verticalToHorizontalRatio
    }
    
    // MARK: - Gesture Handlers
    
    private func handleSwipeProgress(translation: CGSize) {
        guard isHorizontalSwipe(translation) else { return }
        
        if translation.width < -Configuration.constants.weekChangeThreshold && !hasTriggeredNextWeekHaptic {
            triggerHaptic()
            hasTriggeredNextWeekHaptic = true
        }
        
        if translation.width > Configuration.constants.weekChangeThreshold && !hasTriggeredPreviousWeekHaptic {
            triggerHaptic()
            hasTriggeredPreviousWeekHaptic = true
        }
        
        if abs(translation.width) < Configuration.constants.weekChangeThreshold {
            resetHapticFlags()
        }
    }
    
    private func handleSwipeEnd(translation: CGSize) {
        guard isHorizontalSwipe(translation) else { return }

        if translation.width < -Configuration.constants.weekChangeThreshold {
            onNextWeekFromSlider()
        } else if translation.width > Configuration.constants.weekChangeThreshold {
            onPreviousWeekFromSlider()
        }
        
        resetHapticFlags()
    }
    
    private func triggerHaptic() {
        hapticService.impact(style: .medium)
    }
    
    private func resetHapticFlags() {
        hasTriggeredNextWeekHaptic = false
        hasTriggeredPreviousWeekHaptic = false
    }
}

// ===== FILE: Timetable DSW/Features/Settings/ViewModels/AppInfo.swift =====
import Foundation
import UIKit

enum AppInfo {
    static var version: String {
        Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
    static var build: String {
        Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "1"
    }
    static var versionString: String { "\(version) (\(build))" }
}

enum DeviceInfo {
    static var iOSVersion: String { UIDevice.current.systemVersion }

    static var deviceIdentifier: String {
        var sysinfo = utsname()
        uname(&sysinfo)
        let mirror = Mirror(reflecting: sysinfo.machine)
        return mirror.children.reduce(into: "") { acc, element in
            guard let v = element.value as? Int8, v != 0 else { return }
            acc.append(String(UnicodeScalar(UInt8(v))))
        }
    }
}

// ===== FILE: Timetable DSW/Features/Settings/ViewModels/ContactComposer.swift =====
import Foundation

struct ContactComposer {
    enum Kind { case bug, feature }

    let appInfoProvider: () -> (version: String, build: String)
    let deviceInfoProvider: () -> (ios: String, model: String)
    let localeProvider: () -> String
    let selectedGroupProvider: () -> String?

    func subject(for kind: Kind) -> String {
        switch kind {
        case .bug:     return LocalizedString.contactEmailSubjectBug.localized
        case .feature: return LocalizedString.contactEmailSubjectFeature.localized
        }
    }

    func body(for kind: Kind, now: Date = Date()) -> String {
        // Заголовки без \n в локализациях (см. Localizable.xcstrings ниже)
        let headerLine: String
        let extraBlock: String

        switch kind {
        case .bug:
            headerLine = LocalizedString.contactEmailBodyBugHeader.localized
            // Список и подзаголовок формируем программно (надёжные переносы):
            extraBlock = [
                "", // пустая строка
                "1)",
                "2)",
                "3)",
                "",
                LocalizedString.contactEmailBodyAdditionalInfo.localized
            ].joined(separator: "\n")

        case .feature:
            headerLine = LocalizedString.contactEmailBodyFeatureHeader.localized
            extraBlock = [
                "", // пустая строка
                LocalizedString.contactEmailBodyDetailsTitle.localized
            ].joined(separator: "\n")
        }

        // Санитайзер: если в каталогах остались строки с «\n», заменим их на реальные переводы.
        let header = headerLine.unescapedNewlines()

        let app = appInfoProvider()
        let dev = deviceInfoProvider()
        let locale = localeProvider()
        let group = selectedGroupProvider() ?? "—"
        let iso = ISO8601DateFormatter().string(from: now)

        let infoLines = [
            "---",
            "\(LocalizedString.contactEmailInfoApp.localized): \(app.version) (\(app.build))",
            "\(LocalizedString.contactEmailInfoiOS.localized): \(dev.ios)",
            "\(LocalizedString.contactEmailInfoDevice.localized): \(dev.model)",
            "\(LocalizedString.contactEmailInfoLocale.localized): \(locale)",
            "\(LocalizedString.contactEmailInfoGroup.localized): \(group)",
            "\(LocalizedString.contactEmailInfoDate.localized): \(iso)"
        ]

        return ([header, extraBlock] + infoLines).joined(separator: "\n")
    }
}

private extension String {
    /// Превращает последовательности `\\n` в реальные переводы строк.
    func unescapedNewlines() -> String {
        replacingOccurrences(of: "\\n", with: "\n")
    }
}

// ===== FILE: Timetable DSW/Features/Settings/ViewModels/GroupSelectionViewModel.swift =====
import Combine
import Foundation

@MainActor
final class GroupSelectionViewModel: ObservableObject {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            // Константы если понадобятся
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Published Properties
    
    @Published var searchText = ""
    @Published var isRefreshing = false
    @Published var allGroups: [GroupInfo] = []
    
    // MARK: - Properties
    
    weak var appViewModel: AppViewModel?
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Computed Properties
    
    var filteredGroups: [GroupInfo] {
        guard !searchText.isEmpty else {
            return allGroups
        }
        
        return allGroups.filter { group in
            matchesSearchText(group)
        }
    }
    
    private func matchesSearchText(_ group: GroupInfo) -> Bool {
        group.displayName.localizedCaseInsensitiveContains(searchText) ||
        group.faculty.localizedCaseInsensitiveContains(searchText) ||
        group.program.localizedCaseInsensitiveContains(searchText) ||
        group.id.description.localizedCaseInsensitiveContains(searchText)
    }
    
    var isLoading: Bool {
        appViewModel?.isLoadingGroups ?? false
    }
    
    // MARK: - Public Methods
    
    func setupWithAppViewModel(_ appViewModel: AppViewModel) {
        self.appViewModel = appViewModel
        
        appViewModel.$groups
            .assign(to: &$allGroups)
        
        Task {
            await appViewModel.loadGroupsIfNeeded()
        }
    }
    
    func refresh() async {
        isRefreshing = true
        defer { isRefreshing = false }
        
        await appViewModel?.loadGroups()
    }
}

// ===== FILE: Timetable DSW/Features/Settings/ViewModels/MailComposeResult.swift =====
import SwiftUI
import MessageUI

enum MailComposeResult {
    case sent, saved, cancelled, failed(Error?)
}

struct MailComposerView: UIViewControllerRepresentable {
    typealias UIViewControllerType = MFMailComposeViewController

    let recipients: [String]
    let subject: String
    let body: String
    let onFinish: (MailComposeResult) -> Void

    static var canSendMail: Bool {
        MFMailComposeViewController.canSendMail()
    }

    func makeUIViewController(context: Context) -> MFMailComposeViewController {
        let vc = MFMailComposeViewController()
        vc.setToRecipients(recipients)
        vc.setSubject(subject)
        vc.setMessageBody(body, isHTML: false)
        vc.mailComposeDelegate = context.coordinator
        return vc
    }

    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(onFinish: onFinish)
    }

    final class Coordinator: NSObject, MFMailComposeViewControllerDelegate {
        let onFinish: (MailComposeResult) -> Void
        init(onFinish: @escaping (MailComposeResult) -> Void) {
            self.onFinish = onFinish
        }

        func mailComposeController(_ controller: MFMailComposeViewController,
                                   didFinishWith result: MFMailComposeResult,
                                   error: Error?) {
            controller.dismiss(animated: true) {
                let mapped: MailComposeResult
                switch result {
                case .cancelled: mapped = .cancelled
                case .saved:     mapped = .saved
                case .sent:      mapped = .sent
                case .failed:    mapped = .failed(error)
                @unknown default: mapped = .failed(error)
                }
                self.onFinish(mapped)
            }
        }
    }
}

// ===== FILE: Timetable DSW/Features/Settings/ViewModels/SettingsViewModel.swift =====
import Combine
import Foundation

@MainActor
final class SettingsViewModel: ObservableObject {
    // MARK: - Configuration

    struct Configuration {
        struct Constants {
            // Убрали константу neverText
        }

        static let constants = Constants()
    }

    // MARK: - Published Properties

    @Published var showingClearCacheAlert = false
    @Published var showingGroupSelection = false

    // MARK: - Properties

    weak var appViewModel: AppViewModel?

    // MARK: - Computed Properties

    var lastUpdatedText: String {
        guard let date = appViewModel?.lastUpdated else {
            return LocalizedString.settingsNever.localized // ← ИСПРАВЛЕНО
        }

        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .full
        return formatter.localizedString(for: date, relativeTo: Date())
    }

    // MARK: - Public Methods

    func selectGroup(_ group: GroupInfo) {
        appViewModel?.groupId = group.groupId
        showingGroupSelection = false

        Task {
            await appViewModel?.clearCache()
            await appViewModel?.loadSchedule()
        }
    }

    func clearCache() async {
        await appViewModel?.clearCache()
    }
}

// ===== FILE: Timetable DSW/Features/Settings/Views/GroupRow.swift =====
import SwiftUI

struct GroupRow: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let iconSize: CGFloat = AppDimensions.buttonHeight.value
            let spacing: AppSpacing = .medium
            let padding: AppSpacing = .medium
            let iconCornerRadius: AppCornerRadius = .medium
            let iconImageSize: CGFloat = AppDimensions.iconMedium.value
            let nameSize: CGFloat = 16
            let programSize: CGFloat = 13
            let facultySize: CGFloat = 12
            let chevronSize: CGFloat = 14
            let backgroundOpacity: Double = 0.15
            let nameSpacing: AppSpacing = .xxs
            let chevronOpacity: Double = 0.5
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    let group: GroupInfo
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Body
    
    var body: some View {
        HStack(spacing: Configuration.constants.spacing.value) {
            iconView
            textContent
            Spacer()
            chevronIcon
        }
        .padding(Configuration.constants.padding.value)
    }
    
    // MARK: - Subviews
    
    private var iconView: some View {
        ZStack {
            RoundedRectangle(cornerRadius: Configuration.constants.iconCornerRadius.value)
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(Configuration.constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: Configuration.constants.iconSize, height: Configuration.constants.iconSize)
            
            AppIcon.person3Fill.image()
                .font(.system(size: Configuration.constants.iconImageSize))
                .themedForeground(.secondary, colorScheme: colorScheme)
        }
    }
    
    private var textContent: some View {
        VStack(alignment: .leading, spacing: Configuration.constants.nameSpacing.value) {
            Text(group.displayName)
                .font(AppTypography.custom(size: Configuration.constants.nameSize, weight: .semibold).font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
            
            Text(group.program)
                .font(AppTypography.custom(size: Configuration.constants.programSize, weight: .regular).font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .lineLimit(1)
            
            Text(group.faculty)
                .font(AppTypography.custom(size: Configuration.constants.facultySize, weight: .regular).font)
                .foregroundAppColor(.tertiaryText, colorScheme: colorScheme)
                .lineLimit(1)
        }
    }
    
    private var chevronIcon: some View {
        AppIcon.chevronRight.image()
            .font(AppTypography.custom(size: Configuration.constants.chevronSize, weight: .semibold).font)
            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
            .opacity(Configuration.constants.chevronOpacity)
    }
    
    // MARK: - Computed Properties
    
    private var gradientColors: [Color] {
        GradientStyle.secondary.colors(for: colorScheme)
    }
}

// ===== FILE: Timetable DSW/Features/Settings/Views/GroupSelectionView.swift =====
import SwiftUI

struct GroupSelectionView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .large
            let progressScale: CGFloat = 1.2
            let listRowInsets = EdgeInsets(
                top: AppSpacing.xs.value,
                leading: AppSpacing.large.value,
                bottom: AppSpacing.xs.value,
                trailing: AppSpacing.large.value
            )
            let progressScaleRefresh: CGFloat = 0.8
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    @StateObject var viewModel: GroupSelectionViewModel
    let onSelectGroup: (GroupInfo) -> Void
    
    // MARK: - Environment
    
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        viewModel: GroupSelectionViewModel,
        onSelectGroup: @escaping (GroupInfo) -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self._viewModel = StateObject(wrappedValue: viewModel)
        self.onSelectGroup = onSelectGroup
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        NavigationView {
            contentView
                .navigationTitle(LocalizedString.groupsSelect.localized)
                .navigationBarTitleDisplayMode(.inline)
                .searchable(text: $viewModel.searchText, prompt: LocalizedString.groupsSearch.localized)
                .toolbar {
                    ToolbarItem(placement: .navigationBarLeading) {
                        cancelButton
                    }
                    
                    ToolbarItem(placement: .navigationBarTrailing) {
                        refreshButton
                    }
                }
        }
    }
    
    // MARK: - Content Views
    
    @ViewBuilder
    private var contentView: some View {
        if viewModel.isLoading && viewModel.allGroups.isEmpty {
            loadingView
        } else if viewModel.allGroups.isEmpty {
            emptyStateView
        } else if viewModel.filteredGroups.isEmpty {
            noResultsView
        } else {
            groupsList
        }
    }
    
    private var loadingView: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            ProgressView()
                .scaleEffect(Configuration.constants.progressScale)
            Text(LocalizedString.groupsLoading.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }
    
    private var emptyStateView: some View {
        ContentUnavailableView(
            LocalizedString.groupsNoAvailable.localized,
            systemImage: AppIcon.listBullet.systemName,
            description: Text(LocalizedString.groupsPullToRefresh.localized)
        )
    }
    
    private var noResultsView: some View {
        ContentUnavailableView(
            LocalizedString.groupsNoFound.localized,
            systemImage: AppIcon.magnifyingGlass.systemName,
            description: Text(LocalizedString.groupsAdjustSearch.localized)
        )
    }
    
    private var groupsList: some View {
        List(viewModel.filteredGroups) { group in
            Button(action: {
                selectGroup(group)
            }) {
                GroupRow(group: group)
            }
            .listRowInsets(Configuration.constants.listRowInsets)
        }
        .listStyle(.plain)
        .refreshable {
            await viewModel.refresh()
        }
    }
    
    // MARK: - Toolbar Buttons
    
    private var cancelButton: some View {
        Button(LocalizedString.generalCancel.localized) { dismiss() }
            .themedForeground(.header, colorScheme: colorScheme)
    }
    
    private var refreshButton: some View {
        Button(action: {
            Task { await viewModel.refresh() }
        }) {
            if viewModel.isRefreshing {
                ProgressView()
                    .scaleEffect(Configuration.constants.progressScaleRefresh)
            } else {
                AppIcon.arrowClockwise.image()
                    .themedForeground(.header, colorScheme: colorScheme)
            }
        }
        .disabled(viewModel.isRefreshing)
    }
    
    // MARK: - Actions
    
    private func selectGroup(_ group: GroupInfo) {
        hapticService.impact(style: .light)
        onSelectGroup(group)
        dismiss()
    }
}

// ===== FILE: Timetable DSW/Features/Settings/Views/SettingsView.swift =====
import SwiftUI
import Combine
import Foundation

struct SettingsView: View {
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .medium
            let iconSize: CGFloat = AppDimensions.avatarSmall.value
            let iconCornerRadius: AppCornerRadius = .small
            let iconImageSize: CGFloat = 14
            let backgroundOpacity: Double = 0.15
            let captionSpacing: AppSpacing = .xxs

            let supportEmail: String = "dev.mikita.laptsionak@gmail.com"
        }
        static let constants = Constants()
    }

    @StateObject private var viewModel = SettingsViewModel()
    @EnvironmentObject var appViewModel: AppViewModel
    @EnvironmentObject var featureFlagService: DefaultFeatureFlagService
    @EnvironmentObject var themeManager: ThemeManager
    @Environment(\.adCoordinator) private var coordinator
    @Environment(\.bottomInsetService) private var bottomInsetService
    @EnvironmentObject var appStateService: DefaultAppStateService

    @State private var showingContactDialog = false
    @State private var showingMailComposer = false
    @State private var showingMailUnavailableAlert = false
    @State private var pendingMailSubject = ""
    @State private var pendingMailBody = ""
    @State private var showConfetti = false
    @State private var timeRemaining = ""
    @State private var timer: Timer?

    // Модальные состояния
    @State private var showThemeSheet = false
    @State private var showWidgetSheet = false

    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        NavigationView {
            Form {
                groupSection
                themeRow
                widgetRow
                cacheSection
                if !(coordinator?.isAdDisabled() ?? true) {
                    awardSection
                }
                contactSection
                aboutSection
                debugSection
            }
            .navigationTitle(LocalizedString.settingsTitle.localized)
            .onAppear { viewModel.appViewModel = appViewModel }
            .safeAreaInset(edge: .bottom) {
                AppColor.clear.color(for: colorScheme)
                    .frame(height: bottomInsetService?.bottomInset ?? 78)
            }
            #if DEBUG
            .measurePerformance(name: "SettingsView", category: .viewAppear)
            #endif
        }
        .sheet(isPresented: $viewModel.showingGroupSelection) { groupSelectionSheet }
        // Модалка: Тема
        .sheet(isPresented: $showThemeSheet) {
            ThemeSettingsContainer()
        }
        // Модалка: Виджеты
        .sheet(isPresented: $showWidgetSheet) {
            WidgetSettingsContainer()
        }
        .sheet(isPresented: $showingMailComposer) {
            MailComposerView(
                recipients: [Configuration.constants.supportEmail],
                subject: pendingMailSubject,
                body: pendingMailBody
            ) { _ in showingMailComposer = false }
        }
        .alert(LocalizedString.mailUnavailableTitle.localized, isPresented: $showingMailUnavailableAlert) {
            Button(LocalizedString.mailCopyAddress.localized) {
                UIPasteboard.general.string = Configuration.constants.supportEmail
            }
            Button(LocalizedString.generalCancel.localized, role: .cancel) {}
        } message: {
            Text(String(format: LocalizedString.mailUnavailableMessage.localized,
                        Configuration.constants.supportEmail))
        }
        .confirmationDialog(
            LocalizedString.settingsContactTitle.localized,
            isPresented: $showingContactDialog,
            titleVisibility: .visible
        ) {
            Button(LocalizedString.contactActionReportProblem.localized) { openMail(kind: .bug) }
            Button(LocalizedString.contactActionRequestFeature.localized) { openMail(kind: .feature) }
            Button(LocalizedString.generalCancel.localized, role: .cancel) {}
        }
        .alert(LocalizedString.settingsClearCache.localized, isPresented: $viewModel.showingClearCacheAlert) {
            Button(LocalizedString.generalCancel.localized, role: .cancel) {}
            Button(LocalizedString.settingsClearCache.localized, role: .destructive) {
                Task { await viewModel.clearCache() }
            }
        } message: {
            Text(LocalizedString.settingsClearCacheMessage.localized)
        }
        .confetti(isShowing: $showConfetti, configuration: .rainbow)
        .onAppear {
            updateTimeRemaining()
            startTimer()
        }
        .onDisappear {
            stopTimer()
        }
    }

    // MARK: - Тема (модально)
    private var themeRow: some View {
        Section {
            Button {
                showThemeSheet = true
            } label: {
                HStack(spacing: Configuration.constants.spacing.value) {
                    iconView(icon: .paintpaletteFill, colors: gradientColors)
                    VStack(alignment: .leading, spacing: Configuration.constants.captionSpacing.value) {
                        Text(LocalizedString.settingsThemeSectionTitle.localized)
                            .font(AppTypography.caption.font)
                            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        Text(currentThemeName)
                            .font(AppTypography.body.font)
                            .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                    }
                    Spacer()
                    AppIcon.chevronRight.image()
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                }
                .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
        } header: {
            Text(LocalizedString.settingsThemeSectionHeader.localized)
        } footer: {
            Text(LocalizedString.settingsThemeSectionFooter.localized)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    private var currentThemeName: String {
        let theme = themeManager.currentTheme(for: colorScheme)
        return "\(theme.name) • \(themeManager.appearanceMode.displayName)"
    }

    // MARK: - Виджеты (модально)
    private var widgetRow: some View {
        Section {
            Button {
                showWidgetSheet = true
            } label: {
                HStack(spacing: Configuration.constants.spacing.value) {
                    iconView(icon: .squareGrid2x2Fill, colors: gradientColors)
                    VStack(alignment: .leading, spacing: Configuration.constants.captionSpacing.value) {
                        Text(LocalizedString.widgetHomeTitle.localized)
                            .font(AppTypography.body.font)
                            .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                    }
                    Spacer()
                    AppIcon.chevronRight.image()
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                }
                .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
        } header: {
            Text(LocalizedString.widgetTitle.localized)
        } footer: {
            Text(LocalizedString.widgetHomeSubtitle.localized)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    // MARK: - Группы
    private var groupSection: some View {
        Section {
            Button(action: { viewModel.showingGroupSelection = true }) {
                HStack(spacing: Configuration.constants.spacing.value) {
                    iconView(icon: .person3Fill, colors: gradientColors)
                    VStack(alignment: .leading, spacing: Configuration.constants.captionSpacing.value) {
                        Text(LocalizedString.groupsSelected.localized)
                            .font(AppTypography.caption.font)
                            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        Text(appViewModel.selectedGroupName ?? LocalizedString.groupsNoSelection.localized)
                            .font(AppTypography.body.font)
                            .foregroundAppColor(appViewModel.selectedGroupName != nil ? .primaryText : .secondaryText, colorScheme: colorScheme)
                    }
                    Spacer()
                    AppIcon.chevronRight.image()
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                }
            }
        } header: {
            Text(LocalizedString.settingsGroupSettings.localized)
        }
    }

    // MARK: - Кэш
    private var cacheSection: some View {
        Section {
            if let data = appViewModel.scheduleData {
                infoRow(label: LocalizedString.settingsEvents.localized, value: "\(data.groupSchedule.count)")
                infoRow(label: LocalizedString.teachersTitle.localized, value: "\(data.teachers.count)")
            }
            Button(role: .destructive) {
                viewModel.showingClearCacheAlert = true
            } label: {
                HStack {
                    AppIcon.trash.image().foregroundAppColor(.error, colorScheme: colorScheme)
                    Text(LocalizedString.settingsClearCache.localized)
                }
            }
        } header: {
            Text(LocalizedString.settingsCacheStatus.localized)
        }
    }

    // MARK: - Награда/реклама
    private var awardSection: some View {
        let premiumAccess = PremiumAccess.from(appState: appStateService.state)
        let isPremium = premiumAccess.isPremium

        return Section {
            Button {
                Task {
                    do {
                        try await coordinator?.showAd(type: .rewardedInterstitial)
                        appStateService.grantTemporaryPremium()

                        withAnimation {
                            showConfetti = true
                        }
                        updateTimeRemaining()
                    } catch {
                        print("Failed to show ad: \(error)")
                    }
                }
            } label: {
                HStack {
                    AppIcon.lockOpen.image()
                        .font(AppTypography.title3.font)
                        .themedForeground(.header, colorScheme: colorScheme)

                    VStack(alignment: .leading, spacing: 4) {
                        Text(LocalizedString.settingsDeveloperAction.localized)
                            .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                        if case .temporaryPremium = premiumAccess.status {
                            Text(timeRemaining.isEmpty ? "Calculating..." : timeRemaining)
                                .font(AppTypography.caption.font)
                                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        } else if case .premium = premiumAccess.status {
                            Text(LocalizedString.settingsPremiumActive.localized)
                                .font(AppTypography.caption.font)
                                .foregroundAppColor(.success, colorScheme: colorScheme)
                        }
                    }

                    Spacer()

                    if !isPremium {
                        AppIcon.chevronRight.image()
                            .font(AppTypography.caption.font)
                            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .contentShape(Rectangle())
                .padding(.vertical, 6)
            }
            .buttonStyle(.plain)
            .disabled(isPremium)
            .opacity(isPremium ? 0.6 : 1.0)
            .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
        } header: {
            Text(LocalizedString.settingsDeveloperSectionTitle.localized)
        } footer: {
            Text(LocalizedString.settingsDeveloperFooter.localized)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
        .preloadAds(.rewardedInterstitial, coordinator: coordinator)
    }

    // MARK: - Контакты
    private var contactSection: some View {
        Section {
            Button {
                showingContactDialog = true
            } label: {
                HStack {
                    AppIcon.envelope.image()
                        .font(AppTypography.title3.font)
                        .themedForeground(.header, colorScheme: colorScheme)

                    Text(LocalizedString.settingsContactTitle.localized)
                        .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                    Spacer()

                    AppIcon.chevronRight.image()
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .contentShape(Rectangle())
                .padding(.vertical, 6)
            }
            .buttonStyle(.plain)
            .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
        } header: {
            Text(LocalizedString.settingsSupportSectionTitle.localized)
        } footer: {
            Text(LocalizedString.settingsSupportFooter.localized)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    // MARK: - О приложении
    private var aboutSection: some View {
        Section {
            infoRow(label: LocalizedString.settingsVersion.localized, value: AppInfo.versionString)
        } header: {
            Text(LocalizedString.settingsAbout.localized)
        }
    }

    // MARK: - Debug
    @ViewBuilder
    private var debugSection: some View {
        #if DEBUG
        let isDebug = true
        #else
        let isDebug = false
        #endif

        if isDebug || featureFlagService.isEnabled(.showDebugMenu) {
            Section {
                NavigationLink("🐛 Debug Menu") {
                    DebugMenuScreen(
                        featureFlagService: featureFlagService,
                        appStateService: appStateService
                    )
                }

                NavigationLink("⚡️ Performance Monitor") {
                    PerformanceMonitorView()
                }

                NavigationLink("🧪 Ads Debug") {
                    AdsDebugScreen()
                }
            } header: {
                Text(LocalizedString.debugTools.localized)
            }
        }
    }

    // MARK: - Вспомогательные

    private func iconView(icon: AppIcon, colors: [Color]) -> some View {
        ZStack {
            RoundedRectangle(cornerRadius: Configuration.constants.iconCornerRadius.value)
                .fill(
                    LinearGradient(
                        colors: colors.map { $0.opacity(Configuration.constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: Configuration.constants.iconSize, height: Configuration.constants.iconSize)
            icon.image()
                .font(.system(size: Configuration.constants.iconImageSize))
                .foregroundStyle(LinearGradient(colors: colors, startPoint: .topLeading, endPoint: .bottomTrailing))
        }
        .accessibilityHidden(true)
    }

    private func infoRow(label: String, value: String) -> some View {
        HStack {
            Text(label)
            Spacer()
            Text(value).foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
        .accessibilityElement(children: .combine)
    }

    private var groupSelectionSheet: some View {
        let selectionVM = GroupSelectionViewModel()
        return GroupSelectionView(
            viewModel: selectionVM,
            onSelectGroup: { group in
                viewModel.selectGroup(group)
                Task {
                    try? await Task.sleep(nanoseconds: 600_000_000) // 0.6 seconds
                    try? await coordinator?.showAd(type: .interstitial)
                }
            }
        )
        .onAppear { selectionVM.setupWithAppViewModel(appViewModel) }
        .preloadAds(.interstitial, coordinator: coordinator)
    }

    private var gradientColors: [Color] {
        let theme = themeManager.currentTheme(for: colorScheme)
        return GradientStyle.header.colors(for: colorScheme, theme: theme)
    }

    private var contactComposer: ContactComposer {
        ContactComposer(
            appInfoProvider: { (AppInfo.version, AppInfo.build) },
            deviceInfoProvider: { (DeviceInfo.iOSVersion, DeviceInfo.deviceIdentifier) },
            localeProvider: { Locale.current.identifier },
            selectedGroupProvider: { "\(appViewModel.groupId.description): " + (appViewModel.selectedGroupName ?? "")}
        )
    }

    private func openMail(kind: ContactComposer.Kind) {
        pendingMailSubject = contactComposer.subject(for: kind)
        pendingMailBody = contactComposer.body(for: kind)
        if MailComposerView.canSendMail { showingMailComposer = true } else { showingMailUnavailableAlert = true }
    }

    // MARK: - Premium Timer

    private func updateTimeRemaining() {
        let premiumAccess = PremiumAccess.from(appState: appStateService.state)

        guard case .temporaryPremium(let endDate) = premiumAccess.status else {
            timeRemaining = ""
            return
        }

        let now = Date()
        guard endDate > now else {
            timeRemaining = "Expired"
            return
        }

        let interval = endDate.timeIntervalSince(now)
        let hours = Int(interval) / AppStateConfiguration.secondsInHour
        let minutes = (Int(interval) % AppStateConfiguration.secondsInHour) / 60
        let seconds = Int(interval) % 60

        if hours > 0 {
            timeRemaining = String(format: "%02d:%02d:%02d remaining", hours, minutes, seconds)
        } else {
            timeRemaining = String(format: "%02d:%02d remaining", minutes, seconds)
        }
    }

    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            updateTimeRemaining()
        }
    }

    private func stopTimer() {
        timer?.invalidate()
        timer = nil
    }
}

// ===== FILE: Timetable DSW/Features/Settings/Views/ThemeSettingsContainer.swift =====
import SwiftUI

struct ThemeSettingsContainer: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var appStateService: DefaultAppStateService
    @Environment(\.adCoordinator) private var coordinator
    
    var body: some View {
        NavigationStack {
            if (coordinator?.isAdDisabled() ?? true) {
                ThemeSettingsView()
            } else {
                let premiumAccess = PremiumAccess.from(appState: appStateService.state)
                // User doesn't have premium - show paywall with back button
                PremiumStatusScreen(
                    premiumAccess: premiumAccess,
                    onWatchAd: {
                        Task {
                            do {
                                try await coordinator?.loadAd(type: .rewarded)
                                try await coordinator?.showAd(type: .rewarded)
                                appStateService.grantTemporaryPremium()
                            } catch {
                                print("[Premium] Failed to show rewarded ad: \(error)")
                            }
                        }
                    },
                    onPurchase: {
#if DEBUG
                        appStateService.grantPremium()
#endif
                    }
                )
            }
        }
        .toolbar(.hidden, for: .navigationBar)
        .toolbarBackground(.hidden, for: .navigationBar)
        .navigationBarBackButtonHidden(true)

        // Наш кастомный заголовок сверху
        .safeAreaInset(edge: .top) {
            GradientTitleBar(
                title: LocalizedString.settingsThemeSectionTitle.localized,
                onDone: { dismiss() }
            )
        }

            #if DEBUG
            .measurePerformance(name: "ThemeSettingsContainer", category: .viewAppear)
            #endif
        }
        // Без detents — как у SubjectDetailView (занимает всю высоту)
    }

// ===== FILE: Timetable DSW/Features/Settings/Views/ThemeSettingsView.swift =====
import SwiftUI

struct ThemeSettingsView: View {
    // MARK: - Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            // как у WidgetSettingsView
            let hPadding: AppSpacing = .xxxl
            let vPadding: AppSpacing = .large
            let sectionSpacing: AppSpacing = .large
            let sectionSpacingMultiplier: CGFloat = 1.35

            let cardCornerRadius: AppCornerRadius = .large
            let cardPadding: AppSpacing = .medium
            let itemSpacing: AppSpacing = .medium
            let previewHeight: CGFloat = 120
            let previewCornerRadius: AppCornerRadius = .medium
            let selectedBorderWidth: CGFloat = 3
            let normalBorderWidth: CGFloat = 1
            let iconSize: CGFloat = 24
            let gridColumns: Int = 2
            let gridSpacing: CGFloat = 12
            let strokeOpacity: Double = 0.28
            let cardBgOpacity: Double = 0.08
            let circleBgOpacity: Double = 0.20
        }
        static let constants = Constants()
    }

    // MARK: - Environment
    @Environment(\.colorScheme) private var colorScheme
    @EnvironmentObject var themeManager: ThemeManager
    @Environment(\.bottomInsetService) private var bottomInsetService

    // MARK: - Body
    var body: some View {
        ScrollView {
            LazyVStack(
                spacing: Configuration.constants.sectionSpacing.value * Configuration.constants.sectionSpacingMultiplier
            ) {
                appearanceModeSection

                colorThemeSection
            }
            .padding(.horizontal, Configuration.constants.hPadding.value)
            .padding(.vertical, Configuration.constants.vPadding.value)
        }
        .contentMargins(.top, Configuration.constants.hPadding.value * 2, for: .scrollContent)
        .scrollIndicators(.never) // (1) скрыли индикатор
        .background(AppColor.background.color(for: colorScheme).ignoresSafeArea()) // (2) фон как у виджетов
        .safeAreaInset(edge: .bottom) {
            AppColor.clear.color(for: colorScheme)
                .frame(height: bottomInsetService?.bottomInset ?? 78)
        }
    }

    // MARK: - Sections
    private var appearanceModeSection: some View {
        VStack(alignment: .leading, spacing: Configuration.constants.itemSpacing.value) {
            Text(LocalizedString.themeSettingsAppearanceTitle.localized)
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
                .foregroundStyle(primaryGradient())

            VStack(spacing: 12) {
                ForEach(AppearanceMode.allCases) { mode in
                    AppearanceModeCard(
                        mode: mode,
                        isSelected: themeManager.appearanceMode == mode,
                        stroke: gradientStroke(),
                        selectedStrokeWidth: Configuration.constants.selectedBorderWidth,
                        normalStrokeWidth: Configuration.constants.normalBorderWidth,
                        cardBg: primaryGradient(opacity: Configuration.constants.cardBgOpacity),
                        circleBg: LinearGradient(
                            colors: GradientStyle.header
                                .colors(for: colorScheme)
                                .map { $0.opacity(Configuration.constants.circleBgOpacity) },
                            startPoint: .topLeading, endPoint: .bottomTrailing
                        ),
                        circleIconGradient: LinearGradient(
                            colors: GradientStyle.header.colors(for: colorScheme),
                            startPoint: .topLeading, endPoint: .bottomTrailing
                        )
                    ) {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            themeManager.setAppearanceMode(mode)
                        }
                    }
                }
            }
        }
    }

    private var colorThemeSection: some View {
        VStack(alignment: .leading, spacing: Configuration.constants.itemSpacing.value) {
            Text(LocalizedString.themeSettingsColorThemeTitle.localized)
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
                .foregroundStyle(primaryGradient())

            LazyVGrid(
                columns: Array(repeating: GridItem(.flexible(), spacing: Configuration.constants.gridSpacing), count: Configuration.constants.gridColumns),
                spacing: Configuration.constants.gridSpacing
            ) {
                ForEach(themeManager.allThemes(for: colorScheme), id: \.id) { theme in
                    ThemeCard(
                        theme: theme,
                        isSelected: themeManager.selectedThemeId == theme.id,
                        stroke: gradientStroke(),
                        selectedStrokeWidth: Configuration.constants.selectedBorderWidth,
                        normalStrokeWidth: Configuration.constants.normalBorderWidth,
                        previewCorner: Configuration.constants.previewCornerRadius.value,
                        previewHeight: Configuration.constants.previewHeight,
                        outerCardBg: primaryGradient(opacity: Configuration.constants.cardBgOpacity),
                        themeIconGradient: LinearGradient(
                            colors: [theme.accent, theme.primary],
                            startPoint: .topLeading, endPoint: .bottomTrailing
                        )
                    ) {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            themeManager.selectTheme(theme.id)
                        }
                    }
                }
            }
        }
    }

    // MARK: - Helpers
    private func primaryGradient(opacity: Double = 1.0) -> LinearGradient {
        LinearGradient(
            colors: GradientStyle.primary.colors(for: colorScheme).map { $0.opacity(opacity) },
            startPoint: .topLeading, endPoint: .bottomTrailing
        )
    }
    private func gradientStroke(opacity: Double = Configuration.constants.strokeOpacity) -> LinearGradient {
        LinearGradient(
            colors: GradientStyle.primary.colors(for: colorScheme).map { $0.opacity(opacity) },
            startPoint: .topLeading, endPoint: .bottomTrailing
        )
    }
    private func primaryGradient() -> any ShapeStyle { primaryGradient(opacity: 1.0) }
}

// MARK: - Appearance Mode Card
private struct AppearanceModeCard: View {
    let mode: AppearanceMode
    let isSelected: Bool
    let stroke: LinearGradient
    let selectedStrokeWidth: CGFloat
    let normalStrokeWidth: CGFloat
    let cardBg: LinearGradient
    let circleBg: LinearGradient
    let circleIconGradient: LinearGradient
    let action: () -> Void

    @Environment(\.colorScheme) private var colorScheme

    var body: some View {
        Button(action: action) {
            HStack(spacing: AppSpacing.medium.value) {
                ZStack {
                    Circle()
                        .fill(circleBg)
                        .frame(width: 44, height: 44)
                        .overlay(Circle().stroke(stroke, lineWidth: normalStrokeWidth))

                    mode.icon.image()
                        .font(.system(size: 20, weight: .medium))
                        .foregroundStyle(circleIconGradient)
                }

                VStack(alignment: .leading, spacing: 2) {
                    Text(mode.displayName)
                        .font(AppTypography.body.font)
                        .fontWeight(.medium)
                        .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                    Text(description(for: mode))
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                }

                Spacer()

                if isSelected {
                    AppIcon.checkmarkCircleFill.image()
                        .font(.system(size: 24))
                        .themedForeground(.success, colorScheme: colorScheme)
                }
            }
            .padding(AppSpacing.medium.value)
            .background(
                RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value)
                    .fill(cardBg) // градиентная подложка карточки стиля
            )
            .overlay(
                RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value)
                    .stroke(stroke, lineWidth: isSelected ? selectedStrokeWidth : normalStrokeWidth)
            )
            .contentShape(RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value))
        }
        .buttonStyle(.plain)
    }

    private func description(for mode: AppearanceMode) -> String {
        switch mode {
        case .system: return LocalizedString.appearanceDescSystem.localized
        case .light:  return LocalizedString.appearanceDescLight.localized
        case .dark:   return LocalizedString.appearanceDescDark.localized
        }
    }
}

// MARK: - Theme Card (gradient outer bg, gradient preview bg, full hit area, gradient icon)
private struct ThemeCard: View {
    let theme: any Theme
    let isSelected: Bool
    let stroke: LinearGradient
    let selectedStrokeWidth: CGFloat
    let normalStrokeWidth: CGFloat
    let previewCorner: CGFloat
    let previewHeight: CGFloat
    let outerCardBg: LinearGradient
    let themeIconGradient: LinearGradient
    let action: () -> Void

    @Environment(\.colorScheme) private var colorScheme

    var body: some View {
        Button(action: action) {
            VStack(spacing: AppSpacing.small.value) {
                // Preview: градиентный фон + рамка
                ZStack {
                    RoundedRectangle(cornerRadius: previewCorner)
                        .fill(
                            LinearGradient(
                                colors: [theme.primary, theme.secondary, theme.tertiary],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: previewCorner)
                                .stroke(stroke, lineWidth: isSelected ? selectedStrokeWidth : normalStrokeWidth)
                        )

                    VStack(spacing: 6) {
                        HStack(spacing: 6) {
                            Circle().fill(theme.lectureStart).frame(width: 16, height: 16)
                            Circle().fill(theme.exerciseStart).frame(width: 16, height: 16)
                            Circle().fill(theme.laboratoryStart).frame(width: 16, height: 16)
                        }

                        // Иконка темы с градиентной заливкой
                        theme.icon.image()
                            .font(.system(size: 28, weight: .medium))
                            .foregroundStyle(themeIconGradient)
                    }
                }
                .frame(height: previewHeight)

                // Название темы + маркер выбора
                HStack(spacing: 6) {
                    Text(LocalizedString.themeName(for: theme.id))
                        .font(AppTypography.body.font)
                        .fontWeight(isSelected ? .semibold : .medium)
                        .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                    if isSelected {
                        AppIcon.checkmarkCircleFill.image()
                            .font(.system(size: 16))
                            .foregroundColor(theme.success)
                    }
                }
            }
            .padding(AppSpacing.small.value)
            // Фон внешней карточки темы — градиент (как просили)
            .background(
                RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value)
                    .fill(outerCardBg)
            )
            .overlay(
                RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value)
                    .stroke(stroke, lineWidth: isSelected ? selectedStrokeWidth : normalStrokeWidth)
            )
            // Тап по всей ячейке (включая паддинги)
            .contentShape(RoundedRectangle(cornerRadius: ThemeSettingsView.Configuration.constants.cardCornerRadius.value))
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Preview
#Preview {
    ThemeSettingsView()
}

// ===== FILE: Timetable DSW/Features/Settings/Views/WidgetSettingsContainer.swift =====
import SwiftUI

struct WidgetSettingsContainer: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var appStateService: DefaultAppStateService
    @Environment(\.adCoordinator) private var coordinator

    var body: some View {
        NavigationStack {
            let premiumAccess = PremiumAccess.from(appState: appStateService.state)
            Group {
                if (coordinator?.isAdDisabled() ?? false) {
                    // Внутри есть свой ScrollView — не дублируем
                    WidgetSettingsView()
                } else {
                    PremiumStatusScreen(
                        premiumAccess: premiumAccess,
                        onWatchAd: {
                            Task {
                                do {
                                    try await coordinator?.loadAd(type: .rewarded)
                                    try await coordinator?.showAd(type: .rewarded)
                                    appStateService.grantTemporaryPremium()
                                } catch {
                                    print("[Premium] Failed to show rewarded ad: \(error)")
                                }
                            }
                        },
                        onPurchase: {
#if DEBUG
                            appStateService.grantPremium()
#endif
                        }
                    )
                }
            }
            // Полностью убираем фон системного навбара
            .toolbar(.hidden, for: .navigationBar)
            .toolbarBackground(.hidden, for: .navigationBar)
            .navigationBarBackButtonHidden(true)

            // Наш кастомный заголовок сверху
            .safeAreaInset(edge: .top) {
                GradientTitleBar(
                    title: LocalizedString.widgetTitle.localized,
                    onDone: { dismiss() }
                )
            }

            #if DEBUG
            .measurePerformance(name: "WidgetSettingsContainer", category: .viewAppear)
            #endif
        }
        .presentationDragIndicator(.hidden)
    }
}

// ===== FILE: Timetable DSW/Features/Settings/Views/WidgetSettingsView.swift =====
import SwiftUI
import WidgetKit

struct WidgetSettingsView: View {
    // MARK: - Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            // Layout
            let hPadding: AppSpacing = .large
            let vPadding: AppSpacing = .large
            let sectionSpacing: AppSpacing = .large
            let itemSpacing: AppSpacing = .medium

            // Multipliers
            let sectionSpacingMultiplier: CGFloat = 1.35
            let itemSpacingMultiplier: CGFloat = 1.20
            let cardVPadMultiplier: CGFloat = 1.40

            // Cards
            let containerCorner: AppCornerRadius = .large
            let cardPadding: AppSpacing = .large
            let cardStrokeOpacity: Double = 0.28

            // Misc
            let numberBadgeSize: CGFloat = 28
            let iconSize: CGFloat = 28
        }
        static let constants = Constants()
    }

    // MARK: - Environment
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.bottomInsetService) private var bottomInsetService

    // MARK: - State
    @State private var lastUpdated: Date? = AppGroupManager.loadLastUpdated()

    // MARK: - Body
    var body: some View {
        ScrollView {
            LazyVStack(
                spacing: Configuration.constants.sectionSpacing.value * Configuration.constants.sectionSpacingMultiplier
            ) {
                headerSection
                statusSection
                instructionsSection
                widgetTypesSection
                troubleshootingSection
                footerRefreshHint
            }
            .padding(.horizontal, Configuration.constants.hPadding.value)
            .padding(.vertical, Configuration.constants.vPadding.value)
        }
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button(action: refreshWidgets) {
                    AppIcon.arrowClockwise.image()
                        .font(.system(size: 16, weight: .semibold))
                        .themedForeground(.header, colorScheme: colorScheme)
                        .accessibilityLabel(LocalizedString.settingsRefresh.localized)
                }
            }
        }
        .safeAreaInset(edge: .bottom) {
            AppColor.clear.color(for: colorScheme)
                .frame(height: bottomInsetService?.bottomInset ?? 78)
        }
        .background(AppColor.background.color(for: colorScheme).ignoresSafeArea())
    }

    // MARK: - Header
    private var headerSection: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(LocalizedString.widgetTitle.localized)
                .font(AppTypography.title2.font)
                .fontWeight(.semibold)
                .themedForeground(.primary, colorScheme: colorScheme)

            Text(LocalizedString.widgetSettingsSubtitle.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .fixedSize(horizontal: false, vertical: true)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    // MARK: - Status
    private var statusSection: some View {
        cardContainer {
            HStack(alignment: .top, spacing: 14) {
                ZStack {
                    // Только градиентная обводка
                    Circle()
                        .stroke(gradientStroke(), lineWidth: 1)
                        .frame(width: 42, height: 42)

                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 22, weight: .semibold))
                        .themedForeground(.success, colorScheme: colorScheme)
                }

                VStack(alignment: .leading, spacing: 6) {
                    Text(LocalizedString.widgetEnabledTitle.localized)
                        .font(AppTypography.body.font)
                        .fontWeight(.semibold)
                        .foregroundAppColor(.primaryText, colorScheme: colorScheme)

                    if let lastUpdated {
                        Text("\(LocalizedString.settingsLastUpdated.localized): \(lastUpdated, style: .relative) \(LocalizedString.relativeAgo.localized)")
                            .font(AppTypography.caption.font)
                            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                            .fixedSize(horizontal: false, vertical: true)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .layoutPriority(1)
                    } else {
                        Text(LocalizedString.widgetNeverUpdated.localized)
                            .font(AppTypography.caption.font)
                            .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                            .fixedSize(horizontal: false, vertical: true)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .layoutPriority(1)
                    }

                    Text(LocalizedString.widgetAccessDescription.localized)
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        .padding(.top, 6)
                        .fixedSize(horizontal: false, vertical: true)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .layoutPriority(1)
                }

                Spacer(minLength: 0)

                Button(action: refreshWidgets) {
                    HStack(spacing: 6) {
                        AppIcon.arrowClockwise.image()
                            .font(.system(size: 14, weight: .semibold))
                        Text(LocalizedString.settingsRefresh.localized)
                            .font(AppTypography.caption.font)
                            .fontWeight(.semibold)
                            .lineLimit(1)
                            .minimumScaleFactor(0.8)
                    }
                    .themedForeground(.success, colorScheme: colorScheme)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    // Только капсула-обводка без фона
                    .overlay(
                        Capsule().stroke(gradientStroke(), lineWidth: 1)
                    )
                }
                .buttonStyle(.plain)
                .accessibilityLabel(LocalizedString.settingsRefresh.localized)
            }
        }
    }

    // MARK: - Instructions
    private var instructionsSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            sectionTitle(LocalizedString.widgetHowToAdd.localized)

            cardContainer {
                VStack(
                    alignment: .leading,
                    spacing: CGFloat(12) * Configuration.constants.itemSpacingMultiplier
                ) {
                    instructionRow(step: 1, text: LocalizedString.widgetInstructionStep1.localized)
                    instructionRow(step: 2, text: LocalizedString.widgetInstructionStep2.localized)
                    instructionRow(step: 3, text: LocalizedString.widgetInstructionStep3.localized)
                    instructionRow(step: 4, text: LocalizedString.widgetInstructionStep4.localized)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
    }

    private func instructionRow(step: Int, text: String) -> some View {
        HStack(alignment: .top, spacing: 12) {
            ZStack {
                // Только обводка
                Circle()
                    .stroke(gradientStroke(), lineWidth: 1)
                    .frame(width: Configuration.constants.numberBadgeSize, height: Configuration.constants.numberBadgeSize)
                Text("\(step)")
                    .font(.system(size: 14, weight: .bold))
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)
            }

            Text(text)
                .font(AppTypography.body.font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                .fixedSize(horizontal: false, vertical: true)
                .frame(maxWidth: .infinity, alignment: .leading)
                .layoutPriority(1)
        }
    }

    // MARK: - Widget Types
    private var widgetTypesSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            sectionTitle(LocalizedString.widgetAvailable.localized)

            VStack(
                spacing: Configuration.constants.itemSpacing.value * Configuration.constants.itemSpacingMultiplier
            ) {
                widgetTypeCard(
                    title: LocalizedString.widgetTypeSmallTitle.localized,
                    icon: "square.fill",
                    description: LocalizedString.widgetTypeSmallDescription.localized
                )
                widgetTypeCard(
                    title: LocalizedString.widgetTypeMediumTitle.localized,
                    icon: "rectangle.fill",
                    description: LocalizedString.widgetTypeMediumDescription.localized
                )
                widgetTypeCard(
                    title: LocalizedString.widgetTypeLargeTitle.localized,
                    icon: "rectangle.portrait.fill",
                    description: LocalizedString.widgetTypeLargeDescription.localized
                )
//                widgetTypeCard(
//                    title: LocalizedString.widgetTypeLiveTitle.localized,
//                    icon: "circle.hexagongrid.circle.fill",
//                    description: LocalizedString.widgetTypeLiveDescription.localized
//                )
            }
        }
    }

    private func widgetTypeCard(title: String, icon: String, description: String) -> some View {
        cardContainer {
            HStack(alignment: .top, spacing: 14) {
                ZStack {
                    // Контейнер иконки — только обводка
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(gradientStroke(), lineWidth: 1)
                        .frame(width: 50, height: 50)

                    Image(systemName: icon)
                        .font(.system(size: Configuration.constants.iconSize))
                        .themedForeground(.primary, colorScheme: colorScheme)
                }

                VStack(alignment: .leading, spacing: 4) {
                    Text(title)
                        .font(AppTypography.body.font)
                        .fontWeight(.semibold)
                        .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                        .fixedSize(horizontal: false, vertical: true)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .layoutPriority(1)

                    Text(description)
                        .font(AppTypography.caption.font)
                        .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                        .fixedSize(horizontal: false, vertical: true)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .layoutPriority(1)
                }

                Spacer(minLength: 0)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }

    // MARK: - Troubleshooting
    private var troubleshootingSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            sectionTitle(LocalizedString.widgetTroubleshooting.localized)

            cardContainer {
                VStack(
                    alignment: .leading,
                    spacing: CGFloat(14) * Configuration.constants.itemSpacingMultiplier
                ) {
                    troubleshootingItem(
                        problem: LocalizedString.widgetTroubleNoDataTitle.localized,
                        solution: LocalizedString.widgetTroubleNoDataSolution.localized
                    )
                    Divider()
                    troubleshootingItem(
                        problem: LocalizedString.widgetTroubleNotUpdatingTitle.localized,
                        solution: LocalizedString.widgetTroubleNotUpdatingSolution.localized
                    )
                    Divider()
                    troubleshootingItem(
                        problem: LocalizedString.widgetTroubleWrongThemeTitle.localized,
                        solution: LocalizedString.widgetTroubleWrongThemeSolution.localized
                    )
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
    }

    private func troubleshootingItem(problem: String, solution: String) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(alignment: .top, spacing: 8) {
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.system(size: 14, weight: .semibold))
                    .themedForeground(.warning, colorScheme: colorScheme)

                Text(problem)
                    .font(AppTypography.caption.font)
                    .fontWeight(.semibold)
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                    .fixedSize(horizontal: false, vertical: true)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .layoutPriority(1)
            }

            Text(solution)
                .font(AppTypography.caption2.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .fixedSize(horizontal: false, vertical: true)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.leading, 22)
                .layoutPriority(1)
        }
    }

    // MARK: - Footer
    private var footerRefreshHint: some View {
        HStack(spacing: 8) {
            AppIcon.arrowClockwise.image()
                .font(.system(size: 14, weight: .semibold))
                .themedForeground(.primary, colorScheme: colorScheme)
            Text(LocalizedString.widgetFooterReloadHint.localized)
                .font(AppTypography.caption2.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(maxWidth: .infinity, alignment: .center)
        .padding(.top, 8)
    }

    // MARK: - Card container (only gradient stroke)
    private func cardContainer<Content: View>(@ViewBuilder _ content: () -> Content) -> some View {
        let corner = Configuration.constants.containerCorner.value

        return VStack(alignment: .leading, spacing: 0) {
            content()
                .padding(.vertical, Configuration.constants.cardPadding.value * Configuration.constants.cardVPadMultiplier)
                .padding(.horizontal, Configuration.constants.cardPadding.value)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        // Без фонов/теней/blur — только обводка
        .overlay(
            RoundedRectangle(cornerRadius: corner)
                .stroke(gradientStroke(), lineWidth: 1)
        )
    }

    private func gradientStroke(opacity: Double = Configuration.constants.cardStrokeOpacity) -> LinearGradient {
        let colors = GradientStyle.primary.colors(for: colorScheme).map { $0.opacity(opacity) }
        return LinearGradient(colors: colors, startPoint: .topLeading, endPoint: .bottomTrailing)
    }

    private func sectionTitle(_ text: String) -> some View {
        Text(text)
            .font(AppTypography.title3.font)
            .fontWeight(.semibold)
            .themedForeground(.primary, colorScheme: colorScheme)
            .frame(maxWidth: .infinity, alignment: .leading)
            .fixedSize(horizontal: false, vertical: true)
    }

    // MARK: - Actions
    private func refreshWidgets() {
        WidgetCenter.shared.reloadAllTimelines()
        let now = Date()
        lastUpdated = now
        AppGroupManager.saveLastUpdated(now)
    }
}

// ===== FILE: Timetable DSW/Features/Subjects/Subject.swift =====
import Foundation

struct Subject: Identifiable, Hashable, Sendable {
    var id: String { normalizedName }
    let name: String
    let normalizedName: String
    let schedule: [ScheduleEvent]

    init(name: String, schedule: [ScheduleEvent]) {
        self.name = name.trimmingCharacters(in: .whitespacesAndNewlines)
        self.normalizedName = Self.normalize(self.name)
        self.schedule = schedule.sorted { (lhs, rhs) in
            guard let l = lhs.startDate, let r = rhs.startDate else { return false }
            return l < r
        }
    }

    var count: Int { schedule.count }

    private static func normalize(_ s: String) -> String {
        s.lowercased()
         .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
         .trimmingCharacters(in: .whitespacesAndNewlines)
    }
}

// ===== FILE: Timetable DSW/Features/Subjects/SubjectDetailView.swift =====
import SwiftUI

// MARK: - SubjectDetailView (final, optimized)

struct SubjectDetailView: View {
    // MARK: Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            // Layout
            let spacing: AppSpacing = .large
            let sectionSpacing: AppSpacing = .medium
            let padding: AppSpacing = .large

            // Header stack spacing (title + assessment)
            let headerTightSpacing: CGFloat = 6

            // Stats container
            let statsCorner: AppCornerRadius = .large
            let statItemCorner: AppCornerRadius = .medium
            let statItemPadding: AppSpacing = .large
            let statColumns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]
            let containerStrokeOpacity: Double = 0.30

            // Тени (компактные, цветные, без смещений)
            let containerShadowOpacityColored: Double = 0.35
            let containerShadowRadiusTight: CGFloat = 7

            let pillStrokeOpacity: Double = 0.28
            let pillShadowOpacityColored: Double = 0.35
            let pillShadowRadiusTight: CGFloat = 6

            // Date line paddings
            let dateChipVPad: CGFloat = 8
            let dateChipHPad: CGFloat = 12

            // Typography
            let pillNumberFont = AppTypography.custom(size: 22, weight: .semibold).font
            let pillLabelFont  = AppTypography.caption2.font
        }
        static let constants = Constants()
    }

    // MARK: Environment & State
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.dismiss) private var dismiss

    @StateObject var viewModel: SubjectDetailViewModel

    // Перенос тяжёлого дерева на следующий тик после анимации
    @State private var didAppear = false

    // Стабилизация «текущего времени» для EventCard
    @State private var now = Date()

    // Предварительно вычисленное значение (во избежание вычислений в body)
    private let precomputedMostCommonGrading: String?

    // MARK: Init
    init(subject: Subject) {
        _viewModel = StateObject(wrappedValue: SubjectDetailViewModel(subject: subject))
        self.precomputedMostCommonGrading = Self.computeMostCommonGrading(subject.schedule)
    }

    // MARK: Derived
    private var gradientColors: [Color] {
        GradientStyle.primary.colors(for: colorScheme)
    }
    private var accentShadowColor: Color {
        gradientColors.dropFirst().first ?? gradientColors.first ?? Color.accentColor
    }

    /// Чистая заливка для пилюль: светлая в Light, деликатная в Dark
    private var cleanPillFill: LinearGradient {
        let isDark = colorScheme == .dark
        return LinearGradient(
            colors: isDark
                ? [Color.white.opacity(0.10), Color.white.opacity(0.04)] // white-glass в тёмной теме
                : [Color.white.opacity(0.96), Color.white.opacity(0.88)], // почти белая в светлой
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    // MARK: Body
    var body: some View {
        NavigationStack {
            ScrollView {
                LazyVStack(spacing: Configuration.constants.spacing.value) { // ← ленивый контейнер
                    VStack(alignment: .leading, spacing: Configuration.constants.headerTightSpacing) {
                        subjectHeader
                        assessmentLine
                    }

                    statsSection

                    // Отложенная инициализация тяжёлого списка секций
                    if didAppear {
                        sectionsList
                    }
                }
                .padding(.horizontal, Configuration.constants.padding.value)
                .padding(.bottom, Configuration.constants.padding.value)
            }
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) { doneButton }
            }
            .safeAreaInset(edge: .bottom) { Color.clear.frame(height: 96) }
            #if DEBUG
            .measurePerformance(name: "SubjectDetailView", category: .viewAppear)
            #endif
            .onAppear {
                // Дать закончиться переходу и зафиксировать «сейчас»
                DispatchQueue.main.async {
                    self.didAppear = true
                    self.now = Date()
                }
            }
        }
    }

    // MARK: - Header

    private var subjectHeader: some View {
        Text(viewModel.subject.name)
            .font(AppTypography.title2.font)
            .fontWeight(.semibold)
            .multilineTextAlignment(.leading)
            .frame(maxWidth: .infinity, alignment: .leading)
            .themedForeground(.primary, colorScheme: colorScheme)
            .accessibilityLabel(viewModel.subject.name)
    }

    // MARK: - Assessment

    private var assessmentLine: some View {
        Group {
            if let grading = precomputedMostCommonGrading, !grading.isEmpty {
                Text("\(LocalizedString.subjectsGradingType.localized): \(grading)")
                    .font(AppTypography.subheadline.font)
                    .fontWeight(.semibold)
                    .themedForeground(.primary, colorScheme: colorScheme)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .accessibilityLabel("\(LocalizedString.subjectsGradingType.localized): \(grading)")
            }
        }
    }

    // MARK: - Navbar

    private var doneButton: some View {
        Button(LocalizedString.generalDone.localized) { dismiss() }
            .fontWeight(.medium)
            .themedForeground(.header, colorScheme: colorScheme)
    }

    // MARK: - Stats (outline + compact colored shadow)

    private var statsSection: some View {
        let s = viewModel.stats

        return VStack(spacing: Configuration.constants.sectionSpacing.value) {
            LazyVGrid(columns: Configuration.constants.statColumns,
                      spacing: Configuration.constants.sectionSpacing.value) {
                statPill(title: LocalizedString.subjectsTotal.localized,        value: s.total)
                statPill(title: LocalizedString.subjectsPast.localized,         value: s.past)
                statPill(title: LocalizedString.subjectsUpcoming.localized,     value: s.upcoming)
                statPill(title: LocalizedString.subjectsLectures.localized,     value: s.lectures)
                statPill(title: LocalizedString.subjectsExercises.localized,    value: s.exercises)
                statPill(title: LocalizedString.subjectsLaboratories.localized, value: s.laboratories)
            }
        }
        .padding(Configuration.constants.statItemPadding.value)
        .background(
            RoundedRectangle(cornerRadius: Configuration.constants.statsCorner.value)
                .strokeBorder(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(Configuration.constants.containerStrokeOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 1
                )
                .shadow(
                    color: accentShadowColor.opacity(Configuration.constants.containerShadowOpacityColored),
                    radius: Configuration.constants.containerShadowRadiusTight,
                    x: 0, y: 0
                )
        )
        .compositingGroup()           // объединяем в один слой
        .drawingGroup(opaque: false)  // снижает композитинг-стоимость
    }

    private func statPill(title: String, value: Int) -> some View {
        ZStack {
            // Лёгкое свечение — без blur (дешевле, чем offscreen blur)
            RoundedRectangle(cornerRadius: Configuration.constants.statItemCorner.value)
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(0.12) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .blur(radius: 10)

            // ЧИСТАЯ заливка (вместо .ultraThinMaterial)
            RoundedRectangle(cornerRadius: Configuration.constants.statItemCorner.value)
                .fill(cleanPillFill)
                .overlay(
                    RoundedRectangle(cornerRadius: Configuration.constants.statItemCorner.value)
                        .strokeBorder(
                            LinearGradient(
                                colors: gradientColors.map { $0.opacity(Configuration.constants.pillStrokeOpacity) },
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
                .shadow(
                    color: accentShadowColor.opacity(Configuration.constants.pillShadowOpacityColored),
                    radius: Configuration.constants.pillShadowRadiusTight,
                    x: 0, y: 0
                )
        }
        .overlay(
            VStack(spacing: 6) {
                Text("\(value)")
                    .font(Configuration.constants.pillNumberFont)
                    .themedForeground(.primary, colorScheme: colorScheme)
                Text(title)
                    .font(Configuration.constants.pillLabelFont)
                    .fontWeight(.medium)
                    .foregroundAppColor(.primaryText, colorScheme: colorScheme)
                    .multilineTextAlignment(.center)
            }
            .padding(.vertical, 10)
            .padding(.horizontal, 6)
        )
        .frame(maxWidth: .infinity, minHeight: 64)
    }

    // MARK: - Sections

    private var sectionsList: some View {
        VStack(spacing: Configuration.constants.sectionSpacing.value) {
            ForEach(viewModel.sections, id: \.date) { section in
                VStack(alignment: .leading, spacing: 8) {
                    dateLine(for: section.date)
                    VStack(spacing: Configuration.constants.sectionSpacing.value) {
                        ForEach(section.items) { ev in
                            EventCard(
                                event: ev,
                                showTeacherName: true,
                                onTeacherTap: nil,
                                now: now
                            )
                        }
                    }
                }
            }
        }
    }

    // MARK: - Date Line

    private func dateLine(for date: Date) -> some View {
        HStack(spacing: 8) {
            Text(Self.dotDateFormatter.string(from: date))
                .font(AppTypography.subheadline.font)
                .fontWeight(.semibold)
                .themedForeground(.primary, colorScheme: colorScheme)

            Text(Self.weekdayShortFormatter.string(from: date))
                .font(AppTypography.subheadline.font)
                .fontWeight(.semibold)
                .themedForeground(.primary, colorScheme: colorScheme)
        }
        .padding(.vertical, Configuration.constants.dateChipVPad)
        .padding(.horizontal, Configuration.constants.dateChipHPad)
    }
}

// MARK: - Helpers

private extension SubjectDetailView {
    static func computeMostCommonGrading(_ events: [ScheduleEvent]) -> String? {
        let values = events
            .compactMap { $0.grading?.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        guard !values.isEmpty else { return nil }
        let freq = Dictionary(grouping: values, by: { $0 }).mapValues(\.count)
        return freq.max(by: { $0.value < $1.value })?.key
    }
}

// MARK: - Formatters

private extension SubjectDetailView {
    static let dotDateFormatter: DateFormatter = {
        let df = DateFormatter()
        df.locale = .current
        df.dateFormat = "dd.MM.yyyy"
        return df
    }()

    static let weekdayShortFormatter: DateFormatter = {
        let df = DateFormatter()
        df.locale = .current
        df.setLocalizedDateFormatFromTemplate("EEE")
        return df
    }()
}

// ===== FILE: Timetable DSW/Features/Subjects/SubjectDetailViewModel.swift =====
import Foundation
import Combine

struct SubjectStats: Sendable {
    let total: Int
    let past: Int
    let upcoming: Int
    let lectures: Int
    let exercises: Int
    let laboratories: Int
    let other: Int
}

@MainActor
final class SubjectDetailViewModel: ObservableObject {
    let subject: Subject
    let dateService: DateService
    private let eventTypeDetector: EventTypeDetector

    // Cached computed properties for performance
    @Published private(set) var stats: SubjectStats
    @Published private(set) var sections: [(date: Date, items: [ScheduleEvent])]

    init(
        subject: Subject,
        dateService: DateService = DefaultDateService.shared,
        eventTypeDetector: EventTypeDetector = DefaultEventTypeDetector()
    ) {
        self.subject = subject
        self.dateService = dateService
        self.eventTypeDetector = eventTypeDetector

        // Initialize cached properties once
        self.stats = Self.computeStats(for: subject, using: eventTypeDetector)
        self.sections = Self.computeSections(for: subject)
    }

    // MARK: - Private Static Helpers

    private static func computeStats(for subject: Subject, using detector: EventTypeDetector) -> SubjectStats {
        let total = subject.schedule.count
        let now = Date()
        let past = subject.schedule.filter { ($0.endDate ?? .distantPast) < now }.count
        let upcoming = total - past

        var lectures = 0, exercises = 0, laboratories = 0, other = 0
        for ev in subject.schedule {
            switch detector.detectEventType(from: ev.type) {
            case .lecture: lectures += 1
            case .exercise: exercises += 1
            case .laboratory: laboratories += 1
            case .other: other += 1
            }
        }

        return SubjectStats(
            total: total, past: past, upcoming: upcoming,
            lectures: lectures, exercises: exercises, laboratories: laboratories, other: other
        )
    }

    private static func computeSections(for subject: Subject) -> [(date: Date, items: [ScheduleEvent])] {
        let grouped = Dictionary(grouping: subject.schedule) { (ev: ScheduleEvent) -> Date in
            (ev.startDate ?? .distantPast).onlyYMD()
        }

        let mapped: [(date: Date, items: [ScheduleEvent])] = grouped.map { (key: Date, value: [ScheduleEvent]) in
            let sortedItems: [ScheduleEvent] = value.sorted(by: { (a: ScheduleEvent, b: ScheduleEvent) in
                (a.startDate ?? .distantPast) < (b.startDate ?? .distantPast)
            })
            return (date: key, items: sortedItems)
        }

        return mapped.sorted(by: { (lhs: (date: Date, items: [ScheduleEvent]), rhs: (date: Date, items: [ScheduleEvent])) in
            lhs.date < rhs.date
        })
    }
}

private extension Date {
    func onlyYMD() -> Date {
        let cal = Calendar.current
        let comps = cal.dateComponents([.year,.month,.day], from: self)
        return cal.date(from: comps) ?? self
    }
}

// ===== FILE: Timetable DSW/Features/Subjects/SubjectsView.swift =====
import SwiftUI

struct SubjectsView: View {
    // MARK: - Configuration
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let progressScale: CGFloat = 1.2
            let spacing: AppSpacing = .large
        }
        static let constants = Constants()
    }

    // MARK: - Properties
    @StateObject var viewModel: SubjectsViewModel = .init()
    @EnvironmentObject var appViewModel: AppViewModel
    @State private var selectedSubject: Subject?

    // MARK: - Environment
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.bottomInsetService) private var bottomInsetService

    // MARK: - Body
    var body: some View {
        NavigationView {
            contentView
                .navigationTitle(LocalizedString.subjectsTitle.localized)
                .searchable(text: $viewModel.searchText, placement: .navigationBarDrawer(displayMode: .always), prompt: LocalizedString.subjectsSearch.localized)
                .onAppear {
                    if let data = appViewModel.scheduleData {
                        viewModel.rebuild(from: data)
                    }
                }
                .onChange(of: appViewModel.scheduleData) {
                    if let data = appViewModel.scheduleData {
                        viewModel.rebuild(from: data)
                    }
                }
                #if DEBUG
                .measurePerformance(name: "SubjectsView", category: .viewAppear)
                #endif
        }
        .sheet(item: $selectedSubject) { subject in
            SubjectDetailView(subject: subject)
        }
    }

    // MARK: - Content Views
    @ViewBuilder
    private var contentView: some View {
        if appViewModel.isLoading {
            loadingView
        } else if appViewModel.scheduleData == nil {
            noDataView
        } else if viewModel.filteredSubjects.isEmpty {
            noResultsView
        } else {
            subjectsList
        }
    }

    private var loadingView: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            ProgressView()
                .scaleEffect(Configuration.constants.progressScale)
            Text(LocalizedString.subjectsLoading.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    private var noDataView: some View {
        ContentUnavailableView(
            LocalizedString.subjectsNoData.localized,
            systemImage: AppIcon.person2Slash.systemName,
            description: Text(LocalizedString.subjectsLoadScheduleFirst.localized)
        )
    }

    private var noResultsView: some View {
        ContentUnavailableView(
            LocalizedString.subjectsNoFound.localized,
            systemImage: AppIcon.magnifyingGlass.systemName,
            description: Text(LocalizedString.groupsAdjustSearch.localized)
        )
    }

    private var subjectsList: some View {
        List(viewModel.filteredSubjects) { subject in
            SubjectRow(subject: subject) {
                selectedSubject = subject
            }
            .listRowInsets(EdgeInsets(
                top: AppSpacing.xs.value,
                leading: AppSpacing.large.value,
                bottom: AppSpacing.xs.value,
                trailing: AppSpacing.large.value
            ))
        }
        .listStyle(.plain)
        .safeAreaInset(edge: .bottom) {
            AppColor.clear.color(for: colorScheme)
                .frame(height: bottomInsetService?.bottomInset ?? 78)
        }
    }
}

// MARK: - Subject Row (1-в-1 стиль TeacherRow, меняем только наполнение)

private struct SubjectRow: View {
    struct Constants {
        let avatarSize: CGFloat = AppDimensions.avatarLarge.value
        let spacing: AppSpacing = .medium
        let padding: AppSpacing = .medium
        let initialsSize: CGFloat = 18
        let nameSize: CGFloat = 16
        let subtitleSize: CGFloat = 13
        let countSize: CGFloat = 20
        let classesSize: CGFloat = 11
        let backgroundOpacity: Double = 0.15
        let nameSpacing: AppSpacing = .xxs
        let countSpacing: AppSpacing = .xxs
        let cornerRadius: CGFloat = AppCornerRadius.large.value
    }
    private let constants = Constants()

    // MARK: - Properties
    let subject: Subject
    let action: () -> Void

    // MARK: - Environment
    @Environment(\.colorScheme) var colorScheme

    // MARK: - Dependencies
    private let hapticService: HapticFeedbackService = DefaultHapticFeedbackService()

    // MARK: - Body
    var body: some View {
        Button(action: handleTap) {
            HStack(spacing: constants.spacing.value) {
                avatarView
                textContent
                Spacer()
                classesIndicator
            }
            .padding(constants.padding.value)
        }
    }

    // MARK: - Subviews
    private var avatarView: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: constants.avatarSize, height: constants.avatarSize)

            Text(initials)
                .font(AppTypography.custom(size: constants.initialsSize, weight: .semibold).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        }
    }

    private var textContent: some View {
        VStack(alignment: .leading, spacing: constants.nameSpacing.value) {
            Text(subject.name)
                .font(AppTypography.custom(size: constants.nameSize, weight: .semibold).font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)

            // ↓ Вместо типов занятий показываем "сколько осталось"
            Text(bottomLine)
                .font(AppTypography.custom(size: constants.subtitleSize, weight: .regular).font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                .lineLimit(1)
        }
    }

    private var gradingType: String? {
           let values = subject.schedule
               .map { ($0.grading ?? "").trimmingCharacters(in: .whitespacesAndNewlines) }
               .filter { !$0.isEmpty }
           guard !values.isEmpty else { return nil }
           let freq = Dictionary(grouping: values, by: { $0 }).mapValues(\.count)
           return freq.max(by: { $0.value < $1.value })?.key
       }

       /// Строка под названием предмета: «Осталось … • Тип зачёта»
       private var bottomLine: String {
           if let g = gradingType {
               return "\(LocalizedString.subjectsUpcoming.localized): \(upcomingCount) • \(g)"
           } else {
               return "\(LocalizedString.subjectsUpcoming.localized): \(upcomingCount)"
           }
       }

    private var classesIndicator: some View {
        VStack(spacing: constants.countSpacing.value) {
            Text("\(subject.count)")
                .font(AppTypography.custom(size: constants.countSize, weight: .bold).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )

            Text(LocalizedString.subjectsClasses.localized)
                .font(AppTypography.custom(size: constants.classesSize, weight: .regular).font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }

    // MARK: - Computed
    private var initials: String {
        let parts = subject.name.split(separator: " ")
        if parts.count >= 2 {
            let first = parts[0].prefix(1)
            let last  = parts[1].prefix(1)
            return "\(first)\(last)".uppercased()
        }
        return String(subject.name.prefix(1)).uppercased()
    }

    private var gradientColors: [Color] {
        GradientStyle.accent.colors(for: colorScheme)
    }

    // Сколько занятий осталось у предмета (включая текущее, если оно ещё не закончено)
    private var upcomingCount: Int {
        let now = Date()
        return subject.schedule.reduce(into: 0) { acc, ev in
            if let end = ev.endDate {
                if end >= now { acc += 1 }
            } else if let start = ev.startDate {
                if start >= now { acc += 1 }
            }
        }
    }

    // MARK: - Actions
    private func handleTap() {
        hapticService.impact(style: .light)
        action()
    }
}

// ===== FILE: Timetable DSW/Features/Subjects/SubjectsViewModel.swift =====
import Foundation
import Combine

@MainActor
final class SubjectsViewModel: ObservableObject {
    @Published var searchText: String = ""
    @Published private(set) var allSubjects: [Subject] = []

    // Сборка из агрегата
    func rebuild(from aggregate: AggregateResponse) {
        let grouped = Dictionary(grouping: aggregate.groupSchedule) { (ev: ScheduleEvent) in
            (ev.title ?? "—").trimmingCharacters(in: .whitespacesAndNewlines)
        }

        self.allSubjects = grouped
            .map { Subject(name: $0.key,
                           schedule: $0.value.sorted { ($0.startDate ?? .distantPast) < ($1.startDate ?? .distantPast) }) }
            .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
    }

    // Отфильтрованный + отсортированный список: сначала по остаткам (меньше — выше), потом по имени
    var filteredSubjects: [Subject] {
        let base: [Subject]
        if searchText.isEmpty {
            base = allSubjects
        } else {
            base = allSubjects.filter { $0.name.localizedCaseInsensitiveContains(searchText) }
        }

        let now = Date()
        return base.sorted { lhs, rhs in
            let l = upcomingCount(for: lhs, now: now)
            let r = upcomingCount(for: rhs, now: now)
            if l != r { return l < r }
            return lhs.name.localizedCaseInsensitiveCompare(rhs.name) == .orderedAscending
        }
    }

    // Сколько занятий осталось у предмета (включая идущие сейчас)
    func upcomingCount(for subject: Subject, now: Date = Date()) -> Int {
        subject.schedule.reduce(into: 0) { acc, ev in
            if let end = ev.endDate {
                if end >= now { acc += 1 }
            } else if let start = ev.startDate {
                if start >= now { acc += 1 }
            }
        }
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/Providers/TeacherEventsProvider.swift =====
import Foundation

final class TeacherEventsProvider: EventsProviderProtocol {
    // MARK: - Properties
    
    let teacher: Teacher
    private let calendar: Calendar
    private let eventTypeDetector: EventTypeDetector

    // MARK: - Initialization
    
    init(teacher: Teacher,
         calendar: Calendar = .current,
         eventTypeDetector: EventTypeDetector = DefaultEventTypeDetector()) {
        self.teacher = teacher
        self.calendar = calendar
        self.eventTypeDetector = eventTypeDetector
    }

    // MARK: - EventsProviderProtocol
    
    func eventsForDate(_ date: Date) -> [ScheduleEvent] {
        teacher.schedule.filter { ev in
            guard let d = ev.startDate else { return false }
            return calendar.isDate(d, inSameDayAs: date)
        }
    }

    func hasEventsOn(date: Date) -> Bool {
        eventType(on: date) != .none
    }

    func eventType(on date: Date) -> EventDayType {
        let events = eventsForDate(date)
        guard !events.isEmpty else { return .none }
        let allOnline = events.allSatisfy { ev in
            eventTypeDetector.isOnline(remarks: ev.remarks)
        }
        return allOnline ? .onlineOnly : .regular
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/ViewModels/TeacherDetailViewModel.swift =====
import Combine
import Foundation

@MainActor
final class TeacherDetailViewModel: ObservableObject {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            // Константы если понадобятся
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Published Properties
    
    @Published var navigation = WeekNavigationController()
    
    // MARK: - Properties
    
    let teacher: Teacher
    let eventsProvider: EventsProviderProtocol
    
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Initialization
    
    init(teacher: Teacher) {
        self.teacher = teacher
        self.eventsProvider = TeacherEventsProvider(teacher: teacher)
        
        setupNavigationObserver()
    }
    
    private func setupNavigationObserver() {
        navigation.objectWillChange
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/ViewModels/TeachersViewModel.swift =====
import Combine
import Foundation

@MainActor
final class TeachersViewModel: ObservableObject {
    // MARK: - Configuration
    
    struct Configuration {
        struct Constants {
            // Константы если понадобятся
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Published Properties
    
    @Published var searchText = ""
    @Published var allTeachers: [Teacher] = []
    
    // MARK: - Computed Properties
    
    var filteredTeachers: [Teacher] {
        guard !searchText.isEmpty else {
            return allTeachers
        }
        
        return allTeachers.filter { teacher in
            matchesSearchText(teacher)
        }
    }
    
    private func matchesSearchText(_ teacher: Teacher) -> Bool {
        teacher.displayName.localizedCaseInsensitiveContains(searchText) ||
        (teacher.email?.localizedCaseInsensitiveContains(searchText) ?? false)
    }
    
    // MARK: - Public Methods
    
    func updateTeachers(_ teachers: [Teacher]) {
        allTeachers = teachers.sorted { $0.displayName < $1.displayName }
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/Views/TeacherDetailView.swift =====
import SwiftUI

struct TeacherDetailView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let headerSpacing: AppSpacing = .small
            let headerCornerRadius: AppCornerRadius = .xl
            let headerShadowRadius: CGFloat = 12
            let headerShadowY: CGFloat = 4
            let headerBlurOpacity: Double = 0.98
            let headerContentPadding: AppSpacing = .medium
            let bottomInset: CGFloat = 20
            let defaultSafeAreaTop: CGFloat = 47
            let darkFillOpacity: Double = 0.15
            let lightFillOpacity: Double = 0.12
            let darkShadowOpacity: Double = 0.3
            let lightShadowOpacity: Double = 0.25
            let springResponse: Double = 0.3
            let springDamping: Double = 0.7
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties
    
    @StateObject var viewModel: TeacherDetailViewModel
    @State private var headerHeight: CGFloat = 0
    @State private var headerHeightMax: CGFloat = 0
    
    // MARK: - Environment
    
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Computed Properties
    
    private var safeAreaTop: CGFloat {
        UIApplication.shared.connectedScenes
            .compactMap { $0 as? UIWindowScene }
            .first?.windows.first?.safeAreaInsets.top ?? Configuration.constants.defaultSafeAreaTop
    }
    
    private var headerGradientFill: Color {
        let opacity = colorScheme == .dark ? Configuration.constants.darkFillOpacity : Configuration.constants.lightFillOpacity
        return (colorScheme == .dark ? AppColor.purple : AppColor.pink).color(for: colorScheme).opacity(opacity)
    }
    
    private var headerShadowColor: Color {
        let opacity = colorScheme == .dark ? Configuration.constants.darkShadowOpacity : Configuration.constants.lightShadowOpacity
        return (colorScheme == .dark ? AppColor.purple : AppColor.pink).color(for: colorScheme).opacity(opacity)
    }
    
    // MARK: - Body
    
    var body: some View {
//        let _ = db()
        NavigationView {
            ZStack(alignment: .top) {
                contentView
                floatingHeader
                    .zIndex(1)
            }
            .ignoresSafeArea(edges: .top)
            .navigationBarTitleDisplayMode(.inline)
            .toolbarBackground(.hidden, for: .navigationBar)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    doneButton
                }
            }
            .sheet(isPresented: $viewModel.navigation.showingDatePicker) {
                datePickerSheet
            }
            #if DEBUG
            .measurePerformance(name: "TeacherDetailView", category: .viewAppear)
            #endif
        }
    }
    
    // MARK: - Subviews
    
    private var contentView: some View {
        let topInset: CGFloat = headerHeightMax > 0 ? headerHeightMax : AppDimensions.headerMinHeight.value

        return DayScheduleTabView(
            events: viewModel.teacher.schedule,
            daysInWeek: viewModel.navigation.daysInWeek,
            selectedDate: viewModel.navigation.selectedDate,
            onSelectDate: { viewModel.navigation.selectDate($0) },
            showTeacherName: false,
            topInset: topInset,
            bottomInset: Configuration.constants.bottomInset,
            onTeacherTap: nil,
            onNextWeekFromTabView: { viewModel.navigation.nextWeekFromTabView() },
            onPreviousWeekFromTabView: { viewModel.navigation.previousWeekFromTabView() }
        )
        .ignoresSafeArea(edges: .bottom)
    }

    private var floatingHeader: some View {
        RoundedShadowContainer(
            corners: [.bottomLeft, .bottomRight],
            cornerRadius: Configuration.constants.headerCornerRadius.value,
            fill: headerGradientFill,
            blurMaterial: .ultraThinMaterial,
            blurOpacity: Configuration.constants.headerBlurOpacity,
            shadow: ShadowStyle(
                color: headerShadowColor,
                radius: Configuration.constants.headerShadowRadius,
                x: 0,
                y: Configuration.constants.headerShadowY
            ),
            contentInsets: .init(
                top: 0,
                leading: Configuration.constants.headerContentPadding.value,
                bottom: Configuration.constants.headerSpacing.value,
                trailing: Configuration.constants.headerContentPadding.value
            ),
            outerPadding: .init(top: 0, leading: 0, bottom: 0, trailing: 0),
            ignoresSafeAreaEdges: .top
        ) {
            VStack(spacing: Configuration.constants.headerSpacing.value) {
                AppColor.clear.color(for: colorScheme)
                    .frame(height: safeAreaTop)
                
                TeacherHeaderView(
                    teacher: viewModel.teacher,
                    selectedDate: viewModel.navigation.selectedDate,
                    onCalendarTap: { viewModel.navigation.showingDatePicker = true }
                )
                
                WeekSlider(
                    days: viewModel.navigation.daysInWeek,
                    selectedDate: viewModel.navigation.selectedDate,
                    eventDayType: { viewModel.eventsProvider.eventType(on: $0) },
                    onSelectDate: { viewModel.navigation.selectDate($0) },
                    onNextWeekFromSlider: {
                        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
                            viewModel.navigation.nextWeekFromSlider()
                        }
                    },
                    onPreviousWeekFromSlider: {
                        withAnimation(.spring(response: Configuration.constants.springResponse, dampingFraction: Configuration.constants.springDamping)) {
                            viewModel.navigation.previousWeekFromSlider()
                        }
                    }
                )
            }
            .overlay(
                GeometryReader { headerGeo in
                    AppColor.clear.color(for: colorScheme)
                        .preference(
                            key: HeaderHeightKey.self,
                            value: headerGeo.size.height + Configuration.constants.headerSpacing.value
                        )
                }
            )
        }
        .onPreferenceChange(HeaderHeightKey.self) { value in
            guard value > 0 else { return }
            headerHeight = value
            let clamped = ceil(value)
            if clamped > headerHeightMax {
                headerHeightMax = clamped
            }
        }
    }
    
    private var doneButton: some View {
        Button(LocalizedString.generalDone.localized) { dismiss() }
            .themedForeground(.header, colorScheme: colorScheme)
    }
    
    private var datePickerSheet: some View {
        DatePickerSheet(
            selectedDate: $viewModel.navigation.selectedDate,
            onDateSelected: { viewModel.navigation.selectDate($0) },
            eventTypeForDate: { viewModel.eventsProvider.eventType(on: $0) },
        )
        .presentationDetents([.medium])
    }
    
    // MARK: - Preference Key
    
    struct HeaderHeightKey: PreferenceKey {
        static var defaultValue: CGFloat = 0
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
            value = nextValue()
        }
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/Views/TeacherHeaderView.swift =====
import SwiftUI

struct TeacherHeaderView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let spacing: AppSpacing = .medium
            let nameSpacing: AppSpacing = .xxs
            let horizontalPadding: AppSpacing = .large
            let verticalPadding: AppSpacing = .small
            let emailSpacing: AppSpacing = .xs
        }
        
        static let constants = Constants()
    }
    
    // MARK: - Properties

    let teacher: Teacher
    let selectedDate: Date
    let onCalendarTap: () -> Void

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        teacher: Teacher,
        selectedDate: Date,
        onCalendarTap: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.teacher = teacher
        self.selectedDate = selectedDate
        self.onCalendarTap = onCalendarTap
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        HStack(alignment: .center, spacing: Configuration.constants.spacing.value) {
            leftSection
            Spacer()
            calendarButton
        }
        .padding(.horizontal, Configuration.constants.horizontalPadding.value)
        .padding(.vertical, Configuration.constants.verticalPadding.value)
    }
    
    // MARK: - Subviews
    
    private var leftSection: some View {
        VStack(alignment: .leading, spacing: Configuration.constants.nameSpacing.value) {
            Text(teacher.displayName)
                .font(AppTypography.title3.font)
                .fontWeight(.semibold)
                .lineLimit(1)

            HStack(spacing: Configuration.constants.emailSpacing.value) {
                Text(formattedSelectedDate)
                    .font(AppTypography.subheadline.font)
                    .fontWeight(.medium)
                    .themedForeground(.header, colorScheme: colorScheme)

                if let email = teacher.email {
                    Text("•")
                        .font(AppTypography.caption.font)
                        .themedForeground(.header, colorScheme: colorScheme)

                    emailButton(email: email)
                }
            }
        }
    }

    private var formattedSelectedDate: String {
        let formatter = DateFormatter()
        formatter.locale = .current
        formatter.dateFormat = "dd.MM.yyyy"
        return formatter.string(from: selectedDate)
    }
    
    private func emailButton(email: String) -> some View {
        Button(action: {
            copyEmail(email)
        }) {
            HStack(spacing: Configuration.constants.emailSpacing.value) {
                Text(email)
                    .font(AppTypography.caption.font)
                    .lineLimit(1)
                AppIcon.docOnDoc.image()
                    .font(AppTypography.caption2.font)
            }
            .themedForeground(.header, colorScheme: colorScheme)
        }
    }
    
    private var calendarButton: some View {
        Button(action: onCalendarTap) {
            AppIcon.calendar.image()
                .font(AppTypography.title3.font)
                .themedForeground(.header, colorScheme: colorScheme)
        }
    }
    
    // MARK: - Actions
    
    private func copyEmail(_ email: String) {
        UIPasteboard.general.string = email
        hapticService.impact(style: .light)
    }
}

// ===== FILE: Timetable DSW/Features/Teachers/Views/TeachersView.swift =====
import SwiftUI

struct TeachersView: View {
    // MARK: - Configuration
    
    struct Configuration: ComponentConfiguration {
        struct Constants {
            let progressScale: CGFloat = 1.2
            let spacing: AppSpacing = .large
        }

        static let constants = Constants()
    }

    // MARK: - Properties

    @StateObject var viewModel: TeachersViewModel
    @EnvironmentObject var appViewModel: AppViewModel
    @State private var selectedTeacher: Teacher?

    // MARK: - Environment

    @Environment(\.colorScheme) var colorScheme
    @Environment(\.bottomInsetService) private var bottomInsetService
    
    // MARK: - Body
    
    var body: some View {
        NavigationView {
            contentView
                .navigationTitle(LocalizedString.teachersTitle.localized)
                .searchable(text: $viewModel.searchText, placement: .navigationBarDrawer(displayMode: .always), prompt: LocalizedString.teachersSearch.localized)
                .onAppear {
                    if let scheduleData = appViewModel.scheduleData {
                        viewModel.updateTeachers(scheduleData.teachers)
                    }
                }
                .onChange(of: appViewModel.scheduleData) {
                    if let newData = appViewModel.scheduleData {
                        viewModel.updateTeachers(newData.teachers)
                    }
                }
                #if DEBUG
                .measurePerformance(name: "TeachersView", category: .viewAppear)
                #endif
        }
        .sheet(item: $selectedTeacher) { teacher in
            TeacherDetailView(viewModel: TeacherDetailViewModel(teacher: teacher))
        }
    }
    
    // MARK: - Content Views
    
    @ViewBuilder
    private var contentView: some View {
        if appViewModel.isLoadingTeachers {
            loadingView
        } else if appViewModel.scheduleData == nil {
            noDataView
        } else if viewModel.filteredTeachers.isEmpty {
            noResultsView
        } else {
            teachersList
        }
    }
    
    private var loadingView: some View {
        VStack(spacing: Configuration.constants.spacing.value) {
            ProgressView()
                .scaleEffect(Configuration.constants.progressScale)
            Text(LocalizedString.teachersLoading.localized)
                .font(AppTypography.subheadline.font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }
    
    private var noDataView: some View {
        ContentUnavailableView(
            LocalizedString.teachersNoData.localized,
            systemImage: AppIcon.person2Slash.systemName,
            description: Text(LocalizedString.teachersLoadScheduleFirst.localized)
        )
    }
    
    private var noResultsView: some View {
        ContentUnavailableView(
            LocalizedString.teachersNoFound.localized,
            systemImage: AppIcon.magnifyingGlass.systemName,
            description: Text(LocalizedString.groupsAdjustSearch.localized)
        )
    }
    
    private var teachersList: some View {
        List(viewModel.filteredTeachers) { teacher in
            TeacherRow(teacher: teacher) {
                selectedTeacher = teacher
            }
            .listRowInsets(EdgeInsets(
                top: AppSpacing.xs.value,
                leading: AppSpacing.large.value,
                bottom: AppSpacing.xs.value,
                trailing: AppSpacing.large.value
            ))
        }
        .listStyle(.plain)
        .safeAreaInset(edge: .bottom) {
            AppColor.clear.color(for: colorScheme)
                .frame(height: bottomInsetService?.bottomInset ?? 78)
        }
    }
}

// MARK: - Teacher Row

private struct TeacherRow: View {
    // MARK: - Configuration
    
    struct Constants {
        let avatarSize: CGFloat = AppDimensions.avatarLarge.value
        let spacing: AppSpacing = .medium
        let padding: AppSpacing = .medium
        let initialsSize: CGFloat = 18
        let nameSize: CGFloat = 16
        let emailSize: CGFloat = 13
        let countSize: CGFloat = 20
        let classesSize: CGFloat = 11
        let backgroundOpacity: Double = 0.15
        let nameSpacing: AppSpacing = .xxs
        let countSpacing: AppSpacing = .xxs
    }
    
    private let constants = Constants()
    
    // MARK: - Properties
    
    let teacher: Teacher
    let action: () -> Void
    
    // MARK: - Environment
    
    @Environment(\.colorScheme) var colorScheme
    
    // MARK: - Dependencies
    
    private let hapticService: HapticFeedbackService
    
    // MARK: - Initialization
    
    init(
        teacher: Teacher,
        action: @escaping () -> Void,
        hapticService: HapticFeedbackService = DefaultHapticFeedbackService()
    ) {
        self.teacher = teacher
        self.action = action
        self.hapticService = hapticService
    }
    
    // MARK: - Body
    
    var body: some View {
        Button(action: handleTap) {
            HStack(spacing: constants.spacing.value) {
                avatarView
                textContent
                Spacer()
                classesIndicator
            }
            .padding(constants.padding.value)
        }
    }
    
    // MARK: - Subviews
    
    private var avatarView: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors.map { $0.opacity(constants.backgroundOpacity) },
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: constants.avatarSize, height: constants.avatarSize)
            
            Text(initials)
                .font(AppTypography.custom(size: constants.initialsSize, weight: .semibold).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        }
    }
    
    private var textContent: some View {
        VStack(alignment: .leading, spacing: constants.nameSpacing.value) {
            Text(teacher.displayName)
                .font(AppTypography.custom(size: constants.nameSize, weight: .semibold).font)
                .foregroundAppColor(.primaryText, colorScheme: colorScheme)
            
            if let email = teacher.email {
                Text(email)
                    .font(AppTypography.custom(size: constants.emailSize, weight: .regular).font)
                    .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
                    .lineLimit(1)
            }
        }
    }
    
    private var classesIndicator: some View {
        VStack(spacing: constants.countSpacing.value) {
            Text("\(teacher.schedule.count)")
                .font(AppTypography.custom(size: constants.countSize, weight: .bold).font)
                .foregroundStyle(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            
            Text(LocalizedString.teachersClasses.localized)
                .font(AppTypography.custom(size: constants.classesSize, weight: .regular).font)
                .foregroundAppColor(.secondaryText, colorScheme: colorScheme)
        }
    }
    
    // MARK: - Computed Properties
    
    private var initials: String {
        let components = teacher.displayName.split(separator: " ")
        if components.count >= 2 {
            let first = components[0].prefix(1)
            let last = components[1].prefix(1)
            return "\(first)\(last)".uppercased()
        }
        return String(teacher.displayName.prefix(1)).uppercased()
    }
    
    private var gradientColors: [Color] {
        GradientStyle.accent.colors(for: colorScheme)
    }
    
    // MARK: - Actions
    
    private func handleTap() {
        hapticService.impact(style: .light)
        action()
    }
}

// ===== FILE: Timetable DSW/Models/AggregateResponse.swift =====
import Foundation

struct AggregateResponse: Equatable, Codable, Sendable {
    let groupId: Int
    let from: String
    let to: String
    let intervalType: Int
    let groupSchedule: [ScheduleEvent]
    let teachers: [Teacher]
    let fetchedAt: String

    init(groupId: Int, from: String, to: String, intervalType: Int, groupSchedule: [ScheduleEvent], teachers: [Teacher], fetchedAt: String) {
        self.groupId = groupId
        self.from = from
        self.to = to
        self.intervalType = intervalType
        self.groupSchedule = groupSchedule
        self.teachers = teachers
        self.fetchedAt = fetchedAt
    }

    init(from groupSchedule: GroupScheduleResponse, teachers: [Teacher] = []) {
        self.groupId = groupSchedule.groupId
        self.from = groupSchedule.from
        self.to = groupSchedule.to
        self.intervalType = groupSchedule.intervalType
        self.groupSchedule = groupSchedule.groupSchedule
        self.teachers = teachers
        self.fetchedAt = groupSchedule.fetchedAt
    }
}

// ===== FILE: Timetable DSW/Models/GroupInfo.swift =====
import Foundation

struct GroupInfo: Identifiable, Codable, Hashable, Sendable {
    let groupId: Int
    let code: String
    let name: String
    let tracks: [TrackInfo]
    let program: String
    let faculty: String

    var id: Int { groupId }

    var displayName: String {
        "\(code) - \(name)"
    }
}

// ===== FILE: Timetable DSW/Models/GroupScheduleResponse.swift =====
import Foundation

struct GroupScheduleResponse: Equatable, Codable, Sendable {
    // MARK: - Codable
    private enum CodingKeys: String, CodingKey {
        case groupId
        case from
        case to
        case intervalType
        case groupSchedule
        case fetchedAt
    }
    
    static func == (lhs: GroupScheduleResponse, rhs: GroupScheduleResponse) -> Bool {
        lhs.groupId == rhs.groupId
    }
    
    let groupId: Int
    let from: String
    let to: String
    let intervalType: Int
    let groupSchedule: [ScheduleEvent]
    let fetchedAt: String

    init(groupId: Int, from: String, to: String, intervalType: Int, groupSchedule: [ScheduleEvent], fetchedAt: String) {
        self.groupId = groupId
        self.from = from
        self.to = to
        self.intervalType = intervalType
        self.groupSchedule = groupSchedule
        self.fetchedAt = fetchedAt
    }

    // Explicit Codable to avoid synthesis issues when dependent types fail to resolve in some targets
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.groupId = try container.decode(Int.self, forKey: .groupId)
        self.from = try container.decode(String.self, forKey: .from)
        self.to = try container.decode(String.self, forKey: .to)
        self.intervalType = try container.decode(Int.self, forKey: .intervalType)
        self.groupSchedule = try container.decode([ScheduleEvent].self, forKey: .groupSchedule)
        self.fetchedAt = try container.decode(String.self, forKey: .fetchedAt)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(groupId, forKey: .groupId)
        try container.encode(from, forKey: .from)
        try container.encode(to, forKey: .to)
        try container.encode(intervalType, forKey: .intervalType)
        try container.encode(groupSchedule, forKey: .groupSchedule)
        try container.encode(fetchedAt, forKey: .fetchedAt)
    }
}

// ===== FILE: Timetable DSW/Models/ScheduleEvent.swift =====
import Foundation

struct ScheduleEvent: Identifiable, Hashable, Sendable {
    let title: String
    let type: String?
    let startISO: String
    let endISO: String
    let room: String?
    let grading: String?
    let remarks: String?
    let studyTrack: String?
    let groups: String?
    let teacherId: Int?
    let teacherName: String?
    let teacherEmail: String?

    // Даты парсятся один раз при декодировании вместо каждого обращения
    let startDate: Date?
    let endDate: Date?

    private static let dateService = DefaultDateService.shared

    var id: String {
        "\(startISO)_\(title)_\(teacherId ?? 0)"
    }

    var displayRoom: String {
//        guard let room = room, !room.isEmpty, room != "Brak" else {
//            return "online"
//        }
        return room ?? ""
    }
}

// MARK: - Codable

extension ScheduleEvent: Codable {
    enum CodingKeys: String, CodingKey {
        case title, type, startISO, endISO, room, grading, remarks, studyTrack, groups
        case teacherId, teacherName, teacherEmail
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        title = try container.decode(String.self, forKey: .title)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        startISO = try container.decode(String.self, forKey: .startISO)
        endISO = try container.decode(String.self, forKey: .endISO)
        room = try container.decodeIfPresent(String.self, forKey: .room)
        grading = try container.decodeIfPresent(String.self, forKey: .grading)
        remarks = try container.decodeIfPresent(String.self, forKey: .remarks)
        studyTrack = try container.decodeIfPresent(String.self, forKey: .studyTrack)
        groups = try container.decodeIfPresent(String.self, forKey: .groups)
        teacherId = try container.decodeIfPresent(Int.self, forKey: .teacherId)
        teacherName = try container.decodeIfPresent(String.self, forKey: .teacherName)
        teacherEmail = try container.decodeIfPresent(String.self, forKey: .teacherEmail)

        // Парсим даты один раз при декодировании
        startDate = ScheduleEvent.dateService.parseISO8601(startISO)
        endDate = ScheduleEvent.dateService.parseISO8601(endISO)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(title, forKey: .title)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encode(startISO, forKey: .startISO)
        try container.encode(endISO, forKey: .endISO)
        try container.encodeIfPresent(room, forKey: .room)
        try container.encodeIfPresent(grading, forKey: .grading)
        try container.encodeIfPresent(remarks, forKey: .remarks)
        try container.encodeIfPresent(studyTrack, forKey: .studyTrack)
        try container.encodeIfPresent(groups, forKey: .groups)
        try container.encodeIfPresent(teacherId, forKey: .teacherId)
        try container.encodeIfPresent(teacherName, forKey: .teacherName)
        try container.encodeIfPresent(teacherEmail, forKey: .teacherEmail)
        // startDate и endDate не кодируются - они вычисляются из ISO строк
    }
}

extension ScheduleEvent {
    func presentationInfo(detector: EventTypeDetector = DefaultEventTypeDetector()) -> EventPresentationInfo {
        EventPresentationInfo(event: self, detector: detector)
    }

    func isOnline(detector: EventTypeDetector = DefaultEventTypeDetector()) -> Bool {
        presentationInfo(detector: detector).isOnline
    }

    func isCancelled(detector: EventTypeDetector = DefaultEventTypeDetector()) -> Bool {
        presentationInfo(detector: detector).isCancelled
    }

    func eventType(detector: EventTypeDetector = DefaultEventTypeDetector()) -> EventType {
        presentationInfo(detector: detector).kind
    }
}

// ===== FILE: Timetable DSW/Models/Teacher.swift =====
import Foundation

struct Teacher: Identifiable, Codable, Hashable, Sendable {
    let id: Int
    let name: String?
    let title: String?
    let department: String?
    let email: String?
    let phone: String?
    let aboutHTML: String?
    let schedule: [ScheduleEvent]

    var displayName: String {
        name ?? "Unknown Teacher"
    }
}

// ===== FILE: Timetable DSW/Models/TrackInfo.swift =====
import Foundation

struct TrackInfo: Codable, Hashable, Sendable {
    let trackId: Int
    let title: String
}

// ===== FILE: Timetable DSW/Services/Ads/ATTPermissionManager.swift =====
import AppTrackingTransparency

enum ATTPermissionManager {
    @MainActor
    static func requestIfNeeded() async -> ATTrackingManager.AuthorizationStatus {
        let status = ATTrackingManager.trackingAuthorizationStatus
        if status == .notDetermined {
            return await withCheckedContinuation { cont in
                ATTrackingManager.requestTrackingAuthorization { newStatus in
                    cont.resume(returning: newStatus)
                }
            }
        } else {
            return status
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdCoordinator.swift =====
import Combine
import Foundation
import UIKit

protocol AdCoordinator {
    func loadAd(type: AdType) async throws
    func showAd(type: AdType) async throws
    func isAdReady(type: AdType) -> Bool
    func isAdDisabled() -> Bool
    var rewardPublisher: AnyPublisher<Bool, Never> { get }

    // View factories
    func makeBannerView(width: CGFloat) -> UIView
//    func makeNativeAdView() -> UIView

    // Utilities
    func presentAdInspector() async
    func setTestDevices(_ deviceIDs: [String])
}

// ===== FILE: Timetable DSW/Services/Ads/AdEligibilityService.swift =====
protocol AdEligibilityService {
    var canShowAds: Bool { get }
    func checkEligibility() throws
}

// ===== FILE: Timetable DSW/Services/Ads/AdError.swift =====
import Foundation

enum AdError: Error, LocalizedError {
    case notLoaded
    case failedToLoad(Error)
    case failedToPresent(Error)
    case premiumUser
    case adsDisabled
    case noReward
    case timeout
    
    var errorDescription: String? {
        switch self {
        case .notLoaded: return "Ad not loaded yet"
        case .failedToLoad(let error): return "Failed to load: \(error.localizedDescription)"
        case .failedToPresent(let error): return "Failed to present: \(error.localizedDescription)"
        case .premiumUser: return "Ads disabled for premium users"
        case .adsDisabled: return "Ads are currently disabled"
        case .noReward: return "Ad closed before reward"
        case .timeout: return "Operation timeout"
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdLoadingView.swift =====
import SwiftUI

struct AdLoadingView: View {
    let adType: AdType
    let coordinator: AdCoordinator?
    @State private var isLoading = false
    @State private var error: Error?
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView(LocalizedString.adLoadingText.localized)
            } else if let error = error {
                VStack(spacing: 8) {
                    Text(LocalizedString.adLoadingFailed.localized)
                        .font(.caption)
                        .foregroundColor(.red)
                    Button(LocalizedString.adLoadingRetry.localized) {
                        Task { await loadAd() }
                    }
                    .font(.caption)
                }
            } else {
                EmptyView()
            }
        }
        .task {
            await loadAd()
        }
    }
    
    private func loadAd() async {
        guard let coordinator = coordinator else { return }
        isLoading = true
        error = nil
        
        do {
            try await coordinator.loadAd(type: adType)
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdMobCoordinator.swift =====
import Foundation
import Combine
import GoogleMobileAds
import UIKit
import AppTrackingTransparency

@MainActor
final class AdMobCoordinator: AdCoordinator {

    // Dependencies
    private let eligibilityService: AdEligibilityService
    private let viewControllerProvider: ViewControllerProvider
    private let configuration: AdUnitIDsConfiguration

    // Providers cache
    private var interstitialProvider: InterstitialAdProvider?
    private var rewardedProvider: RewardedAdProvider?
    private var rewardedInterstitialProvider: RewardedInterstitialAdProvider?
    private var appOpenProvider: AppOpenAdProvider?
    private var nativeAdProviders: [String: NativeAdProvider] = [:] // Key: identifier

    // State
    private var isPresenting = false
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    private var isStarted = false
    private var consentATT: ATTrackingManager.AuthorizationStatus = .notDetermined


    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }

    init(
        eligibilityService: AdEligibilityService,
        viewControllerProvider: ViewControllerProvider,
        configuration: AdUnitIDsConfiguration
    ) {
        self.eligibilityService = eligibilityService
        self.viewControllerProvider = viewControllerProvider
        self.configuration = configuration
    }

    // MARK: - Public Methods

    func start(afterATT status: ATTrackingManager.AuthorizationStatus) {
        guard !isStarted else { return }
        consentATT = status
        isStarted = true
        MobileAds.shared.start()
    }

    private func ensureStarted() throws {
           guard isStarted else { throw AdError.failedToPresent(NSError(
               domain: "AdCoordinator", code: 2,
               userInfo: [NSLocalizedDescriptionKey: "Ads SDK not started yet (wait for ATT)."]
           )) }
       }


    func isAdDisabled() -> Bool {
        !isStarted || !eligibilityService.canShowAds
    }

    func loadAd(type: AdType) async throws {
        try ensureStarted()
        try eligibilityService.checkEligibility()

        switch type {
        case .interstitial:
            let provider = InterstitialAdProvider(adUnitID: configuration.interstitial)
            try await provider.load()
            interstitialProvider = provider

        case .rewarded:
            let provider = RewardedAdProvider(adUnitID: configuration.rewarded)
            try await provider.load()
            setupRewardPublisher(for: provider)
            rewardedProvider = provider

        case .rewardedInterstitial:
            let provider = RewardedInterstitialAdProvider(adUnitID: configuration.rewardedInterstitial)
            try await provider.load()
            setupRewardPublisher(for: provider)
            rewardedInterstitialProvider = provider

        case .appOpen:
            let provider = AppOpenAdProvider(adUnitID: configuration.appOpen)
            try await provider.load()
            appOpenProvider = provider

        case .native, .banner:
            break
        }
    }

    func showAd(type: AdType) async throws {
        try ensureStarted()
        try eligibilityService.checkEligibility()

        guard !isPresenting else {
            throw AdError.failedToPresent(NSError(
                domain: "AdCoordinator",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Another ad is presenting"]
            ))
        }

        isPresenting = true
        defer { isPresenting = false }

        let viewController = try await viewControllerProvider.acquirePresentingViewController(timeout: 2.0)

        switch type {
        case .interstitial:
            guard let provider = interstitialProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .rewarded:
            guard let provider = rewardedProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .rewardedInterstitial:
            guard let provider = rewardedInterstitialProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .appOpen:
            guard let provider = appOpenProvider else { throw AdError.notLoaded }
            try await provider.present(from: viewController)

        case .banner, .native:
            break
        }
    }

    func isAdReady(type: AdType) -> Bool {
        guard isStarted, eligibilityService.canShowAds else { return false }

        switch type {
        case .interstitial:
            return interstitialProvider?.isReady ?? false
        case .rewarded:
            return rewardedProvider?.isReady ?? false
        case .rewardedInterstitial:
            return rewardedInterstitialProvider?.isReady ?? false
        case .appOpen:
            return appOpenProvider?.isReady ?? false
        case .native:
            return true
        case .banner:
            return true
        }
    }

    // MARK: - Native Ad Methods

    /// Create or get existing native ad provider
    func getNativeAdProvider(identifier: String = "default") -> NativeAdProvider {
        if let existing = nativeAdProviders[identifier] {
            return existing
        }

        let config = NativeAdProvider.Configuration(
            adUnitID: configuration.native,
            cacheSize: 3,
            refreshInterval: 60.0
        )

        let provider = NativeAdProvider(configuration: config)
        nativeAdProviders[identifier] = provider

        return provider
    }

    /// Load native ad for specific identifier
    func loadNativeAd(identifier: String = "default") async throws {
        try eligibilityService.checkEligibility()

        let provider = getNativeAdProvider(identifier: identifier)
        try await provider.load()
    }

    /// Refresh native ad (force reload)
    func refreshNativeAd(identifier: String = "default") async throws {
        try eligibilityService.checkEligibility()

        guard let provider = nativeAdProviders[identifier] else {
            throw AdError.notLoaded
        }

        try await provider.refresh()
    }

    // MARK: - View Factories

    func makeBannerView(width: CGFloat) -> UIView {
        let provider = BannerAdProvider.create(
            width: width,
            adUnitID: configuration.banner,
            viewControllerProvider: viewControllerProvider
        )
        return provider.createView()
    }

    // MARK: - Utilities

    func presentAdInspector() async {
        guard let rootVC = await viewControllerProvider.getRootViewController() else { return }
        MobileAds.shared.presentAdInspector(from: rootVC) { error in
            if let error = error {
                print("[AdInspector] Error: \(error)")
            }
        }
    }

    func setTestDevices(_ deviceIDs: [String]) {
        MobileAds.shared.requestConfiguration.testDeviceIdentifiers = deviceIDs
    }

    // MARK: - Private Helpers

    private func setupRewardPublisher(for provider: RewardableAdProvider) {
        provider.rewardPublisher
            .sink { [weak self] earned in
                self?.rewardSubject.send(earned)
            }
            .store(in: &cancellables)
    }

    private var cancellables = Set<AnyCancellable>()
}

// MARK: - Dependency Injection Helpers

extension AdMobCoordinator {
    static func makeForProduction(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) -> AdMobCoordinator {
        let eligibility = DefaultAdEligibilityService(
            featureFlagService: featureFlagService,
            appStateService: appStateService
        )
        let vcProvider = DefaultViewControllerProvider()

        #if DEBUG
        let config = AdUnitIDsConfiguration.test
        #else
        let config = AdUnitIDsConfiguration.production
        #endif

        return AdMobCoordinator(
            eligibilityService: eligibility,
            viewControllerProvider: vcProvider,
            configuration: config
        )
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdPreloader.swift =====
import SwiftUI

struct AdPreloader: ViewModifier {
    let types: [AdType]
    let coordinator: AdCoordinator?

    func body(content: Content) -> some View {
        content
            .task {
                guard let coordinator = coordinator, !coordinator.isAdDisabled() else { return }

                for type in types {
                    try? await coordinator.loadAd(type: type)
                }
            }
    }
}

extension View {
    func preloadAds(_ types: AdType..., coordinator: AdCoordinator?) -> some View {
        modifier(AdPreloader(types: types, coordinator: coordinator))
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AdProvider.swift =====
import UIKit.UIViewController
import Combine

protocol AdProvider {
    associatedtype AdObject

    var adType: AdType { get }
    var isReady: Bool { get }

    func load() async throws
    func reset()
}

protocol PresentableAdProvider: AdProvider {
    func present(from viewController: UIViewController) async throws
}

protocol RewardableAdProvider: PresentableAdProvider {
    var rewardPublisher: AnyPublisher<Bool, Never> { get }
}

protocol ViewAdProvider: AdProvider {
    associatedtype ViewType
    func createView() -> ViewType
}

// ===== FILE: Timetable DSW/Services/Ads/AdType.swift =====
enum AdType {
    case banner
    case interstitial
    case rewarded
    case rewardedInterstitial
    case native
    case appOpen
}

// ===== FILE: Timetable DSW/Services/Ads/AdUnitIDsConfiguration.swift =====
struct AdUnitIDsConfiguration {
    let rewarded: String
    let interstitial: String
    let banner: String
    let rewardedInterstitial: String
    let appOpen: String
    let native: String

    static let test = AdUnitIDsConfiguration(
        rewarded: "ca-app-pub-3940256099942544/1712485313",
        interstitial: "ca-app-pub-3940256099942544/4411468910",
        banner: "ca-app-pub-3940256099942544/2934735716",
        rewardedInterstitial: "ca-app-pub-3940256099942544/6978759866",
        appOpen: "ca-app-pub-3940256099942544/5662855259",
        native: "ca-app-pub-3940256099942544/3986624511"
    )

    static let production = AdUnitIDsConfiguration(
        rewarded: "ca-app-pub-2195931602320991/5476969834",
        interstitial: "ca-app-pub-2195931602320991/5169848072",
        banner: "ca-app-pub-2195931602320991/9416214847",
        rewardedInterstitial: "YOUR_REWARDED_INTERSTITIAL_AD_UNIT_ID",
        appOpen: "YOUR_APP_OPEN_AD_UNIT_ID",
        native: "YOUR_NATIVE_AD_UNIT_ID"
    )
}

// ===== FILE: Timetable DSW/Services/Ads/AdaptiveBannerView.swift =====
import SwiftUI
import GoogleMobileAds

struct AdaptiveBannerView: View {
    @Environment(\.adCoordinator) private var coordinator
    @State private var bannerHeight: CGFloat = 50

    var body: some View {
        if coordinator?.isAdDisabled() ?? true {
            EmptyView()
        } else {
            GeometryReader { geometry in
                BannerViewRepresentable(
                    coordinator: coordinator,
                    availableWidth: geometry.size.width,
                    onHeightChange: { newHeight in
                        bannerHeight = newHeight
                    }
                )
            }
            .frame(height: bannerHeight)
        }
    }
}

private struct BannerViewRepresentable: UIViewRepresentable {
    let coordinator: AdCoordinator?
    let availableWidth: CGFloat
    let onHeightChange: (CGFloat) -> Void

    func makeUIView(context: Context) -> UIView {
        let container = UIView()
        container.backgroundColor = .clear
        return container
    }

    func updateUIView(_ container: UIView, context: Context) {
        let currentWidth = container.subviews.first?.frame.width ?? 0
        let widthDifference = abs(currentWidth - availableWidth)

        // Обновляем только при значительном изменении
        guard widthDifference > 10 || container.subviews.isEmpty else {
            return
        }

        container.subviews.forEach { $0.removeFromSuperview() }

        guard let coordinator = coordinator, availableWidth > 0 else { return }

        let bannerView = coordinator.makeBannerView(width: availableWidth)
        bannerView.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(bannerView)

        NSLayoutConstraint.activate([
            bannerView.centerXAnchor.constraint(equalTo: container.centerXAnchor),
            bannerView.centerYAnchor.constraint(equalTo: container.centerYAnchor),
            bannerView.widthAnchor.constraint(lessThanOrEqualTo: container.widthAnchor)
        ])

        // Получаем точную высоту
        DispatchQueue.main.async {
            let adSize = currentOrientationAnchoredAdaptiveBanner(width: availableWidth)
            let height = adSize.size.height
            if height > 0 {
                onHeightChange(height)
            }
        }
    }
}

// MARK: - Styled Components

struct CompactBannerAd: View {
    var body: some View {
        AdaptiveBannerView()
            .background(Color(uiColor: .systemBackground))
            .cornerRadius(8)
            .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
    }
}

// ===== FILE: Timetable DSW/Services/Ads/AppOpenAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class AppOpenAdProvider: NSObject, PresentableAdProvider {
    typealias AdObject = AppOpenAd
    
    let adType: AdType = .appOpen
    private let adUnitID: String
    private var ad: AppOpenAd?
    private var loadTime: Date?
    private var lastShownAt: Date?
    private let expirationInterval: TimeInterval = 30 * 60 // 30 минут
    private let cooldownInterval: TimeInterval = 60 // 1 минута
    
    var isReady: Bool {
        guard let loadTime = loadTime, ad != nil else { return false }
        return Date().timeIntervalSince(loadTime) < expirationInterval
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        let loadedAd = try await AppOpenAd.load(with: adUnitID, request: Request())
        ad = loadedAd
        loadTime = Date()
        loadedAd.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard isReady, let ad = ad else { throw AdError.notLoaded }
        
        // Cooldown check
        if let last = lastShownAt, Date().timeIntervalSince(last) < cooldownInterval {
            throw AdError.failedToPresent(NSError(
                domain: "AppOpenAd",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Cooldown period"]
            ))
        }
        
        ad.present(from: viewController)
        lastShownAt = Date()
    }
    
    func reset() {
        ad = nil
        loadTime = nil
    }
}

extension AppOpenAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { await reset() }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { await reset() }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/BannerAdConfiguration.swift =====
import GoogleMobileAds

struct BannerAdConfiguration {
    let adUnitID: String
    let width: CGFloat

    var adSize: AdSize {
        currentOrientationAnchoredAdaptiveBanner(width: width)
    }
}

// ===== FILE: Timetable DSW/Services/Ads/BannerAdProvider.swift =====
import GoogleMobileAds
import UIKit
import Combine

@MainActor
final class BannerAdProvider: NSObject, ViewAdProvider {
    typealias AdObject = BannerView
    typealias ViewType = UIView

    let adType: AdType = .banner
    private let configuration: BannerAdConfiguration
    private let viewControllerProvider: ViewControllerProvider

    private weak var bannerView: BannerView?

    var isReady: Bool { bannerView != nil }

    init(
        configuration: BannerAdConfiguration,
        viewControllerProvider: ViewControllerProvider
    ) {
        self.configuration = configuration
        self.viewControllerProvider = viewControllerProvider
        super.init()
    }

    func load() async throws {
        // Banner loads automatically when view is created
    }

    func createView() -> UIView {
        // Create banner view
        let banner = BannerView(adSize: configuration.adSize)
        banner.adUnitID = configuration.adUnitID
        banner.delegate = self
        banner.translatesAutoresizingMaskIntoConstraints = false

        self.bannerView = banner

        // Get root view controller and load ad
        Task { @MainActor in
            banner.rootViewController = await viewControllerProvider.getTopMostViewController()
            banner.load(Request())
        }

        return banner
    }

    func reset() {
        bannerView = nil
    }
}

// MARK: - Banner View Delegate

extension BannerAdProvider: BannerViewDelegate {
    nonisolated func bannerViewDidReceiveAd(_ bannerView: BannerView) {
        print("[Banner] Ad received, size: \(bannerView.adSize.size)")
    }

    nonisolated func bannerView(_ bannerView: BannerView, didFailToReceiveAdWithError error: Error) {
        print("[Banner] Failed to receive ad: \(error.localizedDescription)")
    }

    nonisolated func bannerViewDidRecordImpression(_ bannerView: BannerView) {
        print("[Banner] Impression recorded")
    }

    nonisolated func bannerViewWillPresentScreen(_ bannerView: BannerView) {
        print("[Banner] Will present screen")
    }

    nonisolated func bannerViewDidDismissScreen(_ bannerView: BannerView) {
        print("[Banner] Did dismiss screen")
    }
}

extension BannerAdProvider {
    /// Factory method for easy creation
    static func create(
        width: CGFloat,
        adUnitID: String = "ca-app-pub-3940256099942544/2934735716",
        viewControllerProvider: ViewControllerProvider
    ) -> BannerAdProvider {
        let config = BannerAdConfiguration(
            adUnitID: adUnitID,
            width: width
        )
        return BannerAdProvider(
            configuration: config,
            viewControllerProvider: viewControllerProvider
        )
    }
}

// ===== FILE: Timetable DSW/Services/Ads/DefaultAdEligibilityService.swift =====
final class DefaultAdEligibilityService: AdEligibilityService {
    private let featureFlagService: FeatureFlagService
    private let appStateService: AppStateService
    
    var canShowAds: Bool {
        !appStateService.isPremium && featureFlagService.isEnabled(.showAds)
    }
    
    init(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) {
        self.featureFlagService = featureFlagService
        self.appStateService = appStateService
    }
    
    func checkEligibility() throws {
        if appStateService.isPremium {
            throw AdError.premiumUser
        }
        if !featureFlagService.isEnabled(.showAds) {
            throw AdError.adsDisabled
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/DefaultViewControllerProvider.swift =====
import UIKit

@MainActor
final class DefaultViewControllerProvider: ViewControllerProvider {
    func getRootViewController() async -> UIViewController? {
        UIApplication.shared.connectedScenes
            .compactMap { $0 as? UIWindowScene }
            .first(where: { $0.activationState == .foregroundActive })?
            .windows
            .first(where: { $0.isKeyWindow })?
            .rootViewController
    }
    
    func getTopMostViewController() async -> UIViewController? {
        guard let root = await getRootViewController() else { return nil }
        
        var top = root
        while true {
            if let presented = top.presentedViewController, !presented.isBeingDismissed {
                top = presented
            } else if let nav = top as? UINavigationController, let visible = nav.visibleViewController {
                top = visible
            } else if let tab = top as? UITabBarController, let selected = tab.selectedViewController {
                top = selected
            } else if let split = top as? UISplitViewController, let last = split.viewControllers.last {
                top = last
            } else {
                break
            }
        }
        return top
    }
    
    func acquirePresentingViewController(timeout: TimeInterval = 2.0) async throws -> UIViewController {
        let start = Date()
        while Date().timeIntervalSince(start) < timeout {
            if let vc = await getTopMostViewController(),
               vc.presentedViewController == nil,
               !vc.isBeingPresented,
               !vc.isBeingDismissed,
               vc.view.window != nil {
                return vc
            }
            try? await Task.sleep(nanoseconds: 100_000_000)
        }
        throw AdError.timeout
    }
}

// ===== FILE: Timetable DSW/Services/Ads/InterstitialAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class InterstitialAdProvider: NSObject, PresentableAdProvider {
    typealias AdObject = InterstitialAd
    
    let adType: AdType = .interstitial
    private let adUnitID: String
    private var ad: InterstitialAd?
    
    var isReady: Bool { ad != nil }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            InterstitialAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        ad.present(from: viewController)
    }
    
    func reset() {
        ad = nil
    }
}

extension InterstitialAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { await reset() }
    }

    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { await reset() }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/InterstitialCooldownManager.swift =====
import Foundation

@MainActor
final class InterstitialCooldownManager {
    // MARK: - Configuration

    struct Configuration {
        let cooldownInterval: TimeInterval
        let actionsBeforeShow: Int

        static let weekSwitch = Configuration(
            cooldownInterval: 300, // 5 minutes
            actionsBeforeShow: 3   // Show after every 3 week switches
        )
    }

    // MARK: - Properties

    private let configuration: Configuration
    private var lastShowTime: Date?
    private var actionCounter: Int = 0

    // MARK: - Initialization

    init(configuration: Configuration) {
        self.configuration = configuration
    }

    // MARK: - Public Methods

    func shouldShowAd() -> Bool {
        let timePassed = checkTimeCooldown()
        let actionsPassed = checkActionCounter()

        return timePassed && actionsPassed
    }

    func recordAction() {
        actionCounter += 1
    }

    func recordAdShown() {
        lastShowTime = Date()
        actionCounter = 0
    }

    func reset() {
        lastShowTime = nil
        actionCounter = 0
    }

    // MARK: - Private Methods

    private func checkTimeCooldown() -> Bool {
        guard let lastShow = lastShowTime else {
            return true
        }

        let elapsed = Date().timeIntervalSince(lastShow)
        return elapsed >= configuration.cooldownInterval
    }

    private func checkActionCounter() -> Bool {
        return actionCounter >= configuration.actionsBeforeShow
    }
}

// ===== FILE: Timetable DSW/Services/Ads/Native/NativeAdView.swift =====
// ===== FILE: Services/Ads/Native/NativeAdView.swift =====

import GoogleMobileAds
import SwiftUI

struct NativeAdViewRepresentable: UIViewRepresentable {
    public typealias UIViewType = NativeAdView
    
    @ObservedObject var nativeViewModel: NativeAdViewModel
    var style: NativeAdViewStyle
    
    init(nativeViewModel: NativeAdViewModel, style: NativeAdViewStyle = .card) {
        self.nativeViewModel = nativeViewModel
        self.style = style
    }
    
    public func makeUIView(context: Context) -> NativeAdView {
        return style.view
    }
    
    func removeCurrentSizeConstraints(from mediaView: UIView) {
        mediaView.constraints.forEach { constraint in
            if constraint.firstAttribute == .width || constraint.firstAttribute == .height {
                mediaView.removeConstraint(constraint)
            }
        }
    }
    
    public func updateUIView(_ nativeAdView: NativeAdView, context: Context) {
        guard let nativeAd = nativeViewModel.nativeAd else { return }
        
        // Media View
        if let mediaView = nativeAdView.mediaView {
            mediaView.contentMode = .scaleAspectFill
            mediaView.clipsToBounds = true

            let aspectRatio = nativeAd.mediaContent.aspectRatio

            debugPrint("Google aspectRatio: \(aspectRatio), hasVideoContent: \(nativeAd.mediaContent.hasVideoContent)")
            
            if style == .largeBanner {
                removeCurrentSizeConstraints(from: mediaView)
                if aspectRatio > 0 {
                    if aspectRatio > 1 {
                        mediaView.widthAnchor.constraint(equalTo: mediaView.heightAnchor, multiplier: aspectRatio).isActive = true
                    } else {
                        mediaView.widthAnchor.constraint(equalTo: mediaView.heightAnchor, multiplier: 1).isActive = true
                    }
                } else {
                    mediaView.widthAnchor.constraint(equalTo: mediaView.heightAnchor, multiplier: 16/9).isActive = true
                }
            }
            nativeAdView.mediaView?.mediaContent = nativeAd.mediaContent
        }


        // headline require
        (nativeAdView.headlineView as? UILabel)?.text = nativeAd.headline
        
        // body
        (nativeAdView.bodyView as? UILabel)?.text = nativeAd.body
        nativeAdView.bodyView?.isHidden = nativeAd.body == nil
        
        // icon
        (nativeAdView.iconView as? UIImageView)?.image = nativeAd.icon?.image
        nativeAdView.iconView?.isHidden = (nativeAd.icon == nil)
        
        // ratting
        let starRattingImage = imageOfStars(from: nativeAd.starRating)
        (nativeAdView.starRatingView as? UIImageView)?.image = starRattingImage
        nativeAdView.starRatingView?.isHidden = (starRattingImage == nil)
        
        // store
        (nativeAdView.storeView as? UILabel)?.text = nativeAd.store
        nativeAdView.storeView?.isHidden = nativeAd.store == nil
        
        // price
        (nativeAdView.priceView as? UILabel)?.text = nativeAd.price
        nativeAdView.priceView?.isHidden = nativeAd.price == nil
        
        // advertiser
        (nativeAdView.advertiserView as? UILabel)?.text = nativeAd.advertiser
        nativeAdView.advertiserView?.isHidden = (nativeAd.advertiser == nil)
        
        // button
        (nativeAdView.callToActionView as? UIButton)?.setTitle(nativeAd.callToAction, for: .normal)
        nativeAdView.callToActionView?.isHidden = nativeAd.callToAction == nil
        nativeAdView.callToActionView?.isUserInteractionEnabled = false
        
        if style == .largeBanner, let body = nativeAd.body, body.count > 0 {
            nativeAdView.callToActionView?.isHidden = true
        }
        
        // КРИТИЧНО: Связываем view с ad ПОСЛЕДНИМ
        nativeAdView.nativeAd = nativeAd
    }

//    func updateUIView(_ nativeAdView: NativeAdView, context: Context) {
//      guard let nativeAd = nativeViewModel.nativeAd else { return }
//
//      // Each UI property is configurable using your native ad.
//      (nativeAdView.headlineView as? UILabel)?.text = nativeAd.headline
//
//      nativeAdView.mediaView?.mediaContent = nativeAd.mediaContent
//
//      (nativeAdView.bodyView as? UILabel)?.text = nativeAd.body
//
//      (nativeAdView.iconView as? UIImageView)?.image = nativeAd.icon?.image
//
//      (nativeAdView.starRatingView as? UIImageView)?.image = imageOfStars(from: nativeAd.starRating)
//
//      (nativeAdView.storeView as? UILabel)?.text = nativeAd.store
//
//      (nativeAdView.priceView as? UILabel)?.text = nativeAd.price
//
//      (nativeAdView.advertiserView as? UILabel)?.text = nativeAd.advertiser
//
//      (nativeAdView.callToActionView as? UIButton)?.setTitle(nativeAd.callToAction, for: .normal)
//
//      // For the SDK to process touch events properly, user interaction should be disabled.
//      nativeAdView.callToActionView?.isUserInteractionEnabled = false
//
//      // Associate the native ad view with the native ad object. This is required to make the ad
//      // clickable.
//      // Note: this should always be done after populating the ad views.
//      nativeAdView.nativeAd = nativeAd
//    }

    func imageOfStars(from starRating: NSDecimalNumber?) -> UIImage? {
        guard let rating = starRating?.doubleValue else {
            return nil
        }
        
        // Используйте Bundle.main для ваших assets или создайте изображения
        // Для тестирования можно использовать SF Symbols
        if rating >= 5 {
            return UIImage(named: "stars_5")
        } else if rating >= 4.5 {
            return UIImage(named: "stars_4_5")
        } else if rating >= 4 {
            return UIImage(named: "stars_4")
        } else if rating >= 3.5 {
            return UIImage(named: "stars_3_5")
        }
        
        return nil
    }
}

// ===== FILE: Timetable DSW/Services/Ads/Native/NativeAdViewClasses.swift =====
// ===== FILE: Services/Ads/Native/NativeAdViewClasses.swift =====

import GoogleMobileAds
import UIKit
import LBTATools
import SwiftUI

// MARK: - NativeAdViewStyle enum

public enum NativeAdViewStyle {
    /// у меня неправильный
    case basic
        /// баннер с кнопкой и видео
    case card
        /// обычный баннер
    case banner
        /// странный, как будто только для горизонтали
    case largeBanner
    
    var view: NativeAdView {
        switch self {
        case .basic:
            return NativeAdBasicView1(frame: .zero)
        case .card:
            return NativeAdCardView1(frame: .zero)
        case .banner:
            return NativeAdBannerView(frame: .zero)
        case .largeBanner:
            return NativeLargeAdBannerView(frame: .zero)
        }
    }
}

// MARK: - NativeAdCardView (главный стиль)

class NativeAdCardView: NativeAdView {
    
    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 10, weight: .semibold), textColor: .white)
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 17, weight: .medium), textColor: .label)
    let myMediaView = MediaView()
    let callToActionButton = UIButton(title: "", titleColor: .white, font: .boldSystemFont(ofSize: 18), backgroundColor: UIColor(hex: "#3871E0"), target: nil, action: nil)
    let iconImageView = UIImageView()
    let bodyLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)
    let starRatingImageView = UIImageView()
    let advertiserLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    func setupViews() {
        self.headlineView = headlineLabel
        self.advertiserView = advertiserLabel
        
        myMediaView.translatesAutoresizingMaskIntoConstraints = false
        myMediaView.heightAnchor.constraint(equalTo: myMediaView.widthAnchor, multiplier: 9.0/16.0).isActive = true
        self.mediaView = myMediaView
        
        callToActionButton.isUserInteractionEnabled = false
        callToActionButton.layer.cornerRadius = 8
        callToActionButton.clipsToBounds = true
        self.callToActionView = callToActionButton
        
        iconImageView.layer.cornerRadius = 4
        iconImageView.clipsToBounds = true
        iconImageView.withWidth(40).withHeight(40)
        self.iconView = iconImageView
        
        bodyLabel.numberOfLines = 2
        bodyLabel.isUserInteractionEnabled = false
        bodyLabel.textColor = .secondaryLabel
        self.bodyView = bodyLabel
        
        starRatingImageView.withWidth(100).withHeight(17)
        self.starRatingView = starRatingImageView
        
        adTag.withWidth(25)
        adTag.textAlignment = .center
        adTag.backgroundColor = UIColor(hex: "FFCC66")
        adTag.layer.cornerRadius = 2
        adTag.clipsToBounds = true
        adTag.text = "AD"
        
        // ТОЧНАЯ ВЕРСТКА из рабочего примера
        let starRattingStack = hstack(adTag, starRatingImageView, advertiserLabel, UIView(), spacing: 4)
        let headlineStarStack = stack(headlineLabel, starRattingStack, spacing: 8)
        let iconHeadlineStack = hstack(stack(iconImageView), headlineStarStack, UIView(), spacing: 8)
        let buttonStack = hstack(callToActionButton.withHeight(39)).withMargins(.init(top: 0, left: 10, bottom: 0, right: 10))
        let bottomStack = stack(iconHeadlineStack, bodyLabel, buttonStack, spacing: 8).withMargins(.allSides(10))
        stack(myMediaView, bottomStack)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

class NativeAdCardView1: NativeAdView {

    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 10, weight: .semibold), textColor: .white)
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 17, weight: .medium), textColor: .label)
    let myMediaView = MediaView()
    let callToActionButton = UIButton(title: "", titleColor: .white, font: .boldSystemFont(ofSize: 18), backgroundColor: UIColor(hex: "#3871E0"), target: nil, action: nil)
    let iconImageView = UIImageView()
    let bodyLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)
    let advLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)
    let storeLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)
    let starRatingImageView = UIImageView()
//    let advertiserLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .label)

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }

    func setupViews() {
        self.headlineView = headlineLabel

        myMediaView.translatesAutoresizingMaskIntoConstraints = false
        myMediaView.heightAnchor.constraint(equalTo: myMediaView.widthAnchor, multiplier: 9.0/16.0).isActive = true
        self.mediaView = myMediaView

        callToActionButton.isUserInteractionEnabled = false
        callToActionButton.layer.cornerRadius = 8
        callToActionButton.clipsToBounds = true
        callToActionButton.withHeight(39)
        self.callToActionView = callToActionButton

        iconImageView.layer.cornerRadius = 4
        iconImageView.clipsToBounds = true
        iconImageView.withWidth(90).withHeight(90)
        self.iconView = iconImageView

//        advLabel.numberOfLines = 2
//        advLabel.isUserInteractionEnabled = false
//        advLabel.textColor = .secondaryLabel
        self.advertiserView = advLabel
        self.storeView = storeLabel

        bodyLabel.numberOfLines = 2
        bodyLabel.isUserInteractionEnabled = false
        bodyLabel.textColor = .secondaryLabel
        self.bodyView = bodyLabel

        bodyLabel.numberOfLines = 2
        bodyLabel.isUserInteractionEnabled = false
        bodyLabel.textColor = .secondaryLabel
        self.bodyView = bodyLabel

//        starRatingImageView.withWidth(100).withHeight(17)
        starRatingImageView.withHeight(17)
        starRatingImageView.contentMode = .left
        self.starRatingView = starRatingImageView

        adTag.withWidth(25)
        adTag.textAlignment = .center
        adTag.backgroundColor = UIColor(hex: "FFCC66")
        adTag.layer.cornerRadius = 2
        adTag.clipsToBounds = true
        adTag.text = "AD"

        // ТОЧНАЯ ВЕРСТКА из рабочего примера
//        let starRattingStack = hstack(adTag, starRatingImageView, advertiserLabel, UIView(), spacing: 4)
//        let headlineStarStack = stack(headlineLabel, starRattingStack, spacing: 8)
//        let iconHeadlineStack = hstack(stack(iconImageView), headlineStarStack, UIView(), spacing: 8)
//        let buttonStack = hstack(callToActionButton.withHeight(39)).withMargins(.init(top: 0, left: 10, bottom: 0, right: 10))
//        let bottomStack = stack(iconHeadlineStack, bodyLabel, buttonStack, spacing: 8).withMargins(.allSides(10))
//        stack(myMediaView, bottomStack)

        let adOrStoreStack = hstack(advLabel, storeLabel, spacing: 8)
        let adStack = hstack(adTag, starRatingImageView, spacing: 8)
        let infoStack = stack(adStack, headlineLabel, adOrStoreStack).withMargins(.init(top: 0, left: 16, bottom: 8, right: 16))

        let imageInfoStack = hstack(iconImageView, infoStack)
//        let topStack = stack(imageInfoStack, bodyLabel)
        stack(imageInfoStack, bodyLabel, myMediaView, callToActionButton, distribution: .equalSpacing)
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// MARK: - NativeAdBannerView (горизонтальный)

class NativeAdBannerView: NativeAdView {
    
    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 11, weight: .semibold), textColor: .white, textAlignment: .center)
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 15, weight: .medium), textColor: .label)
    let iconImageView = UIImageView()
    let bodyLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel)
    let starRatingImageView = UIImageView()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    func setupViews() {
        self.headlineView = headlineLabel
        self.iconView = iconImageView
        self.bodyView = bodyLabel
        
        adTag.withWidth(20)
        adTag.backgroundColor = UIColor(hex: "FFCC66")
        adTag.layer.cornerRadius = 2
        adTag.clipsToBounds = true
        
        // config 1:1
        iconImageView.heightAnchor.constraint(equalTo: iconImageView.widthAnchor, multiplier: 1).isActive = true
        iconImageView.layer.cornerRadius = 4
        iconImageView.clipsToBounds = true
        
        headlineLabel.numberOfLines = 1
        headlineLabel.lineBreakMode = .byWordWrapping
        
        bodyLabel.numberOfLines = 2
        bodyLabel.lineBreakMode = .byWordWrapping
        
        // ТОЧНАЯ ВЕРСТКА из рабочего примера
        let headerStack = hstack(headlineLabel, adTag)
        let leftStack = stack(headerStack, bodyLabel)
        
        hstack(leftStack, iconImageView, spacing: 8).withMargins(.allSides(8))
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// MARK: - NativeLargeAdBannerView (большой горизонтальный)

class NativeLargeAdBannerView: NativeAdView {
    // require
    let myMediaView = MediaView()
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 15, weight: .medium), textColor: .label, numberOfLines: 2)
    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 10, weight: .semibold), textColor: .secondaryLabel, textAlignment: .center)
    
    // for web
    let advertiserLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel, numberOfLines: 1)
    let bodyLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel, numberOfLines: 3)
    
    // for app
    let callToActionButton = UIButton(title: "", titleColor: .label, font: .boldSystemFont(ofSize: 14), backgroundColor: .systemBlue, target: nil, action: nil)
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    func setupViews() {
        myMediaView.translatesAutoresizingMaskIntoConstraints = false
        myMediaView.widthAnchor.constraint(equalTo: myMediaView.heightAnchor, multiplier: 16/9).isActive = true
        myMediaView.contentMode = .scaleAspectFill
        myMediaView.clipsToBounds = true
        self.mediaView = myMediaView

        self.headlineView = headlineLabel
        self.advertiserView = advertiserLabel
        self.bodyView = bodyLabel
        
        callToActionButton.isUserInteractionEnabled = false
        callToActionButton.layer.cornerRadius = 8
        callToActionButton.clipsToBounds = true
        self.callToActionView = callToActionButton
        
        // ТОЧНАЯ ВЕРСТКА из рабочего примера
        let leftStack = stack(headlineLabel, advertiserLabel, bodyLabel, callToActionButton).withMargins(.init(top: 8, left: 0, bottom: 8, right: 8))

        hstack(myMediaView, leftStack, spacing: 8)
        
        // AD Tag Label
        addSubview(adTag)
        adTag.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            adTag.topAnchor.constraint(equalTo: topAnchor, constant: 4),
            adTag.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 4),
            adTag.widthAnchor.constraint(greaterThanOrEqualToConstant: 25),
            adTag.heightAnchor.constraint(equalToConstant: 15)
        ])
        
        adTag.backgroundColor = .systemFill
        adTag.layer.cornerRadius = 4
        adTag.clipsToBounds = true
        adTag.text = "AD"
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// MARK: - NativeAdBasicView (базовый стиль)

class NativeAdBasicView: NativeAdView {
    
    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 10, weight: .semibold), textColor: .white)
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 17, weight: .medium), textColor: .label)
    let iconImageView = UIImageView()
    let bodyLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel)
    let callToActionButton = UIButton(title: "", titleColor: .white, font: .boldSystemFont(ofSize: 18), backgroundColor: UIColor(hex: "#3871E0"), target: nil, action: nil)
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    func setupViews() {
        self.headlineView = headlineLabel
        self.iconView = iconImageView
        self.bodyView = bodyLabel
        self.callToActionView = callToActionButton
        
        adTag.withWidth(25)
        adTag.textAlignment = .center
        adTag.backgroundColor = UIColor(hex: "FFCC66")
        adTag.layer.cornerRadius = 2
        adTag.clipsToBounds = true
        adTag.text = "AD"
        
        iconImageView.layer.cornerRadius = 4
        iconImageView.clipsToBounds = true
        iconImageView.withWidth(40).withHeight(40)
        
        headlineLabel.numberOfLines = 2
        bodyLabel.numberOfLines = 2
        bodyLabel.textColor = .secondaryLabel
        
        callToActionButton.isUserInteractionEnabled = false
        callToActionButton.layer.cornerRadius = 8
        callToActionButton.clipsToBounds = true
        
        // Simple vertical layout
        let topStack = hstack(adTag, UIView()).withMargins(.init(top: 8, left: 10, bottom: 0, right: 10))
        let iconHeadlineStack = hstack(iconImageView, headlineLabel, spacing: 8).withMargins(.init(top: 8, left: 10, bottom: 0, right: 10))
        let bodyStack = bodyLabel//.withMargins(.init(top: 8, left: 10, bottom: 0, right: 10))
        let buttonStack = hstack(callToActionButton.withHeight(44)).withMargins(.init(top: 8, left: 10, bottom: 12, right: 10))
        
        stack(topStack, iconHeadlineStack, bodyStack, buttonStack, spacing: 0)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

class NativeAdBasicView1: NativeAdView {

    let adTag: UILabel = UILabel(text: "AD", font: .systemFont(ofSize: 10, weight: .semibold), textColor: .white)
    let headlineLabel = UILabel(text: "", font: .systemFont(ofSize: 17, weight: .medium), textColor: .label)
    let iconImageView = UIImageView()
    let advLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel)
    let storeLabel = UILabel(text: "", font: .systemFont(ofSize: 14, weight: .regular), textColor: .secondaryLabel)
    let callToActionButton = UIButton(title: "", titleColor: .white, font: .boldSystemFont(ofSize: 18), backgroundColor: UIColor(hex: "#3871E0"), target: nil, action: nil)

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }

    func setupViews() {
        self.headlineView = headlineLabel
        self.iconView = iconImageView
        self.storeView = storeLabel
        self.advertiserView = advLabel
        self.callToActionView = callToActionButton

        adTag.withWidth(25)
        adTag.textAlignment = .center
        adTag.backgroundColor = UIColor(hex: "FFCC66")
        adTag.layer.cornerRadius = 2
        adTag.clipsToBounds = true
        adTag.text = "AD"

        iconImageView.layer.cornerRadius = 4
        iconImageView.clipsToBounds = true
        iconImageView.contentMode = .scaleAspectFit
//        iconImageView.withHeight(40)

        headlineLabel.numberOfLines = 2
        storeLabel.numberOfLines = 2
        storeLabel.textColor = .secondaryLabel
        advLabel.numberOfLines = 2
        advLabel.textColor = .secondaryLabel

        callToActionButton.isUserInteractionEnabled = false
        callToActionButton.layer.cornerRadius = 8
        callToActionButton.clipsToBounds = true

        // Simple vertical layout
        let storeOrAdvStack = stack(storeLabel, advLabel)
        let infoSubStack = hstack(adTag, storeOrAdvStack, spacing: 5)
        let textStack = stack(headlineLabel, infoSubStack, spacing: 5)
        let infoStack = stack(textStack, callToActionButton, spacing: 10, distribution: .fillEqually)
        hstack(iconImageView, infoStack, spacing: 10).withMargins(.init(top: 8, left: 8, bottom: 8, right: 8))

    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// MARK: - UIColor Extension (из рабочего примера)

extension UIColor {
    convenience init(hex: String, alpha: CGFloat = 1.0) {
        var hexFormatted: String = hex.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        hexFormatted = hexFormatted.replacingOccurrences(of: "#", with: "")
        
        assert(hexFormatted.count == 6, "Invalid hex code used.")
        
        var rgbValue: UInt64 = 0
        Scanner(string: hexFormatted).scanHexInt64(&rgbValue)
        
        self.init(
            red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0,
            green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0,
            blue: CGFloat(rgbValue & 0x0000FF) / 255.0,
            alpha: alpha
        )
    }
}

//#Preview {
//    VStack {
//        NativeAdCardView()
//        NativeAdBannerView()
//        NativeAdCardView()
//    }
//}

// ===== FILE: Timetable DSW/Services/Ads/Native/NativeAdViewModel.swift =====
import SwiftUI
import GoogleMobileAds
import Combine

@MainActor
class NativeAdViewModel: NSObject, ObservableObject, NativeAdLoaderDelegate {
    @Published public var nativeAd: NativeAd?
    @Published public var isLoading: Bool = false

    private var adLoader: AdLoader!
    private var adUnitID: String
    private var lastRequestTime: Date?
    public var requestInterval: Int

    // Static кэш как в рабочем примере
    private static var cachedAds: [String: NativeAd] = [:]
    private static var lastRequestTimes: [String: Date] = [:]

    public init(adUnitID: String = "ca-app-pub-3940256099942544/3986624511", requestInterval: Int = 1 * 60) {
        self.adUnitID = adUnitID
        self.requestInterval = requestInterval
        super.init()

        // ✅ Устанавливаем из кэша при инициализации
        self.nativeAd = NativeAdViewModel.cachedAds[adUnitID]
        self.lastRequestTime = NativeAdViewModel.lastRequestTimes[adUnitID]
    }

    public func refreshAd() {
        let now = Date()

        // ✅ ИСПРАВЛЕНИЕ: Явно переустанавливаем из кэша при rate limiting
        if let cachedAd = NativeAdViewModel.cachedAds[adUnitID],
           let lastRequest = lastRequestTime,
           now.timeIntervalSince(lastRequest) < Double(requestInterval) {

            let remaining = Int(Double(requestInterval) - now.timeIntervalSince(lastRequest))
            print("[NativeAd] Rate limited. Using cached ad. Wait \(remaining)s before new request.")

            // ✅ КРИТИЧНО: Переустанавливаем из кэша чтобы триггернуть SwiftUI update
            self.nativeAd = cachedAd

            // ✅ Явно триггерим обновление (на случай если это тот же объект)
            objectWillChange.send()

            return
        }

        guard !isLoading else {
            print("[NativeAd] Already loading, request canceled.")
            return
        }

        isLoading = true
        lastRequestTime = now
        NativeAdViewModel.lastRequestTimes[adUnitID] = now

        let adViewOptions = NativeAdViewAdOptions()
        adViewOptions.preferredAdChoicesPosition = .topRightCorner
        adLoader = AdLoader(adUnitID: adUnitID, rootViewController: nil, adTypes: [.native], options: [adViewOptions])
        adLoader.delegate = self
        adLoader.load(Request())
    }

    public func adLoader(_ adLoader: AdLoader, didReceive nativeAd: NativeAd) {
        print("[NativeAd] Loaded successfully")

        self.nativeAd = nativeAd
        nativeAd.delegate = self
        self.isLoading = false

        // Кэшируем
        NativeAdViewModel.cachedAds[adUnitID] = nativeAd

        // Setup video delegate
        nativeAd.mediaContent.videoController.delegate = self
    }

    public func adLoader(_ adLoader: AdLoader, didFailToReceiveAdWithError error: Error) {
        print("[NativeAd] Failed: \(error.localizedDescription)")
        self.isLoading = false
    }
}

// MARK: - Delegates

extension NativeAdViewModel: VideoControllerDelegate {
    public func videoControllerDidPlayVideo(_ videoController: VideoController) {
        print("[NativeAd] Video started playing")
    }

    public func videoControllerDidPauseVideo(_ videoController: VideoController) {
        print("[NativeAd] Video paused")
    }

    public func videoControllerDidEndVideoPlayback(_ videoController: VideoController) {
        print("[NativeAd] Video ended")
    }

    public func videoControllerDidMuteVideo(_ videoController: VideoController) {
        print("[NativeAd] Video muted")
    }

    public func videoControllerDidUnmuteVideo(_ videoController: VideoController) {
        print("[NativeAd] Video unmuted")
    }
}

extension NativeAdViewModel: NativeAdDelegate {
    public func nativeAdDidRecordClick(_ nativeAd: NativeAd) {
        print("[NativeAd] Click recorded")
    }

    public func nativeAdDidRecordImpression(_ nativeAd: NativeAd) {
        print("[NativeAd] Impression recorded")
    }

    public func nativeAdWillPresentScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Will present screen")
    }

    public func nativeAdWillDismissScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Will dismiss screen")
    }

    public func nativeAdDidDismissScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Did dismiss screen")
    }
}

// ===== FILE: Timetable DSW/Services/Ads/Native/NativeAdViewModelKey.swift =====
// ===== FILE: Services/Ads/Native/NativeAdViewSui.swift =====

import SwiftUI
import GoogleMobileAds

// MARK: - Environment Key для NativeAdViewModel

private struct NativeAdViewModelKey: EnvironmentKey {
    static let defaultValue: NativeAdViewModel? = nil
}

extension EnvironmentValues {
    var nativeAdViewModel: NativeAdViewModel? {
        get { self[NativeAdViewModelKey.self] }
        set { self[NativeAdViewModelKey.self] = newValue }
    }
}

extension View {
    func nativeAdViewModel(_ viewModel: NativeAdViewModel) -> some View {
        environment(\.nativeAdViewModel, viewModel)
    }
}

// MARK: - NativeAdViewSui с Environment и Eligibility Check

// MARK: - Styled компоненты

struct CardStyleNativeAd: View {
    let style: NativeAdViewStyle
    
    init(style: NativeAdViewStyle = .card) {
        self.style = style
    }
    
    var body: some View {
        NativeAdViewSui(style: style)
            .cornerRadius(12)
            .shadow(color: .black.opacity(0.08), radius: 8, x: 0, y: 4)
            .padding(.horizontal, 16)
    }
}

// MARK: - View Modifier для удобства

struct WithNativeAds: ViewModifier {
    @StateObject private var nativeViewModel: NativeAdViewModel
    
    init(adUnitID: String = "ca-app-pub-3940256099942544/3986624511", requestInterval: Int = 60) {
        self._nativeViewModel = StateObject(wrappedValue: NativeAdViewModel(adUnitID: adUnitID, requestInterval: requestInterval))
    }
    
    func body(content: Content) -> some View {
        content
            .nativeAdViewModel(nativeViewModel)
            .onAppear {
                nativeViewModel.refreshAd()
            }
    }
}

extension View {
    /// Добавляет поддержку Native Ads через Environment
    /// - Parameters:
    ///   - adUnitID: ID рекламного блока (по умолчанию test ID)
    ///   - requestInterval: Интервал между запросами в секундах (по умолчанию 60)
    func withNativeAds(adUnitID: String = "ca-app-pub-3940256099942544/3986624511", requestInterval: Int = 60) -> some View {
        modifier(WithNativeAds(adUnitID: adUnitID, requestInterval: requestInterval))
    }
}

// ===== FILE: Timetable DSW/Services/Ads/Native/NativeAdViewSui.swift =====
import SwiftUI


struct NativeAdViewSui: View {
    @Environment(\.adCoordinator) private var coordinator
    @Environment(\.nativeAdViewModel) private var environmentViewModel
    
    let style: NativeAdViewStyle
    let viewModel: NativeAdViewModel?
    
    // Вариант 1: Использовать ViewModel из Environment (рекомендуется)
    init(style: NativeAdViewStyle = .card) {
        self.style = style
        self.viewModel = nil
    }
    
    // Вариант 2: Передать свой ViewModel
    init(viewModel: NativeAdViewModel, style: NativeAdViewStyle = .card) {
        self.style = style
        self.viewModel = viewModel
    }
    
    var body: some View {
        // Проверка через coordinator (premium/feature flags)
        if coordinator?.isAdDisabled() ?? true {
            EmptyView()
        } else if let nativeViewModel = viewModel ?? environmentViewModel {
            NativeAdViewRepresentable(nativeViewModel: nativeViewModel, style: style)
                .frame(height: heightForStyle(style))
                .background(Color(uiColor: .secondarySystemBackground))
        } else {
            // Fallback если нет ViewModel (для отладки)
            Color.red.opacity(0.3)
                .frame(height: heightForStyle(style))
                .overlay(
                    Text("⚠️ NativeAdViewModel not provided")
                        .font(.caption)
                        .foregroundColor(.white)
                )
        }
    }
    
    private func heightForStyle(_ style: NativeAdViewStyle) -> CGFloat {
        switch style {
        case .basic: return 150
        case .card: return 380
        case .banner: return 80
        case .largeBanner: return 500
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/Providers/NativeAdProvider.swift =====
import Foundation
import GoogleMobileAds
import Combine

// MARK: - Native Ad Provider

@MainActor
final class NativeAdProvider: NSObject {

    // MARK: - Configuration

    struct Configuration {
        let adUnitID: String
        let cacheSize: Int
        let refreshInterval: TimeInterval

        static let `default` = Configuration(
            adUnitID: "ca-app-pub-3940256099942544/3986624511", // Test ID
            cacheSize: 3,
            refreshInterval: 60.0 // 1 minute
        )
    }

    // MARK: - Published State

    @Published private(set) var nativeAd: NativeAd?
    @Published private(set) var isLoading = false

    // MARK: - Private Properties

    private let configuration: Configuration
    private var adLoader: AdLoader?

    // Static cache (shared across instances)
    private static var adCache: [String: CachedNativeAd] = [:]
    private static var loadingStates: [String: Bool] = [:]

    // MARK: - Cached Ad Model

    private struct CachedNativeAd {
        let ad: NativeAd
        let loadedAt: Date
    }

    // MARK: - Initialization

    init(configuration: Configuration = .default) {
        self.configuration = configuration
        super.init()

        // Try to load from cache immediately
        if let cached = Self.getCachedAd(for: configuration.adUnitID, maxAge: configuration.refreshInterval) {
            self.nativeAd = cached.ad
        }
    }

    // MARK: - Public Methods

    func load() async throws {
        // Check cache first
        if let cached = Self.getCachedAd(for: configuration.adUnitID, maxAge: configuration.refreshInterval) {
            self.nativeAd = cached.ad
            return
        }

        // Check if already loading
        if Self.loadingStates[configuration.adUnitID] == true {
            // Wait for existing load to complete
            try await waitForExistingLoad()
            return
        }

        // Start loading
        Self.loadingStates[configuration.adUnitID] = true
        isLoading = true

        defer {
            Self.loadingStates[configuration.adUnitID] = false
            isLoading = false
        }

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            let adViewOptions = NativeAdViewAdOptions()
            adViewOptions.preferredAdChoicesPosition = .topRightCorner

            let loader = AdLoader(
                adUnitID: configuration.adUnitID,
                rootViewController: nil,
                adTypes: [.native],
                options: [adViewOptions]
            )

            let delegate = LoaderDelegate(
                onSuccess: { [weak self] ad in
                    guard let self = self else { return }
                    self.nativeAd = ad
                    ad.delegate = self

                    // Setup video delegate
                    let videoController = ad.mediaContent.videoController
                        videoController.delegate = self

                    // Cache the ad
                    Self.cacheAd(ad, for: self.configuration.adUnitID, cacheSize: self.configuration.cacheSize)

                    continuation.resume()
                },
                onFailure: { error in
                    continuation.resume(throwing: AdError.failedToLoad(error))
                }
            )

            loader.delegate = delegate
            self.adLoader = loader

            loader.load(Request())
        }
    }

    func refresh() async throws {
        // Force refresh by clearing cache
        Self.adCache.removeValue(forKey: configuration.adUnitID)
        try await load()
    }

    // MARK: - Cache Management

    private static func getCachedAd(for adUnitID: String, maxAge: TimeInterval) -> CachedNativeAd? {
        guard let cached = adCache[adUnitID] else { return nil }

        let age = Date().timeIntervalSince(cached.loadedAt)
        guard age < maxAge else {
            adCache.removeValue(forKey: adUnitID)
            return nil
        }

        return cached
    }

    private static func cacheAd(_ ad: NativeAd, for adUnitID: String, cacheSize: Int) {
        adCache[adUnitID] = CachedNativeAd(ad: ad, loadedAt: Date())

        // Trim cache if needed
        if adCache.count > cacheSize {
            let sortedByDate = adCache.sorted { $0.value.loadedAt < $1.value.loadedAt }
            if let oldestKey = sortedByDate.first?.key {
                adCache.removeValue(forKey: oldestKey)
            }
        }
    }

    private func waitForExistingLoad() async throws {
        // Poll until loading is complete or timeout
        let maxWaitTime: TimeInterval = 10.0
        let pollInterval: TimeInterval = 0.1
        var waited: TimeInterval = 0

        while Self.loadingStates[configuration.adUnitID] == true && waited < maxWaitTime {
            try await Task.sleep(nanoseconds: UInt64(pollInterval * 1_000_000_000))
            waited += pollInterval
        }

        // Check if we have the ad now
        if let cached = Self.getCachedAd(for: configuration.adUnitID, maxAge: configuration.refreshInterval) {
            self.nativeAd = cached.ad
        } else {
            throw AdError.failedToLoad(NSError(
                domain: "NativeAdProvider",
                code: 2,
                userInfo: [NSLocalizedDescriptionKey: "Failed to load after waiting"]
            ))
        }
    }

    // MARK: - Loader Delegate

    private class LoaderDelegate: NSObject, NativeAdLoaderDelegate {
        let onSuccess: (NativeAd) -> Void
        let onFailure: (Error) -> Void

        init(onSuccess: @escaping (NativeAd) -> Void, onFailure: @escaping (Error) -> Void) {
            self.onSuccess = onSuccess
            self.onFailure = onFailure
        }

        func adLoader(_ adLoader: AdLoader, didReceive nativeAd: NativeAd) {
            onSuccess(nativeAd)
        }

        func adLoader(_ adLoader: AdLoader, didFailToReceiveAdWithError error: Error) {
            onFailure(error)
        }
    }
}

// MARK: - Video Controller Delegate

extension NativeAdProvider: VideoControllerDelegate {
    func videoControllerDidPlayVideo(_ videoController: VideoController) {
        print("[NativeAd] Video started playing")
    }

    func videoControllerDidPauseVideo(_ videoController: VideoController) {
        print("[NativeAd] Video paused")
    }

    func videoControllerDidEndVideoPlayback(_ videoController: VideoController) {
        print("[NativeAd] Video ended")
    }

    func videoControllerDidMuteVideo(_ videoController: VideoController) {
        print("[NativeAd] Video muted")
    }

    func videoControllerDidUnmuteVideo(_ videoController: VideoController) {
        print("[NativeAd] Video unmuted")
    }
}

// MARK: - Native Ad Delegate

extension NativeAdProvider: NativeAdDelegate {
    func nativeAdDidRecordClick(_ nativeAd: NativeAd) {
        print("[NativeAd] Click recorded")
    }

    func nativeAdDidRecordImpression(_ nativeAd: NativeAd) {
        print("[NativeAd] Impression recorded")
    }

    func nativeAdWillPresentScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Will present screen")
    }

    func nativeAdWillDismissScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Will dismiss screen")
    }

    func nativeAdDidDismissScreen(_ nativeAd: NativeAd) {
        print("[NativeAd] Did dismiss screen")
    }
}

// ===== FILE: Timetable DSW/Services/Ads/RewardedAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class RewardedAdProvider: NSObject, RewardableAdProvider {
    typealias AdObject = RewardedAd
    
    let adType: AdType = .rewarded
    private let adUnitID: String
    private var ad: RewardedAd?
    private var didEarnReward = false
    private var presentationContinuation: CheckedContinuation<Void, Error>?
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    
    var isReady: Bool { ad != nil }
    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            RewardedAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        
        didEarnReward = false
        
        try await withCheckedThrowingContinuation { continuation in
            presentationContinuation = continuation
            ad.present(from: viewController) { [weak self] in
                self?.didEarnReward = true
                self?.rewardSubject.send(true)
            }
        }
    }
    
    func reset() {
        ad = nil
        presentationContinuation = nil
        didEarnReward = false
    }
}

extension RewardedAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { @MainActor in
            if let cont = presentationContinuation {
                presentationContinuation = nil
                if didEarnReward {
                    cont.resume()
                } else {
                    cont.resume(throwing: AdError.noReward)
                }
            }
            reset()
        }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { @MainActor in
            presentationContinuation?.resume(throwing: AdError.failedToPresent(error))
            presentationContinuation = nil
            reset()
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/RewardedInterstitialAdProvider.swift =====
import GoogleMobileAds
import Combine
import UIKit

@MainActor
final class RewardedInterstitialAdProvider: NSObject, RewardableAdProvider {
    typealias AdObject = RewardedInterstitialAd
    
    let adType: AdType = .rewardedInterstitial
    private let adUnitID: String
    private var ad: RewardedInterstitialAd?
    private var didEarnReward = false
    private var presentationContinuation: CheckedContinuation<Void, Error>?
    private let rewardSubject = PassthroughSubject<Bool, Never>()
    
    var isReady: Bool { ad != nil }
    var rewardPublisher: AnyPublisher<Bool, Never> {
        rewardSubject.eraseToAnyPublisher()
    }
    
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }
    
    func load() async throws {
        ad = try await withCheckedThrowingContinuation { continuation in
            RewardedInterstitialAd.load(with: adUnitID, request: Request()) { ad, error in
                if let error = error {
                    continuation.resume(throwing: AdError.failedToLoad(error))
                } else if let ad = ad {
                    continuation.resume(returning: ad)
                } else {
                    continuation.resume(throwing: AdError.notLoaded)
                }
            }
        }
        ad?.fullScreenContentDelegate = self
    }
    
    func present(from viewController: UIViewController) async throws {
        guard let ad = ad else { throw AdError.notLoaded }
        
        didEarnReward = false
        
        try await withCheckedThrowingContinuation { continuation in
            presentationContinuation = continuation
            ad.present(from: viewController) { [weak self] in
                self?.didEarnReward = true
                self?.rewardSubject.send(true)
            }
        }
    }
    
    func reset() {
        ad = nil
        presentationContinuation = nil
        didEarnReward = false
    }
}

extension RewardedInterstitialAdProvider: FullScreenContentDelegate {
    nonisolated func adDidDismissFullScreenContent(_ ad: FullScreenPresentingAd) {
        Task { @MainActor in
            if let cont = presentationContinuation {
                presentationContinuation = nil
                if didEarnReward {
                    cont.resume()
                } else {
                    cont.resume(throwing: AdError.noReward)
                }
            }
            reset()
        }
    }
    
    nonisolated func ad(_ ad: FullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        Task { @MainActor in
            presentationContinuation?.resume(throwing: AdError.failedToPresent(error))
            presentationContinuation = nil
            reset()
        }
    }
}

// ===== FILE: Timetable DSW/Services/Ads/ViewControllerProvider.swift =====
import UIKit.UIViewController

protocol ViewControllerProvider {
    func getRootViewController() async -> UIViewController?
    func getTopMostViewController() async -> UIViewController?
    func acquirePresentingViewController(timeout: TimeInterval) async throws -> UIViewController
}

// ===== FILE: Timetable DSW/Services/AppState/AppStateService.swift =====
// ===== FILE: Timetable DSW/Services/AppState/AppStateService.swift =====
import Foundation
import Combine

// MARK: - Core Models (Sendable для Swift Concurrency)

enum PremiumStatus: Codable, Sendable, Equatable {
    case free
    case premium
    case temporaryPremium(expiresAt: Date)

    var isPremium: Bool {
        switch self {
        case .free:
            return false
        case .premium:
            return true
        case .temporaryPremium(let expiresAt):
            return Date() < expiresAt
        }
    }
}

struct AppState: Codable, Sendable, Equatable {
    var premiumStatus: PremiumStatus
    var premiumPurchaseDate: Date?
    var lastAdWatchedDate: Date?
    var totalAdsWatched: Int

    static let `default` = AppState(
        premiumStatus: .free,
        premiumPurchaseDate: nil,
        lastAdWatchedDate: nil,
        totalAdsWatched: 0
    )
}

// MARK: - Protocol (@MainActor для SwiftUI)

// MARK: - Configuration

struct AppStateConfiguration {
    static let temporaryPremiumDuration: TimeInterval = 3600 // 1 hour
    static let secondsInHour: Int = 3600 // For time formatting
    static let stateStorageKey = "app_state"
}

// MARK: - Storage Layer (Single Responsibility: Persistence)

actor AppStateStorage {
    private let userDefaults: UserDefaults
    private let storageKey: String

    init(
        userDefaults: UserDefaults = .standard,
        storageKey: String = AppStateConfiguration.stateStorageKey
    ) {
        self.userDefaults = userDefaults
        self.storageKey = storageKey
    }

    func loadState() -> AppState {
        guard let data = userDefaults.data(forKey: storageKey),
              let state = try? JSONDecoder().decode(AppState.self, from: data) else {
            return .default
        }
        return state
    }

    func saveState(_ state: AppState) {
        guard let data = try? JSONEncoder().encode(state) else { return }
        userDefaults.set(data, forKey: storageKey)
    }
}

// MARK: - Premium Expiration Monitor (Single Responsibility: Time-based checks)

@MainActor
final class PremiumExpirationMonitor {
    private var timer: Timer?
    private let onExpiration: () -> Void

    init(onExpiration: @escaping () -> Void) {
        self.onExpiration = onExpiration
    }

    func scheduleCheck(for expirationDate: Date) {
        cancelScheduledCheck()

        let timeInterval = expirationDate.timeIntervalSince(Date())
        guard timeInterval > 0 else {
            onExpiration()
            return
        }

        timer = Timer.scheduledTimer(
            withTimeInterval: timeInterval,
            repeats: false
        ) { [weak self] _ in
            self?.onExpiration()
        }
    }

    func cancelScheduledCheck() {
        timer?.invalidate()
        timer = nil
    }

    // deinit не может быть @MainActor, поэтому делаем cleanup синхронно
    nonisolated deinit {
        // Timer.invalidate() может быть вызвано из любого потока
        // Для безопасности проверяем, что timer существует
        Task { @MainActor [timer] in
            timer?.invalidate()
        }
    }
}

// MARK: - Premium Status Validator (Single Responsibility: Validation logic)

struct PremiumStatusValidator {
    func validateAndUpdate(_ state: AppState) -> AppState {
        var updatedState = state

        guard case .temporaryPremium(let expiresAt) = state.premiumStatus else {
            return state
        }

        if Date() >= expiresAt {
            updatedState.premiumStatus = .free
        }

        return updatedState
    }

    func isExpired(_ status: PremiumStatus) -> Bool {
        guard case .temporaryPremium(let expiresAt) = status else {
            return false
        }
        return Date() >= expiresAt
    }
}

// MARK: - Main Service (@MainActor для SwiftUI)

@MainActor
final class DefaultAppStateService: ObservableObject, AppStateService {

    // MARK: - Dependencies

    private let storage: AppStateStorage
    private let validator = PremiumStatusValidator()
    private weak var parametersService: FeatureFlagParametersService?

    // MARK: - Published State

    @Published private(set) var state: AppState {
        didSet {
            Task {
                await storage.saveState(state)
            }
            updateExpirationMonitor()
        }
    }

    // MARK: - Computed Properties

    var statePublisher: AnyPublisher<AppState, Never> {
        $state.eraseToAnyPublisher()
    }

    var premiumStatus: PremiumStatus {
        state.premiumStatus
    }

    var isPremium: Bool {
        state.premiumStatus.isPremium
    }

    private lazy var expirationMonitor: PremiumExpirationMonitor = {
            PremiumExpirationMonitor { [weak self] in
                self?.handlePremiumExpiration()
            }
        }()

    // MARK: - Initialization

    init(
        userDefaults: UserDefaults = .standard,
        parametersService: FeatureFlagParametersService? = nil
    ) {
        self.storage = AppStateStorage(userDefaults: userDefaults)
        self.parametersService = parametersService

        // Временная инициализация для создания monitor
        self.state = .default

        // Загружаем реальное состояние
        Task {
            await loadInitialState()
        }
    }

    // MARK: - Public Methods

    func grantPremium() {
        state.premiumStatus = .premium
        state.premiumPurchaseDate = Date()
    }

    func grantTemporaryPremium(
        duration: TimeInterval? = nil
    ) {
        // Get duration from parameters service or use provided value or fallback to default
        let effectiveDuration: TimeInterval
        if let duration = duration {
            effectiveDuration = duration
        } else if let paramDuration = parametersService?.getInt(.premiumTrialDuration) {
            effectiveDuration = TimeInterval(paramDuration)
        } else {
            effectiveDuration = AppStateConfiguration.temporaryPremiumDuration
        }

        let expiresAt = Date().addingTimeInterval(effectiveDuration)
        state.premiumStatus = .temporaryPremium(expiresAt: expiresAt)
    }

    func revokePremium() {
        state.premiumStatus = .free
        state.premiumPurchaseDate = nil
    }

    func recordAdWatched() {
        state.lastAdWatchedDate = Date()
        state.totalAdsWatched += 1
    }

    // MARK: - Private Methods

    private func loadInitialState() async {
        let loadedState = await storage.loadState()
        state = validator.validateAndUpdate(loadedState)
    }

    private func handlePremiumExpiration() {
        guard validator.isExpired(state.premiumStatus) else { return }
        state.premiumStatus = .free
    }

    private func updateExpirationMonitor() {
        guard case .temporaryPremium(let expiresAt) = state.premiumStatus else {
            expirationMonitor.cancelScheduledCheck()
            return
        }

        expirationMonitor.scheduleCheck(for: expiresAt)
    }
}

// ===== FILE: Timetable DSW/Services/DateService/DateService.swift =====
import Foundation

// MARK: - Protocol

protocol DateService {
    func greeting(for date: Date) -> String
    func formatDate(_ date: Date) -> String
    func formatTime(_ date: Date) -> String
    func weekdayShort(_ date: Date) -> String
    func weekdayFull(_ date: Date) -> String
    func dayNumber(_ date: Date) -> String
    func startOfWeek(for date: Date) -> Date
    func daysInWeek(startingFrom date: Date) -> [Date]
    func parseISO8601(_ string: String) -> Date?
}

// ===== FILE: Timetable DSW/Services/DateService/DefaultDateService.swift =====
import Foundation

final class DefaultDateService: DateService {
    // MARK: - Shared Instance

    static let shared = DefaultDateService()

    // MARK: - Properties

    private let calendar: Calendar
    
    // MARK: - Formatters
    
    private lazy var iso8601Formatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return formatter
    }()
    
    private lazy var dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .none
        formatter.locale = .current
        return formatter
    }()
    
    private lazy var timeFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter
    }()
    
    private lazy var weekdayShortFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEE"
        return formatter
    }()
    
    private lazy var weekdayFullFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE"
        formatter.locale = .current
        return formatter
    }()
    
    private lazy var dayFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "dd"
        return formatter
    }()
    
    // MARK: - Initialization
    
    init(calendar: Calendar = .current) {
        self.calendar = calendar
    }
    
    // MARK: - DateService Implementation
    
    func greeting(for date: Date) -> String {
        let hour = calendar.component(.hour, from: date)
        switch hour {
        case 5..<12: return LocalizedString.greetingMorning.localized
        case 12..<17: return LocalizedString.greetingAfternoon.localized
        case 17..<22: return LocalizedString.greetingEvening.localized
        default: return LocalizedString.greetingNight.localized
        }
    }
    
    func formatDate(_ date: Date) -> String {
        dateFormatter.string(from: date)
    }
    
    func formatTime(_ date: Date) -> String {
        timeFormatter.string(from: date)
    }
    
    func weekdayShort(_ date: Date) -> String {
        weekdayShortFormatter.string(from: date).uppercased()
    }
    
    func weekdayFull(_ date: Date) -> String {
        weekdayFullFormatter.string(from: date).capitalized
    }
    
    func dayNumber(_ date: Date) -> String {
        dayFormatter.string(from: date)
    }
    
    func startOfWeek(for date: Date) -> Date {
        let components = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)
        return calendar.date(from: components) ?? date
    }
    
    func daysInWeek(startingFrom date: Date) -> [Date] {
        (0..<7).compactMap { offset in
            calendar.date(byAdding: .day, value: offset, to: date)
        }
    }
    
    func parseISO8601(_ string: String) -> Date? {
        iso8601Formatter.date(from: string)
    }
}

// ===== FILE: Timetable DSW/Services/EventTypeDetector/DefaultEventTypeDetector.swift =====
import Foundation

final class DefaultEventTypeDetector: EventTypeDetector {
    // MARK: - Configuration
    
    struct Configuration {
        struct Keywords {
            static let lecture = ["wyk", "лекц"]
            static let exercise = ["ćw", "cw", "практ"]
            static let laboratory = ["lab", "лаб"]
            static let online = ["online", "онлайн", "teams", "zoom", "distance"]
            static let cancelled = ["zajęcia odwołane", "odwołane"];
        }
    }
    
    // MARK: - EventTypeDetector Implementation
    
    func detectEventType(from type: String?) -> EventType {
        guard let type = type?.lowercased() else { return .other }
        
        if Configuration.Keywords.lecture.contains(where: { type.contains($0) }) {
            return .lecture
        }
        
        if Configuration.Keywords.exercise.contains(where: { type.contains($0) }) {
            return .exercise
        }
        
        if Configuration.Keywords.laboratory.contains(where: { type.contains($0) }) {
            return .laboratory
        }
        
        return .other
    }
    
    func isOnline(remarks: String?) -> Bool {
        let remarksLower = remarks?.lowercased() ?? ""
        
        return Configuration.Keywords.online.contains { keyword in
            remarksLower.contains(keyword)
        }
    }

    func isCancelled(remarks: String?) -> Bool {
        let remarksLower = remarks?.lowercased() ?? ""
        
        return Configuration.Keywords.cancelled.contains { keyword in
            remarksLower.contains(keyword)
        }
    }
}

struct EventPresentationInfo {
    let kind: EventType        // lecture / exercise / lab / other
    let isOnline: Bool         // пара онлайн?
    let isCancelled: Bool      // пара отменена?

    init(event: ScheduleEvent,
                detector: EventTypeDetector = DefaultEventTypeDetector()) {
        self.kind = detector.detectEventType(from: event.type)
        self.isOnline = detector.isOnline(remarks: event.remarks)
        self.isCancelled = detector.isCancelled(remarks: event.remarks)
    }
}

// ===== FILE: Timetable DSW/Services/EventTypeDetector/EventType.swift =====
import Foundation

// MARK: - Event Type

enum EventType {
    case lecture
    case exercise
    case laboratory
    case other
}

// MARK: - Protocol

protocol EventTypeDetector {
    func detectEventType(from type: String?) -> EventType
    func isOnline(remarks: String?) -> Bool
    func isCancelled(remarks: String?) -> Bool
}

// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlag.swift =====
// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlag.swift =====
import Foundation
import Combine

enum FeatureFlag: String, CaseIterable, Codable, Sendable {
    case showSubjectsTab = "show_subjects_tab"
    case showTeachersTab = "show_teachers_tab"
    case enableAnalytics = "enable_analytics"
    case showAds = "show_ads"
    case enablePushNotifications = "enable_push_notifications"
    case darkModeOnly = "dark_mode_only"
    case showDebugMenu = "show_debug_menu"

    nonisolated var defaultValue: Bool {
        switch self {
        case .showSubjectsTab, .showTeachersTab, .showAds:
            return false
        case .enableAnalytics, .enablePushNotifications:
            return false
        case .darkModeOnly:
            return false
        case .showDebugMenu:
            #if DEBUG
            return true
            #else
            return false
            #endif
        }
    }

    nonisolated var displayName: String {
        switch self {
        case .showSubjectsTab: return "Show Subjects Tab"
        case .showTeachersTab: return "Show Teachers Tab"
        case .enableAnalytics: return "Enable Analytics"
        case .showAds: return "Show Advertisements"
        case .enablePushNotifications: return "Enable Push Notifications"
        case .darkModeOnly: return "Dark Mode Only"
        case .showDebugMenu: return "Show Debug Menu"
        }
    }

    nonisolated var description: String {
        switch self {
        case .showSubjectsTab: return "Display subjects tab in navigation"
        case .showTeachersTab: return "Display teachers tab in navigation"
        case .enableAnalytics: return "Send analytics data"
        case .showAds: return "Display advertisements (disabled for premium users)"
        case .enablePushNotifications: return "Enable push notifications"
        case .darkModeOnly: return "Force dark mode for all users"
        case .showDebugMenu: return "Show debug menu in settings"
        }
    }
}

struct FeatureFlagsResponse: Codable, Sendable {
    let flags: [String: Bool]
    let version: String
    let updatedAt: String
}

struct FeatureFlagsState: Codable, Sendable {
    var localOverrides: [String: Bool]
    var remoteFlags: [String: Bool]
    var version: String?
    var lastSync: Date?

    static let empty = FeatureFlagsState(
        localOverrides: [:],
        remoteFlags: [:],
        version: nil,
        lastSync: nil
    )
}

// MARK: - Protocol (Main Actor для SwiftUI совместимости)


// MARK: - Storage Layer (Single Responsibility: Persistence)

actor FeatureFlagsStorage {
    private let userDefaults: UserDefaults
    private let stateKey = "feature_flags_state"

    init(userDefaults: UserDefaults = .standard) {
        self.userDefaults = userDefaults
    }

    func loadState() -> FeatureFlagsState {
        guard let data = userDefaults.data(forKey: stateKey),
              let state = try? JSONDecoder().decode(FeatureFlagsState.self, from: data) else {
            return .empty
        }
        return state
    }

    func saveState(_ state: FeatureFlagsState) {
        guard let data = try? JSONEncoder().encode(state) else { return }
        userDefaults.set(data, forKey: stateKey)
    }
}

// MARK: - Sync Layer (Single Responsibility: Remote Sync)

actor FeatureFlagsSyncService {
    private let networkManager: NetworkManager
    private let syncInterval: TimeInterval = 3600 // 1 hour

    init(networkManager: NetworkManager) {
        self.networkManager = networkManager
    }

    func shouldSync(lastSyncDate: Date?) -> Bool {
        guard let lastSync = lastSyncDate else { return true }
        return Date().timeIntervalSince(lastSync) > syncInterval
    }

    func fetchRemoteFlags() async throws -> FeatureFlagsResponse {
        try await networkManager.fetch(endpoint: "/api/feature-flags")
    }
}

// MARK: - Resolution Layer (Single Responsibility: Flag Resolution Logic)

struct FeatureFlagResolver {
    func resolveValue(
        for flag: FeatureFlag,
        localOverride: Bool?,
        remoteValue: Bool?
    ) -> Bool {
        // Priority: local override > remote > default
        if let override = localOverride {
            return override
        }

        if let remote = remoteValue {
            return remote
        }

        return flag.defaultValue
    }

    func resolveAllFlags(
        localOverrides: [String: Bool],
        remoteFlags: [String: Bool]
    ) -> [FeatureFlag: Bool] {
        var result: [FeatureFlag: Bool] = [:]

        for flag in FeatureFlag.allCases {
            let localOverride = localOverrides[flag.rawValue]
            let remoteValue = remoteFlags[flag.rawValue]
            result[flag] = resolveValue(
                for: flag,
                localOverride: localOverride,
                remoteValue: remoteValue
            )
        }

        return result
    }
}

// MARK: - Main Service (@MainActor для SwiftUI)

@MainActor
final class DefaultFeatureFlagService: ObservableObject, FeatureFlagService {

    // MARK: - Dependencies

    private let storage: FeatureFlagsStorage
    private let syncService: FeatureFlagsSyncService
    private let resolver = FeatureFlagResolver()

    // MARK: - State

    @Published private var state: FeatureFlagsState
    private let flagsSubject = CurrentValueSubject<[FeatureFlag: Bool], Never>([:])

    nonisolated var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> {
        flagsSubject.eraseToAnyPublisher()
    }

    // MARK: - Initialization

    init(
        networkManager: NetworkManager = NetworkManager(),
        userDefaults: UserDefaults = .standard
    ) {
        self.storage = FeatureFlagsStorage(userDefaults: userDefaults)
        self.syncService = FeatureFlagsSyncService(networkManager: networkManager)
        self.state = .empty

        Task {
            await loadInitialState()
        }
    }

    // MARK: - Public Methods

    func isEnabled(_ flag: FeatureFlag) -> Bool {
        resolver.resolveValue(
            for: flag,
            localOverride: state.localOverrides[flag.rawValue],
            remoteValue: state.remoteFlags[flag.rawValue]
        )
    }

    func setEnabled(_ flag: FeatureFlag, enabled: Bool) {
        state.localOverrides[flag.rawValue] = enabled
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func reset(_ flag: FeatureFlag) {
        state.localOverrides.removeValue(forKey: flag.rawValue)
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func resetAll() {
        state.localOverrides.removeAll()
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    func syncFromRemote() async throws {
        let response = try await syncService.fetchRemoteFlags()

        state.remoteFlags = response.flags
        state.version = response.version
        state.lastSync = Date()

        updatePublisher()
        await storage.saveState(state)
    }

    // MARK: - Internal Methods

    func hasLocalOverride(for flag: FeatureFlag) -> Bool {
        state.localOverrides[flag.rawValue] != nil
    }

    // MARK: - Private Methods

    private func loadInitialState() async {
        let should = await syncService.shouldSync(lastSyncDate: state.lastSync)
            print("🟡 shouldSync=\(should) lastSync=\(String(describing: state.lastSync)) @\(Date())")

            if should {
                print("🟢 entering syncFromRemote @\(Date())")
                do {
                    try await syncFromRemote()
                    print("✅ finished syncFromRemote @\(Date())")
                } catch {
                    print("❌ syncFromRemote error: \(error) @\(Date())")
                }
            } else {
                print("⚪️ skip sync @\(Date())")
            }
    }

    private func updatePublisher() {
        let allFlags = resolver.resolveAllFlags(
            localOverrides: state.localOverrides,
            remoteFlags: state.remoteFlags
        )
        flagsSubject.send(allFlags)
    }
}

// MARK: - Preview/Mock Service

// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlagParameters.swift =====
import Foundation
import Combine
import SwiftUI

// MARK: - Parameter Types

/// Type-safe parameter value
enum FeatureFlagParameterValue: Codable, Sendable, Equatable {
    case string(String)
    case int(Int)
    case double(Double)
    case bool(Bool)
    case stringArray([String])

    // MARK: - Codable

    private enum CodingKeys: String, CodingKey {
        case type, value
    }

    private enum ValueType: String, Codable {
        case string, int, double, bool, stringArray
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .string(let val):
            try container.encode(ValueType.string, forKey: .type)
            try container.encode(val, forKey: .value)
        case .int(let val):
            try container.encode(ValueType.int, forKey: .type)
            try container.encode(val, forKey: .value)
        case .double(let val):
            try container.encode(ValueType.double, forKey: .type)
            try container.encode(val, forKey: .value)
        case .bool(let val):
            try container.encode(ValueType.bool, forKey: .type)
            try container.encode(val, forKey: .value)
        case .stringArray(let val):
            try container.encode(ValueType.stringArray, forKey: .type)
            try container.encode(val, forKey: .value)
        }
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(ValueType.self, forKey: .type)

        switch type {
        case .string:
            self = .string(try container.decode(String.self, forKey: .value))
        case .int:
            self = .int(try container.decode(Int.self, forKey: .value))
        case .double:
            self = .double(try container.decode(Double.self, forKey: .value))
        case .bool:
            self = .bool(try container.decode(Bool.self, forKey: .value))
        case .stringArray:
            self = .stringArray(try container.decode([String].self, forKey: .value))
        }
    }
}

// MARK: - Parameter Definition

struct FeatureFlagParameterDefinition: Codable, Sendable {
    let key: String
    let defaultValue: FeatureFlagParameterValue

    var displayName: String {
        key.replacingOccurrences(of: "_", with: " ").capitalized
    }
}

// MARK: - Parameters Configuration

/// Configuration for feature flag parameters
enum FeatureFlagParameterKey: String, CaseIterable, Sendable {
    case bannerPosition = "banner_position"
    case bannerRefreshInterval = "banner_refresh_interval"
    case interstitialCooldown = "interstitial_cooldown"
    case nativeAdCacheSize = "native_ad_cache_size"
    case premiumTrialDuration = "premium_trial_duration"

    var definition: FeatureFlagParameterDefinition {
        switch self {
        case .bannerPosition:
            return FeatureFlagParameterDefinition(
                key: rawValue,
                defaultValue: .string("bottom")
            )
        case .bannerRefreshInterval:
            return FeatureFlagParameterDefinition(
                key: rawValue,
                defaultValue: .int(60) // seconds
            )
        case .interstitialCooldown:
            return FeatureFlagParameterDefinition(
                key: rawValue,
                defaultValue: .int(300) // 5 minutes
            )
        case .nativeAdCacheSize:
            return FeatureFlagParameterDefinition(
                key: rawValue,
                defaultValue: .int(3)
            )
        case .premiumTrialDuration:
            return FeatureFlagParameterDefinition(
                key: rawValue,
                defaultValue: .int(Int(AppStateConfiguration.temporaryPremiumDuration))
            )
        }
    }

    var displayName: String {
        switch self {
        case .bannerPosition: return "Banner Position"
        case .bannerRefreshInterval: return "Banner Refresh Interval"
        case .interstitialCooldown: return "Interstitial Cooldown"
        case .nativeAdCacheSize: return "Native Ad Cache Size"
        case .premiumTrialDuration: return "Premium Trial Duration"
        }
    }

    var description: String {
        switch self {
        case .bannerPosition:
            return "Position of banner ad (bottom, top, aboveTabBar)"
        case .bannerRefreshInterval:
            return "How often to refresh banner ads (seconds)"
        case .interstitialCooldown:
            return "Cooldown between interstitial ads (seconds)"
        case .nativeAdCacheSize:
            return "Number of native ads to cache"
        case .premiumTrialDuration:
            return "Duration of premium trial after rewarded ad (seconds)"
        }
    }
}

// MARK: - Storage State

struct FeatureFlagParametersState: Codable, Sendable {
    var localOverrides: [String: FeatureFlagParameterValue]
    var remoteParameters: [String: FeatureFlagParameterValue]

    static let empty = FeatureFlagParametersState(
        localOverrides: [:],
        remoteParameters: [:]
    )
}

// MARK: - Response Model

struct FeatureFlagParametersResponse: Codable, Sendable {
    let parameters: [String: FeatureFlagParameterValue]
    let version: String
    let updatedAt: String
}

// MARK: - Storage Layer

actor FeatureFlagParametersStorage {
    private let userDefaults: UserDefaults
    private let stateKey = "feature_flag_parameters_state"

    init(userDefaults: UserDefaults = .standard) {
        self.userDefaults = userDefaults
    }

    func loadState() -> FeatureFlagParametersState {
        guard let data = userDefaults.data(forKey: stateKey),
              let state = try? JSONDecoder().decode(FeatureFlagParametersState.self, from: data) else {
            return .empty
        }
        return state
    }

    func saveState(_ state: FeatureFlagParametersState) {
        guard let data = try? JSONEncoder().encode(state) else { return }
        userDefaults.set(data, forKey: stateKey)
    }
}

// MARK: - Main Service

@MainActor
final class FeatureFlagParametersService: ObservableObject {

    // MARK: - Published State

    @Published private var state: FeatureFlagParametersState

    // MARK: - Dependencies

    private let storage: FeatureFlagParametersStorage
    private let parametersSubject = CurrentValueSubject<[FeatureFlagParameterKey: FeatureFlagParameterValue], Never>([:])

    nonisolated var parametersPublisher: AnyPublisher<[FeatureFlagParameterKey: FeatureFlagParameterValue], Never> {
        parametersSubject.eraseToAnyPublisher()
    }

    // MARK: - Initialization

    init(userDefaults: UserDefaults = .standard) {
        self.storage = FeatureFlagParametersStorage(userDefaults: userDefaults)
        self.state = .empty

        Task {
            await loadInitialState()
        }
    }

    // MARK: - Public Methods

    /// Get parameter value with type-safe access
    func getValue<T>(_ key: FeatureFlagParameterKey, as type: T.Type) -> T? {
        let value = resolveValue(for: key)

        switch value {
        case .string(let str) where T.self == String.self:
            return str as? T
        case .int(let num) where T.self == Int.self:
            return num as? T
        case .double(let num) where T.self == Double.self:
            return num as? T
        case .bool(let flag) where T.self == Bool.self:
            return flag as? T
        case .stringArray(let arr) where T.self == [String].self:
            return arr as? T
        default:
            return nil
        }
    }

    /// Get string parameter (convenience)
    func getString(_ key: FeatureFlagParameterKey) -> String? {
        getValue(key, as: String.self)
    }

    /// Get int parameter (convenience)
    func getInt(_ key: FeatureFlagParameterKey) -> Int? {
        getValue(key, as: Int.self)
    }

    /// Get double parameter (convenience)
    func getDouble(_ key: FeatureFlagParameterKey) -> Double? {
        getValue(key, as: Double.self)
    }

    /// Get bool parameter (convenience)
    func getBool(_ key: FeatureFlagParameterKey) -> Bool? {
        getValue(key, as: Bool.self)
    }

    /// Get string array parameter (convenience)
    func getStringArray(_ key: FeatureFlagParameterKey) -> [String]? {
        getValue(key, as: [String].self)
    }

    /// Set local override
    func setValue(_ key: FeatureFlagParameterKey, value: FeatureFlagParameterValue) {
        state.localOverrides[key.rawValue] = value
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    /// Remove local override
    func reset(_ key: FeatureFlagParameterKey) {
        state.localOverrides.removeValue(forKey: key.rawValue)
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    /// Reset all local overrides
    func resetAll() {
        state.localOverrides.removeAll()
        updatePublisher()
        Task {
            await storage.saveState(state)
        }
    }

    // MARK: - Private Methods

    private func resolveValue(for key: FeatureFlagParameterKey) -> FeatureFlagParameterValue {
        // Priority: local override > remote > default
        if let override = state.localOverrides[key.rawValue] {
            return override
        }

        if let remote = state.remoteParameters[key.rawValue] {
            return remote
        }

        return key.definition.defaultValue
    }

    private func loadInitialState() async {
        state = await storage.loadState()
        updatePublisher()
    }

    private func updatePublisher() {
        var result: [FeatureFlagParameterKey: FeatureFlagParameterValue] = [:]

        for key in FeatureFlagParameterKey.allCases {
            result[key] = resolveValue(for: key)
        }

        parametersSubject.send(result)
    }
}

// MARK: - Environment Key

private struct FeatureFlagParametersServiceKey: EnvironmentKey {
    static let defaultValue: FeatureFlagParametersService? = nil
}

extension EnvironmentValues {
    var featureFlagParameters: FeatureFlagParametersService? {
        get { self[FeatureFlagParametersServiceKey.self] }
        set { self[FeatureFlagParametersServiceKey.self] = newValue }
    }
}

extension View {
    func featureFlagParameters(_ service: FeatureFlagParametersService) -> some View {
        environment(\.featureFlagParameters, service)
    }
}

// ===== FILE: Timetable DSW/Services/FeatureFlags/FeatureFlagService.swift =====
import Foundation
import Combine
import SwiftUI

// MARK: - Feature Flags Protocol (Complete)

@MainActor
protocol FeatureFlagService: AnyObject {
    // Basic operations
    func isEnabled(_ flag: FeatureFlag) -> Bool
    func setEnabled(_ flag: FeatureFlag, enabled: Bool)
    func reset(_ flag: FeatureFlag)
    func resetAll()
    func syncFromRemote() async throws
    
    // Additional methods needed by consumers
    func hasLocalOverride(for flag: FeatureFlag) -> Bool
    
    // Publishers for reactive updates
    var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> { get }
}

// MARK: - App State Protocol (Complete)

@MainActor
protocol AppStateService: AnyObject {
    // State properties
    var isPremium: Bool { get }
    var premiumStatus: PremiumStatus { get }
    var state: AppState { get }
    
    // Actions
    func grantPremium()
    func grantTemporaryPremium(duration: TimeInterval?)
    func revokePremium()
    func recordAdWatched()
    
    // Publisher for reactive updates
    var statePublisher: AnyPublisher<AppState, Never> { get }
}

// MARK: - DefaultFeatureFlagService conforms to protocol


// MARK: - Mock Services for Testing

#if DEBUG

@MainActor
final class MockFeatureFlagService: FeatureFlagService {
    private var flags: [FeatureFlag: Bool] = [:]
    private var overrides: Set<FeatureFlag> = []
    private let subject = CurrentValueSubject<[FeatureFlag: Bool], Never>([:])
    
    var flagsPublisher: AnyPublisher<[FeatureFlag: Bool], Never> {
        subject.eraseToAnyPublisher()
    }
    
    init(defaultFlags: [FeatureFlag: Bool] = [:]) {
        self.flags = defaultFlags
        subject.send(flags)
    }
    
    func isEnabled(_ flag: FeatureFlag) -> Bool {
        flags[flag] ?? flag.defaultValue
    }
    
    func setEnabled(_ flag: FeatureFlag, enabled: Bool) {
        flags[flag] = enabled
        overrides.insert(flag)
        subject.send(flags)
    }
    
    func reset(_ flag: FeatureFlag) {
        flags.removeValue(forKey: flag)
        overrides.remove(flag)
        subject.send(flags)
    }
    
    func resetAll() {
        flags.removeAll()
        overrides.removeAll()
        subject.send(flags)
    }
    
    func syncFromRemote() async throws {
        // Mock implementation
        try await Task.sleep(nanoseconds: 1_000_000_000)
    }
    
    func hasLocalOverride(for flag: FeatureFlag) -> Bool {
        overrides.contains(flag)
    }
}

@MainActor
final class MockAppStateService: AppStateService {
    @Published private(set) var state: AppState
    
    var statePublisher: AnyPublisher<AppState, Never> {
        $state.eraseToAnyPublisher()
    }
    
    var premiumStatus: PremiumStatus {
        state.premiumStatus
    }
    
    var isPremium: Bool {
        state.premiumStatus.isPremium
    }
    
    init(initialState: AppState = .default) {
        self.state = initialState
    }
    
    func grantPremium() {
        state.premiumStatus = .premium
        state.premiumPurchaseDate = Date()
    }
    
    func grantTemporaryPremium(duration: TimeInterval? = AppStateConfiguration.temporaryPremiumDuration) {
        let duration = duration ?? AppStateConfiguration.temporaryPremiumDuration
        let expiresAt = Date().addingTimeInterval(duration)
        state.premiumStatus = .temporaryPremium(expiresAt: expiresAt)
    }
    
    func revokePremium() {
        state.premiumStatus = .free
        state.premiumPurchaseDate = nil
    }
    
    func recordAdWatched() {
        state.lastAdWatchedDate = Date()
        state.totalAdsWatched += 1
    }
}

#endif

// MARK: - Service Container (Dependency Injection)

@MainActor
final class ServiceContainer {
    // Singleton pattern (или можно использовать другой DI подход)
    static let shared = ServiceContainer()
    
    // Services как protocols
    let featureFlagService: FeatureFlagService
    let appStateService: AppStateService
    
    private init(
        featureFlagService: FeatureFlagService? = nil,
        appStateService: AppStateService? = nil
    ) {
        // Production services по умолчанию
        self.featureFlagService = featureFlagService ?? DefaultFeatureFlagService()
        self.appStateService = appStateService ?? DefaultAppStateService()
    }
    
    // Factory для тестов
    static func mock(
        featureFlagService: FeatureFlagService? = nil,
        appStateService: AppStateService? = nil
    ) -> ServiceContainer {
        let featureService: FeatureFlagService?
        let appService: AppStateService?
#if DEBUG
        featureService = featureFlagService ?? MockFeatureFlagService()
        appService = appStateService ?? MockAppStateService()
#else
        featureService = featureFlagService
        appService = appStateService
#endif
        return ServiceContainer(
            featureFlagService: featureService,
            appStateService: appService
        )
    }
}

// MARK: - Environment Key для Protocols



// MARK: - View Extension для удобства

extension View {
    func services(
        featureFlagService: FeatureFlagService,
        appStateService: AppStateService
    ) -> some View {
        self
            .environment(\.featureFlagService, featureFlagService)
            .environment(\.appStateService, appStateService)
    }
}

// ===== FILE: Timetable DSW/Services/HapticFeedbackService/DefaultHapticFeedbackService.swift =====
import UIKit

final class DefaultHapticFeedbackService: HapticFeedbackService {
    // MARK: - HapticFeedbackService Implementation
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
}

// ===== FILE: Timetable DSW/Services/HapticFeedbackService/HapticFeedbackService.swift =====
import UIKit

protocol HapticFeedbackService {
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle)
    func selection()
    func notification(type: UINotificationFeedbackGenerator.FeedbackType)
}

// ===== FILE: Timetable DSW/Services/Layout/BottomInsetService.swift =====
import Foundation
import SwiftUI
import Combine

// MARK: - Configuration

enum BannerPosition: String, Codable, CaseIterable, Sendable {
    case bottom         // Banner at very bottom of screen
    case top            // Banner at top of screen
    case aboveTabBar    // Banner above tab bar

    var displayName: String {
        switch self {
        case .bottom: return "Bottom"
        case .top: return "Top"
        case .aboveTabBar: return "Above Tab Bar"
        }
    }
}

struct BottomInsetConfiguration {
    let tabBarHeight: CGFloat
    let bottomInset: CGFloat
    let bannerHeight: CGFloat
    let spacing: CGFloat

    static let `default` = BottomInsetConfiguration(
        tabBarHeight: 78,      // Standard iOS tab bar with safe area
        bottomInset: 8,
        bannerHeight: 50,      // Standard banner ad height
        spacing: 8             // Spacing between elements
    )
}

// MARK: - Service Protocol

@MainActor
protocol BottomInsetService: ObservableObject {
    var bottomInset: CGFloat { get }
    var tabBarBottomPadding: CGFloat { get }
    var bannerPosition: BannerPosition { get }

    func updateBannerPosition(_ position: BannerPosition)
    func updateBannerHeight(_ height: CGFloat)
    func updateTabBarHeight(_ height: CGFloat)
}

// MARK: - Implementation

@MainActor
final class DefaultBottomInsetService: ObservableObject, BottomInsetService {

    // MARK: - Published Properties

    @Published private(set) var bottomInset: CGFloat
    @Published private(set) var tabBarBottomPadding: CGFloat
    @Published var bannerPosition: BannerPosition

    // MARK: - Private Properties

    private var configuration: BottomInsetConfiguration
    private let appStateService: AppStateService
    private let featureFlagService: FeatureFlagService
    private let parametersService: FeatureFlagParametersService?
    private var cancellables = Set<AnyCancellable>()

    private var currentBannerHeight: CGFloat = 0
    private var currentTabBarHeight: CGFloat = 0
    private var currentTabBarBottomInset: CGFloat = 8
    private var cachedIsPremium: Bool = false

    // MARK: - Initialization

    init(
        configuration: BottomInsetConfiguration = .default,
        appStateService: AppStateService,
        featureFlagService: FeatureFlagService,
        parametersService: FeatureFlagParametersService? = nil,
        initialBannerPosition: BannerPosition = .bottom
    ) {
        self.configuration = configuration
        self.appStateService = appStateService
        self.featureFlagService = featureFlagService
        self.parametersService = parametersService

        // Get initial position from parameters or fallback
        let positionFromParams = parametersService?.getString(.bannerPosition)
            .flatMap { BannerPosition(rawValue: $0) } ?? initialBannerPosition

        // Initialize all stored properties
        self.bannerPosition = positionFromParams
        self.currentTabBarHeight = configuration.tabBarHeight
        self.currentBannerHeight = configuration.bannerHeight
        self.currentTabBarBottomInset = configuration.bottomInset
        self.cachedIsPremium = appStateService.isPremium

        // Calculate initial values using local variables to avoid 'self' before init
        let initialPadding = Self.calculateTabBarBottomPadding(
            bannerHeight: configuration.bannerHeight,
            bannerPosition: positionFromParams,
            isPremium: appStateService.isPremium,
            showAds: featureFlagService.isEnabled(.showAds),
            spacing: configuration.spacing,
            defaultPadding: configuration.bottomInset
        )
        self.tabBarBottomPadding = initialPadding

        let initialBottomInset = Self.calculateBottomInset(
            tabBarHeight: configuration.tabBarHeight,
            tabBarBottomPadding: initialPadding,
            bannerHeight: configuration.bannerHeight,
            bannerPosition: positionFromParams,
            isPremium: appStateService.isPremium,
            showAds: featureFlagService.isEnabled(.showAds),
            spacing: configuration.spacing
        )
        self.bottomInset = initialBottomInset

        setupObservers()
    }

    // MARK: - Public Methods

    func updateBannerPosition(_ position: BannerPosition) {
        bannerPosition = position
        recalculateInset()
    }

    func updateBannerHeight(_ height: CGFloat) {
        currentBannerHeight = height
        recalculateInset()
    }

    func updateTabBarHeight(_ height: CGFloat) {
        currentTabBarHeight = height
        recalculateInset()
    }

    // MARK: - Private Methods

    private func setupObservers() {
        // Observe premium status changes
        appStateService.statePublisher
            .map(\.premiumStatus.isPremium)
            .removeDuplicates()
            .sink { [weak self] isPremium in
                guard let self = self else { return }
                self.cachedIsPremium = isPremium
                self.recalculateInset()
            }
            .store(in: &cancellables)

        // Observe ads feature flag changes
        featureFlagService.flagsPublisher
            .map { $0[.showAds] ?? true }
            .removeDuplicates()
            .sink { [weak self] _ in
                self?.recalculateInset()
            }
            .store(in: &cancellables)

        // Observe banner position parameter changes
        parametersService?.parametersPublisher
            .compactMap { $0[.bannerPosition] }
            .compactMap { value -> String? in
                if case .string(let str) = value {
                    return str
                }
                return nil
            }
            .compactMap { BannerPosition(rawValue: $0) }
            .sink { [weak self] newPosition in
                self?.bannerPosition = newPosition
                self?.recalculateInset()
            }
            .store(in: &cancellables)
    }

    private func recalculateInset() {
        tabBarBottomPadding = Self.calculateTabBarBottomPadding(
            bannerHeight: currentBannerHeight,
            bannerPosition: bannerPosition,
            isPremium: cachedIsPremium,
            showAds: featureFlagService.isEnabled(.showAds),
            spacing: configuration.spacing,
            defaultPadding: currentTabBarBottomInset
        )

        bottomInset = Self.calculateBottomInset(
            tabBarHeight: currentTabBarHeight,
            tabBarBottomPadding: tabBarBottomPadding,
            bannerHeight: currentBannerHeight,
            bannerPosition: bannerPosition,
            isPremium: cachedIsPremium,
            showAds: featureFlagService.isEnabled(.showAds),
            spacing: configuration.spacing
        )
    }

    private static func calculateTabBarBottomPadding(
        bannerHeight: CGFloat,
        bannerPosition: BannerPosition,
        isPremium: Bool,
        showAds: Bool,
        spacing: CGFloat,
        defaultPadding: CGFloat
    ) -> CGFloat {
        // If premium or ads disabled, use default padding
        guard !isPremium && showAds else {
            return defaultPadding
        }

        // Only add banner height if banner is at bottom (below tab bar)
        switch bannerPosition {
        case .bottom:
            // TabBar needs to be lifted by banner height + spacing
            return bannerHeight + spacing + defaultPadding

        case .top, .aboveTabBar:
            // Banner doesn't affect TabBar position
            return defaultPadding
        }
    }

    private static func calculateBottomInset(
        tabBarHeight: CGFloat,
        tabBarBottomPadding: CGFloat,
        bannerHeight: CGFloat,
        bannerPosition: BannerPosition,
        isPremium: Bool,
        showAds: Bool,
        spacing: CGFloat
    ) -> CGFloat {
        // Scroll inset should account for:
        // 1. TabBar height
        // 2. TabBar bottom padding (which already includes banner if needed)
        let safeAreaBottom = UIApplication.shared.connectedScenes
                            .compactMap { $0 as? UIWindowScene }
                            .first?.windows.first?.safeAreaInsets.bottom ?? 0
        // If premium or ads disabled, only tab bar + its padding
        guard !isPremium && showAds else {
            return tabBarHeight + tabBarBottomPadding + safeAreaBottom
        }

        // Calculate based on banner position
        switch bannerPosition {
        case .bottom:
            // TabBar padding already includes banner, so just add tab bar height
            return tabBarHeight + tabBarBottomPadding + safeAreaBottom

        case .top:
            // Banner at top: tab bar + padding (banner doesn't affect bottom)
            return tabBarHeight + tabBarBottomPadding

        case .aboveTabBar:
            // Banner above tab bar: tab bar + padding + banner + spacing
            return tabBarHeight + tabBarBottomPadding + bannerHeight + spacing
        }
    }
}

// MARK: - Environment Key

private struct BottomInsetServiceKey: EnvironmentKey {
    static let defaultValue: DefaultBottomInsetService? = nil
}

extension EnvironmentValues {
    var bottomInsetService: DefaultBottomInsetService? {
        get { self[BottomInsetServiceKey.self] }
        set { self[BottomInsetServiceKey.self] = newValue }
    }
}

extension View {
    func bottomInsetService(_ service: DefaultBottomInsetService) -> some View {
        environment(\.bottomInsetService, service)
    }
}

// MARK: - Mock for Testing

#if DEBUG
@MainActor
final class MockBottomInsetService: ObservableObject, BottomInsetService {
    @Published private(set) var bottomInset: CGFloat
    @Published private(set) var tabBarBottomPadding: CGFloat
    @Published var bannerPosition: BannerPosition

    init(
        bottomInset: CGFloat = 78,
        tabBarBottomPadding: CGFloat = 32,
        bannerPosition: BannerPosition = .bottom
    ) {
        self.bottomInset = bottomInset
        self.tabBarBottomPadding = tabBarBottomPadding
        self.bannerPosition = bannerPosition
    }

    func updateBannerPosition(_ position: BannerPosition) {
        bannerPosition = position
    }

    func updateBannerHeight(_ height: CGFloat) {}
    func updateTabBarHeight(_ height: CGFloat) {}
}
#endif

// ===== FILE: Timetable DSW/Services/Performance/PerformanceLogger.swift =====
import Foundation
import SwiftUI
import Combine
import os.log

// MARK: - Performance Event

struct PerformanceEvent: Identifiable, Sendable, Encodable {
    let id: UUID
    let timestamp: Date
    let category: PerformanceCategory
    let name: String
    let duration: TimeInterval?
    let metadata: [String: String]

    init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        category: PerformanceCategory,
        name: String,
        duration: TimeInterval? = nil,
        metadata: [String: String] = [:]
    ) {
        self.id = id
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.duration = duration
        self.metadata = metadata
    }

    var formattedDuration: String {
        guard let duration = duration else { return "N/A" }
        if duration < 0.001 {
            return String(format: "%.0f μs", duration * 1_000_000)
        } else if duration < 1.0 {
            return String(format: "%.1f ms", duration * 1000)
        } else {
            return String(format: "%.2f s", duration)
        }
    }

    var severityLevel: PerformanceSeverity {
        guard let duration = duration else { return .info }

        switch category {
        case .viewLoad, .viewAppear:
            if duration > 1.0 { return .critical }
            if duration > 0.5 { return .warning }
            if duration > 0.2 { return .info }
            return .success

        case .dataFetch, .apiCall:
            if duration > 5.0 { return .critical }
            if duration > 2.0 { return .warning }
            if duration > 1.0 { return .info }
            return .success

        case .computation:
            if duration > 0.5 { return .critical }
            if duration > 0.2 { return .warning }
            if duration > 0.1 { return .info }
            return .success

        case .rendering:
            if duration > 0.016 { return .warning } // 60fps target
            return .success

        case .custom:
            return .info
        }
    }
}

enum PerformanceCategory: String, Codable, CaseIterable, Sendable {
    case viewLoad = "View Load"
    case viewAppear = "View Appear"
    case dataFetch = "Data Fetch"
    case apiCall = "API Call"
    case computation = "Computation"
    case rendering = "Rendering"
    case custom = "Custom"
}

enum PerformanceSeverity: String, Codable, Sendable {
    case success = "✅"
    case info = "ℹ️"
    case warning = "⚠️"
    case critical = "🔴"

    var color: Color {
        switch self {
        case .success: return .green
        case .info: return .blue
        case .warning: return .orange
        case .critical: return .red
        }
    }
}

// MARK: - Performance Metrics

struct PerformanceMetrics: Sendable {
    var totalEvents: Int
    var averageDuration: TimeInterval
    var slowestEvent: PerformanceEvent?
    var fastestEvent: PerformanceEvent?
    var eventsByCategory: [PerformanceCategory: Int]

    static let empty = PerformanceMetrics(
        totalEvents: 0,
        averageDuration: 0,
        slowestEvent: nil,
        fastestEvent: nil,
        eventsByCategory: [:]
    )
}

// MARK: - Performance Timer

final class PerformanceTimer: @unchecked Sendable {
    private let startTime: CFAbsoluteTime
    private let category: PerformanceCategory
    private let name: String
    private let metadata: [String: String]
    private let logger: PerformanceLogger?

    init(
        category: PerformanceCategory,
        name: String,
        metadata: [String: String] = [:],
        logger: PerformanceLogger?
    ) {
        self.startTime = CFAbsoluteTimeGetCurrent()
        self.category = category
        self.name = name
        self.metadata = metadata
        self.logger = logger
    }

    func stop() {
        let duration = CFAbsoluteTimeGetCurrent() - startTime
        let event = PerformanceEvent(
            category: category,
            name: name,
            duration: duration,
            metadata: metadata
        )

        // Capture logger weakly to avoid retain cycle
        guard let logger = logger else { return }

        Task { @MainActor in
            logger.log(event: event)
        }
    }

    deinit {
        // NO Task in deinit - it creates retain cycle!
        // Timer will be stopped manually via stop()
    }
}

// MARK: - Performance Logger Service

@MainActor
final class PerformanceLogger: ObservableObject {

    // MARK: - Singleton

    static let shared = PerformanceLogger()

    // MARK: - Published State

    @Published private(set) var events: [PerformanceEvent] = []
    @Published private(set) var metrics: PerformanceMetrics = .empty
    @Published var isEnabled: Bool = false

    // MARK: - Configuration

    private let maxEventsToStore = 1000
    private let osLog = OSLog(subsystem: "com.timetable.dsw", category: "Performance")

    // MARK: - Initialization

    private init() {
        #if DEBUG
        isEnabled = true
        #endif
    }

    // MARK: - Public Methods

    /// Start timing an operation
    func startTimer(
        category: PerformanceCategory,
        name: String,
        metadata: [String: String] = [:]
    ) -> PerformanceTimer {
        PerformanceTimer(
            category: category,
            name: name,
            metadata: metadata,
            logger: isEnabled ? self : nil
        )
    }

    /// Log an event
    func log(event: PerformanceEvent) {
        guard isEnabled else { return }

        // Add to events array
        events.append(event)

        // Trim if needed
        if events.count > maxEventsToStore {
            events.removeFirst(events.count - maxEventsToStore)
        }

        // Update metrics
        updateMetrics()

        // Log to console/oslog
        logToConsole(event: event)
    }

    /// Log instant event without duration
    func logInstant(
        category: PerformanceCategory,
        name: String,
        metadata: [String: String] = [:]
    ) {
        let event = PerformanceEvent(
            category: category,
            name: name,
            duration: nil,
            metadata: metadata
        )
        log(event: event)
    }

    /// Clear all events
    func clear() {
        events.removeAll()
        metrics = .empty
    }

    /// Export events as JSON string
    func exportJSON() -> String? {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted

        guard let data = try? encoder.encode(events),
              let json = String(data: data, encoding: .utf8) else {
            return nil
        }

        return json
    }

    // MARK: - Private Methods

    private func updateMetrics() {
        let eventsWithDuration = events.compactMap { event -> (PerformanceEvent, TimeInterval)? in
            guard let duration = event.duration else { return nil }
            return (event, duration)
        }

        guard !eventsWithDuration.isEmpty else {
            metrics = .empty
            return
        }

        let totalDuration = eventsWithDuration.reduce(0.0) { $0 + $1.1 }
        let averageDuration = totalDuration / Double(eventsWithDuration.count)

        let slowest = eventsWithDuration.max(by: { $0.1 < $1.1 })?.0
        let fastest = eventsWithDuration.min(by: { $0.1 < $1.1 })?.0

        var categoryCounts: [PerformanceCategory: Int] = [:]
        for event in events {
            categoryCounts[event.category, default: 0] += 1
        }

        metrics = PerformanceMetrics(
            totalEvents: events.count,
            averageDuration: averageDuration,
            slowestEvent: slowest,
            fastestEvent: fastest,
            eventsByCategory: categoryCounts
        )
    }

    private func logToConsole(event: PerformanceEvent) {
        let severity = event.severityLevel
        let durationStr = event.formattedDuration
        let metadataStr = event.metadata.isEmpty ? "" : " | \(event.metadata)"

        let message = "[\(event.category.rawValue)] \(event.name): \(durationStr)\(metadataStr)"

        // Log based on severity
        switch severity {
        case .success:
            os_log(.debug, log: osLog, "%{public}@", message)
        case .info:
            os_log(.info, log: osLog, "%{public}@", message)
        case .warning:
            os_log(.default, log: osLog, "⚠️ %{public}@", message)
        case .critical:
            os_log(.error, log: osLog, "🔴 %{public}@", message)
        }

        #if DEBUG
        print("[\(severity.rawValue) Performance] \(message)")
        #endif
    }
}

// MARK: - SwiftUI View Extensions

extension View {
    /// Measure view appearance time
    func measurePerformance(
        name: String,
        category: PerformanceCategory = .viewAppear,
        metadata: [String: String] = [:]
    ) -> some View {
        self.modifier(
            PerformanceMeasurementModifier(
                name: name,
                category: category,
                metadata: metadata
            )
        )
    }
}

private struct PerformanceMeasurementModifier: ViewModifier {
    let name: String
    let category: PerformanceCategory
    let metadata: [String: String]

    @State private var timer: PerformanceTimer?
    @State private var hasAppeared = false

    func body(content: Content) -> some View {
        content
            .onAppear {
                // Start timing on first appear
                if !hasAppeared {
                    hasAppeared = true
                    timer = PerformanceLogger.shared.startTimer(
                        category: category,
                        name: name,
                        metadata: metadata
                    )

                    // Stop immediately after the view appears (next frame)
                    // This measures view load time, not screen time
                    DispatchQueue.main.async {
                        timer?.stop()
                        timer = nil
                    }
                }
            }
            .onDisappear {
                // Cleanup if needed
                timer?.stop()
                timer = nil
                hasAppeared = false
            }
    }
}

// MARK: - Environment Key

private struct PerformanceLoggerKey: EnvironmentKey {
    static let defaultValue: PerformanceLogger = .shared
}

extension EnvironmentValues {
    var performanceLogger: PerformanceLogger {
        get { self[PerformanceLoggerKey.self] }
        set { self[PerformanceLoggerKey.self] = newValue }
    }
}

// ===== FILE: Timetable DSW/ViewModels/AppViewModel.swift =====
import Combine
import Foundation
import WidgetKit

@MainActor
final class AppViewModel: ObservableObject, EventsProviderProtocol {
    // MARK: - Configuration

    struct Configuration {
        struct Constants {
            let scheduleFrom = "2025-09-06"
            let scheduleTo = "2026-02-08"
        }

        static let constants = Constants()
    }

    // MARK: - Performance Cache
    private let eventTypeDetector: EventTypeDetector
    private var eventsDayTypeCache: [String: EventDayType] = [:]
    private var eventsCacheVersion = UUID()
    private var currentLoadToken = UUID()
    private var didApplyFullAggregate = false

    @Published var scheduleData: AggregateResponse? {
        didSet {
            if scheduleData?.groupSchedule != oldValue?.groupSchedule {
                invalidateEventsCache()
            }
        }
    }

    // MARK: - Published Properties

    @Published var isLoading = false
    @Published var isLoadingTeachers = false
    @Published var isLoadingGroups = false
    @Published var isRefreshing = false
    @Published var errorMessage: String?
    @Published var lastUpdated: Date?
    @Published var isOffline = false
    @Published var groups: [GroupInfo] = []

    // MARK: - Properties

    private let repository: ScheduleRepository
    private let userDefaults: UserDefaults

    // MARK: - User Defaults Keys

    private enum UserDefaultsKey {
        static let groupId = "groupId"
        static let lastUpdated = "lastUpdated"
    }

    // MARK: - Computed Properties

    var groupId: Int {
        get { userDefaults.integer(forKey: UserDefaultsKey.groupId) }
        set { userDefaults.set(newValue, forKey: UserDefaultsKey.groupId) }
    }

    var selectedGroupName: String? {
        groups.first(where: { $0.groupId == groupId })?.displayName
    }

    // MARK: - Initialization

    init(repository: ScheduleRepository,
         userDefaults: UserDefaults = .standard,
         eventTypeDetector: EventTypeDetector = DefaultEventTypeDetector()) {
        self.repository = repository
        self.userDefaults = userDefaults
        self.eventTypeDetector = eventTypeDetector
    }

    // MARK: - Groups Loading

    func loadGroupsIfNeeded() async {
        guard groups.isEmpty else { return }

        groups = await repository.getCachedGroups() ?? []

        if groups.isEmpty {
            await loadGroups()
        }
    }

    func loadGroups() async {
        isLoadingGroups = true
        defer { isLoadingGroups = false }

        do {
            let fetchedGroups = try await repository.getGroups()
            groups = fetchedGroups.sorted { $0.displayName < $1.displayName }
        } catch {
            print("Failed to load groups: \(error)")
        }
    }

    // MARK: - Schedule Loading

    func loadSchedule() async {
        guard groupId > 0 else {
            errorMessage = LocalizedString.settingsPleaseSelectGroup.localized
            return
        }

        await loadCachedScheduleIfNeeded()

        // 🆕 новый цикл загрузки → новый токен
        let loadToken = UUID()
        currentLoadToken = loadToken
        didApplyFullAggregate = false

        isLoading = scheduleData == nil
        isLoadingTeachers = (scheduleData?.teachers ?? []).isEmpty
        isRefreshing = scheduleData != nil
        errorMessage = nil

        await fetchFreshSchedule(loadToken: loadToken)
    }

    private func loadCachedScheduleIfNeeded() async {
        guard scheduleData == nil else { return }

        scheduleData = await repository.getCachedSchedule()
        if scheduleData != nil {
            lastUpdated = userDefaults.object(forKey: UserDefaultsKey.lastUpdated) as? Date
        }
    }

    private func fetchFreshSchedule(loadToken: UUID) async {
            do {
                let fresh = try await repository.getScheduleWithRace(
                    groupId: groupId,
                    from: Configuration.constants.scheduleFrom,
                    to: Configuration.constants.scheduleTo,
                    existingTeachers: self.scheduleData?.teachers ?? [],
                    onSemesterSchedule: { [weak self] semesterSchedule in
                        guard let self = self else { return }
                        // ✅ Применяем семестровые данные только если:
                        //    - это актуальный запрос
                        //    - ещё НЕ применяли полный aggregate
                        guard self.currentLoadToken == loadToken,
                              self.didApplyFullAggregate == false else { return }

                        let partialResponse = AggregateResponse(from: semesterSchedule, teachers: self.scheduleData?.teachers ?? [])
                        self.scheduleData = partialResponse
                        self.isLoading = false
                        self.isLoadingTeachers = partialResponse.teachers.isEmpty

                        AppGroupManager.saveSemesterSchedule(semesterSchedule)
                        AppGroupManager.saveSelectedGroupId(self.groupId)
                        AppGroupManager.saveLastUpdated(Date())
                        WidgetCenter.shared.reloadAllTimelines()
                    }
                )

                // ✅ Применяем полный aggregate только если запрос актуален
                guard currentLoadToken == loadToken else { return }
                didApplyFullAggregate = true

                scheduleData = fresh
                updateLastUpdatedTimestamp()
                isOffline = false
            } catch {
                // Ошибка по aggregate — пробуем кэш (уже подхватывался выше), помечаем оффлайн
                errorMessage = error.localizedDescription
                isOffline = true
            }

            isLoading = false
        isLoadingTeachers = false
            isRefreshing = false
        }

    private func updateLastUpdatedTimestamp() {
        lastUpdated = Date()
        userDefaults.set(lastUpdated, forKey: UserDefaultsKey.lastUpdated)
    }

    func refresh() async {
        await loadSchedule()
    }

    // MARK: - Cache Management

    func clearCache() async {
        do {
            try await repository.clearScheduleCache()
            scheduleData = nil
            lastUpdated = nil
            userDefaults.removeObject(forKey: UserDefaultsKey.lastUpdated)
        } catch {
            print("Failed to clear cache: \(error)")
        }
    }

    // MARK: - EventsProviderProtocol

    private func cacheKey(for date: Date) -> String {
        let calendar = Calendar.current
        let components = calendar.dateComponents([.year, .month, .day], from: date)
        return "\(eventsCacheVersion)-\(components.year!)-\(components.month!)-\(components.day!)"
    }

    private func invalidateEventsCache() {
        eventsDayTypeCache.removeAll()
        eventsCacheVersion = UUID()
    }

    func hasEventsOn(date: Date) -> Bool {
        eventType(on: date) != .none
    }

    func eventsForDate(_ date: Date) -> [ScheduleEvent] {
        guard let scheduleData = scheduleData else { return [] }

        return scheduleData.groupSchedule.filter { event in
            guard let eventDate = event.startDate else { return false }
            return Calendar.current.isDate(eventDate, inSameDayAs: date)
        }
    }

    func eventType(on date: Date) -> EventDayType {
        let key = cacheKey(for: date)
        if let cached = eventsDayTypeCache[key] { return cached }

        let events = eventsForDate(date)
        let value: EventDayType
        if events.isEmpty {
            value = .none
        } else {
            let allOnline = events.allSatisfy { ev in
                eventTypeDetector.isOnline(remarks: ev.remarks)
            }
            value = allOnline ? .onlineOnly : .regular
        }
        eventsDayTypeCache[key] = value
        return value
    }
}

// ===== FILE: TimetableWidget/AppGroupManager.swift =====
import Foundation

struct AppGroupManager {
    // ВАЖНО: Замените на свой App Group ID из Xcode
    static let appGroupIdentifier = "group.org.laptenok.Timetable-DSW.rl"

    static var sharedDefaults: UserDefaults? {
        UserDefaults(suiteName: appGroupIdentifier)
    }

    // Keys для хранения данных
    struct Keys {
        static let semesterSchedule = "widget_semester_schedule"
        static let selectedGroupId = "widget_selected_group_id"
        static let selectedThemeId = "widget_selected_theme_id"
        static let appearanceMode = "widget_appearance_mode"
        static let lastUpdated = "widget_last_updated"
    }

    // MARK: - Save Methods

    static func saveSemesterSchedule(_ schedule: GroupScheduleResponse) {
        guard let data = try? JSONEncoder().encode(schedule) else { return }
        sharedDefaults?.set(data, forKey: Keys.semesterSchedule)
    }

    static func saveSelectedGroupId(_ groupId: Int) {
        sharedDefaults?.set(groupId, forKey: Keys.selectedGroupId)
    }

    static func saveSelectedTheme(id: String, appearanceMode: String) {
        sharedDefaults?.set(id, forKey: Keys.selectedThemeId)
        sharedDefaults?.set(appearanceMode, forKey: Keys.appearanceMode)
    }

    static func saveLastUpdated(_ date: Date) {
        sharedDefaults?.set(date, forKey: Keys.lastUpdated)
    }

    // MARK: - Load Methods

    static func loadSemesterSchedule() -> GroupScheduleResponse? {
        guard let data = sharedDefaults?.data(forKey: Keys.semesterSchedule),
              let schedule = try? JSONDecoder().decode(GroupScheduleResponse.self, from: data) else {
            return nil
        }
        return schedule
    }

    static func loadSelectedGroupId() -> Int? {
        guard let groupId = sharedDefaults?.integer(forKey: Keys.selectedGroupId), groupId > 0 else {
            return nil
        }
        return groupId
    }

    static func loadSelectedThemeId() -> String? {
        sharedDefaults?.string(forKey: Keys.selectedThemeId)
    }

    static func loadAppearanceMode() -> String? {
        sharedDefaults?.string(forKey: Keys.appearanceMode)
    }

    static func loadLastUpdated() -> Date? {
        sharedDefaults?.object(forKey: Keys.lastUpdated) as? Date
    }
}

// ===== FILE: TimetableWidget/Default/TimetableWidgetControl.swift =====
import AppIntents
import SwiftUI
import WidgetKit

struct TimetableWidgetControl: ControlWidget {
    static let kind: String = "org.laptenok.Timetable-DSW.rl.TimetableWidget"

    var body: some ControlWidgetConfiguration {
        AppIntentControlConfiguration(
            kind: Self.kind,
            provider: Provider()
        ) { value in
            ControlWidgetToggle(
                "Start Timer",
                isOn: value.isRunning,
                action: StartTimerIntent(value.name)
            ) { isRunning in
                Label(isRunning ? "On" : "Off", systemImage: "timer")
            }
        }
        .displayName("Timer")
        .description("A an example control that runs a timer.")
    }
}

extension TimetableWidgetControl {
    struct Value {
        var isRunning: Bool
        var name: String
    }

    struct Provider: AppIntentControlValueProvider {
        func previewValue(configuration: TimerConfiguration) -> Value {
            TimetableWidgetControl.Value(isRunning: false, name: configuration.timerName)
        }

        func currentValue(configuration: TimerConfiguration) async throws -> Value {
            let isRunning = true // Check if the timer is running
            return TimetableWidgetControl.Value(isRunning: isRunning, name: configuration.timerName)
        }
    }
}

struct TimerConfiguration: ControlConfigurationIntent {
    static let title: LocalizedStringResource = "Timer Name Configuration"

    @Parameter(title: "Timer Name", default: "Timer")
    var timerName: String
}

struct StartTimerIntent: SetValueIntent {
    static let title: LocalizedStringResource = "Start a timer"

    @Parameter(title: "Timer Name")
    var name: String

    @Parameter(title: "Timer is running")
    var value: Bool

    init() {}

    init(_ name: String) {
        self.name = name
    }

    func perform() async throws -> some IntentResult {
        // Start the timer…
        return .result()
    }
}

// ===== FILE: TimetableWidget/Default/TimetableWidgetLiveActivity.swift =====
import ActivityKit
import WidgetKit
import SwiftUI

struct TimetableWidgetAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        // Dynamic stateful properties about your activity go here!
        var emoji: String
    }

    // Fixed non-changing properties about your activity go here!
    var name: String
}

struct TimetableWidgetLiveActivity: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: TimetableWidgetAttributes.self) { context in
            // Lock screen/banner UI goes here
            VStack {
                Text("Hello \(context.state.emoji)")
            }
            .activityBackgroundTint(Color.cyan)
            .activitySystemActionForegroundColor(Color.black)

        } dynamicIsland: { context in
            DynamicIsland {
                // Expanded UI goes here.  Compose the expanded UI through
                // various regions, like leading/trailing/center/bottom
                DynamicIslandExpandedRegion(.leading) {
                    Text("Leading")
                }
                DynamicIslandExpandedRegion(.trailing) {
                    Text("Trailing")
                }
                DynamicIslandExpandedRegion(.bottom) {
                    Text("Bottom \(context.state.emoji)")
                    // more content
                }
            } compactLeading: {
                Text("L")
            } compactTrailing: {
                Text("T \(context.state.emoji)")
            } minimal: {
                Text(context.state.emoji)
            }
            .widgetURL(URL(string: "http://www.apple.com"))
            .keylineTint(Color.red)
        }
    }
}

extension TimetableWidgetAttributes {
    fileprivate static var preview: TimetableWidgetAttributes {
        TimetableWidgetAttributes(name: "World")
    }
}

extension TimetableWidgetAttributes.ContentState {
    fileprivate static var smiley: TimetableWidgetAttributes.ContentState {
        TimetableWidgetAttributes.ContentState(emoji: "😀")
     }
     
     fileprivate static var starEyes: TimetableWidgetAttributes.ContentState {
         TimetableWidgetAttributes.ContentState(emoji: "🤩")
     }
}

#Preview("Notification", as: .content, using: TimetableWidgetAttributes.preview) {
   TimetableWidgetLiveActivity()
} contentStates: {
    TimetableWidgetAttributes.ContentState.smiley
    TimetableWidgetAttributes.ContentState.starEyes
}

// ===== FILE: TimetableWidget/TimetableControlWidget.swift =====
import AppIntents
import SwiftUI
import WidgetKit

@available(iOS 18.0, *)
struct TimetableControlWidget: ControlWidget {
    var body: some ControlWidgetConfiguration {
        StaticControlConfiguration(kind: "com.timetable.control") {
            ControlWidgetButton(action: OpenTimetableIntent()) { 
                Label(LocalizedString.controlOpenScheduleLabel.localized, systemImage: "calendar")
            }
        }
        .displayName(LocalizedString.controlOpenScheduleDisplayName.resource)
        .description(LocalizedString.controlOpenScheduleDescription.resource)
    }
}

@available(iOS 18.0, *)
struct TimetableToggleControl: ControlWidget {
    var body: some ControlWidgetConfiguration {
        AppIntentControlConfiguration(
            kind: "com.timetable.toggle",
            provider: TimetableToggleProvider()
        ) { value in
            ControlWidgetToggle(
                isOn: value.hasClasses,
                action: RefreshScheduleIntent()
            ) { 
                Label(LocalizedString.controlToggleLabel.localized, systemImage: "calendar")
            } valueLabel: { isOn in
                Text(isOn ? LocalizedString.statusActive.localized : LocalizedString.statusNoClasses.localized)
            }
        }
        .displayName(LocalizedString.controlToggleDisplayName.resource)
        .description(LocalizedString.controlToggleDescription.resource)
    }
}

@available(iOS 18.0, *)
struct TimetableControlValue {
    var hasClasses: Bool
    var status: String { hasClasses ? "ON" : "OFF" }
}

@available(iOS 18.0, *)
struct TimetableToggleProvider: AppIntentControlValueProvider {
    typealias Value = TimetableControlValue
    typealias Configuration = ConfigurationIntent

    func currentValue(configuration: Configuration) async throws -> Value {
        let schedule = AppGroupManager.loadSemesterSchedule()
        let today = Date()
        let hasClasses = schedule?.groupSchedule.contains {
            guard let d = $0.startDate else { return false }
            return Calendar.current.isDate(d, inSameDayAs: today)
        } ?? false
        return TimetableControlValue(hasClasses: hasClasses)
    }

    func previewValue(configuration: Configuration) -> Value {
        TimetableControlValue(hasClasses: true)
    }
}

// MARK: - App Intents

struct OpenTimetableIntent: AppIntent { // fixnik locale
    static var title: LocalizedStringResource = "Open Timetable"
    static var description: IntentDescription = IntentDescription("Open the timetable")
    static var openAppWhenRun: Bool = true
    func perform() async throws -> some IntentResult { .result() }
}

struct ShowTodayScheduleIntent: AppIntent {
    static var title: LocalizedStringResource = "Show Today's Schedule"
    static var description: IntentDescription = IntentDescription("Open today's schedule")
    static var openAppWhenRun: Bool = true
    func perform() async throws -> some IntentResult { .result() }
}

struct ShowNextClassIntent: AppIntent {
    static var title: LocalizedStringResource = "Show Next Class"
    static var description: IntentDescription = IntentDescription("Open the next class")
    static var openAppWhenRun: Bool = true
    func perform() async throws -> some IntentResult { .result() }
}

@available(iOS 18.0, *)
struct RefreshScheduleIntent: SetValueIntent {
    static var title: LocalizedStringResource = "Refresh Schedule"

    @Parameter(title: "Enabled")
    var value: Bool

    static var openAppWhenRun: Bool = false

    func perform() async throws -> some IntentResult {
        WidgetCenter.shared.reloadAllTimelines()
        return .result()
    }
}

@available(iOS 18.0, *)
struct ConfigurationIntent: ControlConfigurationIntent {
    static var title: LocalizedStringResource = "Timetable Controls"
}

// ===== FILE: TimetableWidget/TimetableLiveActivity.swift =====
//
//  TimetableLiveActivity.swift
//  TimetableWidget
//
//  Created by Claude on 23/10/2025.
//

import ActivityKit
import WidgetKit
import SwiftUI

struct TimetableLiveActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var eventTitle: String
        var eventType: String?
        var room: String?
        var startTime: Date
        var endTime: Date
        var teacherName: String?
        var isOnline: Bool
        var progress: Double
    }
    var groupId: Int
    var themeId: String
}

struct TimetableLiveActivity: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: TimetableLiveActivityAttributes.self) { context in
            LockScreenLiveActivityView(context: context)
        } dynamicIsland: { context in
            DynamicIsland {
                DynamicIslandExpandedRegion(.leading) {
                    eventIcon(for: context.state.eventType, isOnline: context.state.isOnline)
                }
                DynamicIslandExpandedRegion(.trailing) {
                    timeRemaining(context: context)
                }
                DynamicIslandExpandedRegion(.center) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(context.state.eventTitle)
                            .font(.headline)
                            .lineLimit(1)

                        if let room = context.state.room, !room.isEmpty {
                            Label(room, systemImage: "location.fill")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        if let teacher = context.state.teacherName {
                            Text(teacher)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                DynamicIslandExpandedRegion(.bottom) {
                    progressBar(progress: context.state.progress)
                }
            } compactLeading: {
                eventIcon(for: context.state.eventType, isOnline: context.state.isOnline)
            } compactTrailing: {
                Text(timerInterval: context.state.startTime...context.state.endTime, countsDown: false)
                    .multilineTextAlignment(.trailing)
                    .frame(width: 50)
                    .font(.caption2.monospacedDigit())
            } minimal: {
                eventIcon(for: context.state.eventType, isOnline: context.state.isOnline)
            }
        }
    }

    private func eventIcon(for type: String?, isOnline: Bool) -> some View {
        ZStack {
            Circle()
                .fill(eventColor(for: type).gradient)
                .frame(width: 30, height: 30)
            Image(systemName: isOnline ? "wifi" : eventSymbol(for: type))
                .font(.system(size: 12))
                .foregroundColor(.white)
        }
    }

    private func timeRemaining(context: ActivityViewContext<TimetableLiveActivityAttributes>) -> some View {
        VStack(alignment: .trailing, spacing: 2) {
            Text(LocalizedString.liveEnds.localized)
                .font(.caption2)
                .foregroundColor(.secondary)

            Text(context.state.endTime, style: .time)
                .font(.caption.bold())
                .monospacedDigit()
        }
    }

    private func progressBar(progress: Double) -> some View {
        VStack(spacing: 4) {
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    Capsule()
                        .fill(Color.secondary.opacity(0.3))
                        .frame(height: 4)
                    Capsule()
                        .fill(LinearGradient(colors: [.blue, .cyan], startPoint: .leading, endPoint: .trailing))
                        .frame(width: geometry.size.width * max(0, min(1, progress)), height: 4)
                }
            }
            .frame(height: 4)

            HStack {
                Text("\(Int(progress * 100))% \(LocalizedString.livePercentCompleteSuffix.localized)")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Spacer()
            }
        }
    }

    private func eventColor(for type: String?) -> Color {
        switch type?.lowercased() {
        case "lecture", "лекция": return Color(red: 1.0, green: 0.5, blue: 0.0)
        case "exercise", "упражнение": return Color(red: 0.1, green: 0.6, blue: 1.0)
        case "laboratory", "лабораторная": return Color(red: 0.7, green: 0.2, blue: 0.9)
        default: return .blue
        }
    }

    private func eventSymbol(for type: String?) -> String {
        switch type?.lowercased() {
        case "lecture", "лекция": return "book.fill"
        case "exercise", "упражнение": return "pencil"
        case "laboratory", "лабораторная": return "flask.fill"
        default: return "calendar"
        }
    }
}

struct LockScreenLiveActivityView: View {
    let context: ActivityViewContext<TimetableLiveActivityAttributes>
    @Environment(\.colorScheme) var colorScheme
    private var theme: any Theme { ThemeFactory.theme(withId: context.attributes.themeId, for: colorScheme) }

    var body: some View {
        VStack(spacing: 10) {
            HStack(spacing: 8) {
                eventIcon(for: context.state.eventType, isOnline: context.state.isOnline)

                VStack(alignment: .leading, spacing: 2) {
                    Text(context.state.eventTitle)
                        .font(.headline)
                        .lineLimit(1)
                    if let room = context.state.room, !room.isEmpty {
                        Label(room, systemImage: "location.fill")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }

                Spacer(minLength: 8)

                VStack(alignment: .trailing, spacing: 2) {
                    Text(LocalizedString.liveEnds.localized)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text(context.state.endTime, style: .time)
                        .font(.caption.bold())
                        .monospacedDigit()
                }
            }

            GeometryReader { geo in
                ZStack(alignment: .leading) {
                    Capsule().fill(Color.secondary.opacity(0.3)).frame(height: 6)
                    Capsule().fill(LinearGradient(colors: [theme.primary, theme.secondary],
                                                  startPoint: .leading, endPoint: .trailing))
                        .frame(width: geo.size.width * max(0, min(1, context.state.progress)), height: 6)
                }
            }
            .frame(height: 6)

            HStack {
                if let teacher = context.state.teacherName {
                    Text(teacher).font(.caption).foregroundColor(.secondary)
                }
                Spacer()
                Text("\(Int(context.state.progress * 100))% \(LocalizedString.livePercentCompleteSuffix.localized)")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
    }

    private func eventIcon(for type: String?, isOnline: Bool) -> some View {
        ZStack {
            Circle().fill(eventColor(for: type).gradient).frame(width: 36, height: 36)
            Image(systemName: isOnline ? "wifi" : eventSymbol(for: type))
                .font(.system(size: 16))
                .foregroundColor(.white)
        }
    }

    private func eventColor(for type: String?) -> Color {
        switch type?.lowercased() {
        case "lecture", "лекция": return Color(red: 1.0, green: 0.5, blue: 0.0)
        case "exercise", "упражнение": return Color(red: 0.1, green: 0.6, blue: 1.0)
        case "laboratory", "лабораторная": return Color(red: 0.7, green: 0.2, blue: 0.9)
        default: return theme.primary
        }
    }

    private func eventSymbol(for type: String?) -> String {
        switch type?.lowercased() {
        case "lecture", "лекция": return "book.fill"
        case "exercise", "упражнение": return "pencil"
        case "laboratory", "лабораторная": return "flask.fill"
        default: return "calendar"
        }
    }
}


//#Preview(
//    "Live Activity — compact",
//    as: .dynamicIsland(.minimal),
//    using: TimetableLiveActivityAttributes(groupId: 1, themeId: "default")
//) {
//    TimetableLiveActivity()
//} contentStates: {
//    TimetableLiveActivityAttributes.ContentState(
//        eventTitle: "Discrete Math",
//        eventType: "lecture",
//        room: "A-201",
//        startTime: .now,
//        endTime: .now.addingTimeInterval(5400),
//        teacherName: "Dr. Kowalski",
//        isOnline: false,
//        progress: 0.35
//    )
//}

//#Preview(
//    "Live Activity — expanded",
//    as: .dynamicIsland(.expanded),
//    using: TimetableLiveActivityAttributes(groupId: 1, themeId: "default")
//) {
//    TimetableLiveActivity()
//} contentStates: {
//    TimetableLiveActivityAttributes.ContentState(
//        eventTitle: "Discrete Math",
//        eventType: "lecture",
//        room: "A-201",
//        startTime: .now,
//        endTime: .now.addingTimeInterval(5400),
//        teacherName: "Dr. Kowalski",
//        isOnline: false,
//        progress: 0.7
//    )
//}

// ===== FILE: TimetableWidget/TimetableWidget.swift =====
import WidgetKit
import SwiftUI
import AppIntents

struct TimetableWidget: Widget {
    let kind: String = "TimetableWidget"

    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: kind,
            intent: TimetableWidgetProvider.Intent.self,
            provider: TimetableWidgetProvider(),
            content: { entry in
                TimetableWidgetEntryView(entry: entry)
                    .containerBackground(for: .widget) { Color.clear }
            }
        )
        .contentMarginsDisabled()                // убрали системные поля
        .containerBackgroundRemovable(true)
        .configurationDisplayName("Timetable")
        .description("View your class schedule at a glance")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}

struct TimetableWidgetEntryView: View {
    var entry: TimetableWidgetEntry

    @Environment(\.widgetFamily) var widgetFamily

    var body: some View {
        switch widgetFamily {
        case .systemSmall:
            SmallWidgetView(entry: entry)
        case .systemMedium:
            MediumWidgetView(entry: entry)
        case .systemLarge:
            LargeWidgetView(entry: entry)
        default:
            SmallWidgetView(entry: entry)
        }
    }
}

#Preview(as: .systemSmall) {
    TimetableWidget()
} timeline: {
    TimetableWidgetEntry(
        date: .now,
        schedule: nil,
        selectedThemeId: "default",
        appearanceMode: "system",
        configuration: nil
    )
}

#Preview(as: .systemMedium) {
    TimetableWidget()
} timeline: {
    TimetableWidgetEntry(
        date: .now,
        schedule: nil,
        selectedThemeId: "default",
        appearanceMode: "system",
        configuration: nil
    )
}

#Preview(as: .systemLarge) {
    TimetableWidget()
} timeline: {
    TimetableWidgetEntry(
        date: .now,
        schedule: nil,
        selectedThemeId: "default",
        appearanceMode: "system",
        configuration: nil
    )
}

// ===== FILE: TimetableWidget/TimetableWidgetBundle.swift =====
import WidgetKit
import SwiftUI

@main
struct TimetableWidgetBundle: WidgetBundle {
    var body: some Widget {
        // Main widget with different sizes
        TimetableWidget()
        
        // Live Activity for current class tracking
//        TimetableLiveActivity()
        
        // Control Center widget
//        TimetableControlWidget()
    }
}

// ===== FILE: TimetableWidget/TimetableWidgetEntry.swift =====
import WidgetKit
import SwiftUI
import AppIntents

struct TimetableWidgetEntry: TimelineEntry {
    let date: Date
    let schedule: GroupScheduleResponse?
    let selectedThemeId: String
    let appearanceMode: String
    let configuration: (any WidgetConfigurationIntent)?

    var shouldShowOnline: Bool {
        (configuration as? ConfigurationAppIntent)?.showOnlineStatus ?? true
    }

    // события только за сегодня (и не отменённые)
    var todayEvents: [ScheduleEvent] {
        guard let schedule = schedule else { return [] }

        return schedule.groupSchedule
            .filter { event in
                guard
                    !event.isCancelled(),
                    let eventDate = event.startDate
                else { return false }

                return Calendar.current.isDate(eventDate, inSameDayAs: date)
            }
            .sorted {
                ($0.startDate ?? .distantPast) < ($1.startDate ?? .distantPast)
            }
    }

    // события по дням недели (аналогично фильтр)
    var weekEvents: [Date: [ScheduleEvent]] {
        guard let schedule = schedule else { return [:] }

        let calendar = Calendar.current
        let startOfWeek = calendar.date(
            from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)
        ) ?? date

        var result: [Date: [ScheduleEvent]] = [:]

        for dayOffset in 0..<7 {
            guard let day = calendar.date(byAdding: .day, value: dayOffset, to: startOfWeek)
            else { continue }

            let dayEvents = schedule.groupSchedule
                .filter { event in
                    guard
                        !event.isCancelled(),
                        let eventDate = event.startDate
                    else { return false }

                    return calendar.isDate(eventDate, inSameDayAs: day)
                }
                .sorted {
                    ($0.startDate ?? .distantPast) < ($1.startDate ?? .distantPast)
                }

            if !dayEvents.isEmpty {
                result[day] = dayEvents
            }
        }

        return result
    }

    // Текущая пара (первая, которая идёт прямо сейчас)
    var currentEvent: ScheduleEvent? {
        todayEvents.first { ev in
            guard let s = ev.startDate, let e = ev.endDate else { return false }
            return date >= s && date <= e
        }
    }

    // Следующая пара после "сейчас"
    var nextEvent: ScheduleEvent? {
        todayEvents.first { ev in
            guard let s = ev.startDate else { return false }
            return s > date
        }
    }
}

// ===== FILE: TimetableWidget/TimetableWidgetProvider.swift =====
import WidgetKit
import SwiftUI
import AppIntents

struct TimetableWidgetProvider: AppIntentTimelineProvider {
    typealias Intent = ConfigurationAppIntent
    typealias Entry = TimetableWidgetEntry

    func placeholder(in context: Context) -> TimetableWidgetEntry {
        TimetableWidgetEntry(
            date: Date(),
            schedule: nil,
            selectedThemeId: "default",
            appearanceMode: "system",
            configuration: nil
        )
    }

    func snapshot(for configuration: Intent, in context: Context) async -> TimetableWidgetEntry {
        let schedule = AppGroupManager.loadSemesterSchedule()
        let themeId = AppGroupManager.loadSelectedThemeId() ?? "default"
        let appearanceMode = AppGroupManager.loadAppearanceMode() ?? "system"

        return TimetableWidgetEntry(
            date: Date(),
            schedule: schedule,
            selectedThemeId: themeId,
            appearanceMode: appearanceMode,
            configuration: configuration   // <—
        )
    }

    func timeline(for configuration: Intent, in context: Context) async -> Timeline<TimetableWidgetEntry> {
        let schedule = AppGroupManager.loadSemesterSchedule()
        let themeId = AppGroupManager.loadSelectedThemeId() ?? "default"
        let appearanceMode = AppGroupManager.loadAppearanceMode() ?? "system"
        let currentDate = Date()
        var entries: [TimetableWidgetEntry] = []

        let baseEntry = { (date: Date) in
            TimetableWidgetEntry(
                date: date,
                schedule: schedule,
                selectedThemeId: themeId,
                appearanceMode: appearanceMode,
                configuration: configuration    // <—
            )
        }

        // точка "сейчас"
        entries.append(baseEntry(currentDate))

        // добавить апдейты на старты/концы занятий:
        let calendar = Calendar.current
        if let eventsToday = schedule?.groupSchedule
            .filter({ e in
                guard !e.isCancelled(), let d = e.startDate else { return false }
                return calendar.isDate(d, inSameDayAs: currentDate)
            })
            .sorted(by: { ($0.startDate ?? .distantPast) < ($1.startDate ?? .distantPast) })
        {
            for ev in eventsToday {
                if let st = ev.startDate, st > currentDate {
                    entries.append(baseEntry(st))
                }
                if let en = ev.endDate, en > currentDate {
                    entries.append(baseEntry(en))
                }
            }
        }

        // резерв: завтра утром
        if entries.count == 1,
           let tomorrow = calendar.date(byAdding: .day, value: 1, to: currentDate),
           let tMorning = calendar.date(bySettingHour: 6, minute: 0, second: 0, of: tomorrow) {
            entries.append(baseEntry(tMorning))
        }

        entries.sort { $0.date < $1.date }
        let nextUpdate = entries.last?.date.addingTimeInterval(3600) ?? currentDate.addingTimeInterval(3600)

        return Timeline(entries: entries, policy: .after(nextUpdate))
    }
}

// ===== FILE: TimetableWidget/TimetableWidgetViews.swift =====
import SwiftUI
import WidgetKit

// MARK: - Helpers

/// Создаёт короткую аббревиатуру дисциплины (до 5 символов)
private func eventAbbreviation(from title: String) -> String {
    let words = title
        .replacingOccurrences(of: "·", with: " ")
        .replacingOccurrences(of: "—", with: " ")
        .split { $0.isWhitespace || $0.isNewline || $0.isPunctuation }
        .map(String.init)

    var result = words.compactMap { $0.first?.uppercased() }.joined()
    if result.count < 2 {
        result = title
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .uppercased()
    }
    return String(result.prefix(5))
}

/// Время в формате "HH:mm-HH:mm" с коротким дефисом
private func timeRange(_ start: Date?, _ end: Date?) -> String {
    switch (start, end) {
    case let (s?, e?):
        return "\(s.formatted(date: .omitted, time: .shortened))-\(e.formatted(date: .omitted, time: .shortened))"
    case let (s?, nil):
        return s.formatted(date: .omitted, time: .shortened)
    case let (nil, e?):
        return e.formatted(date: .omitted, time: .shortened)
    default:
        return ""
    }
}

/// Цвет акцента для пары.
/// Вместо хардкода используем цвета текущей темы:
///  - lecture  → theme.lectureStart
///  - exercise → theme.exerciseStart
///  - lab      → theme.laboratoryStart
///  - other    → theme.primary (фоллбэк)
private func eventAccentColor(for event: ScheduleEvent, theme: any Theme) -> Color {
    switch event.eventType() {
    case .lecture:
        return theme.lectureStart
    case .exercise:
        return theme.exerciseStart
    case .laboratory:
        return theme.laboratoryStart
    case .other:
        return theme.primary
    }
}

/// Для упорядочивания дней недели (Пн=1 ... Вс=7)
private func weekdayRank(_ date: Date, calendar: Calendar = .current) -> Int {
    let wd = calendar.component(.weekday, from: date) // 1=Sun..7=Sat
    return wd == 1 ? 7 : wd - 1
}

// MARK: - SMALL

struct SmallWidgetView: View {
    let entry: TimetableWidgetEntry

    @Environment(\.colorScheme) var colorScheme
    private var theme: any Theme {
        ThemeFactory.theme(withId: entry.selectedThemeId, for: colorScheme)
    }

    private let maxRowsTotal = 5

    var body: some View {
        let now = entry.date

        // фильтруем отменённые пары через общую логику
        let events = entry.todayEvents.filter { !$0.isCancelled() }

        // индексы всех активных пар (могут идти одновременно)
        let activeIdxs: [Int] = events.enumerated().compactMap { idx, ev in
            guard let s = ev.startDate, let e = ev.endDate else { return nil }
            return (now >= s && now <= e) ? idx : nil
        }

        return VStack(alignment: .leading, spacing: 5) {

            // HEADER "TODAY"
            Text(LocalizedString.commonToday.localized)
                .font(.system(size: 11.5, weight: .bold))
                .foregroundStyle(
                    LinearGradient(
                        colors: [theme.primary, theme.secondary],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .lineLimit(1)

            if !activeIdxs.isEmpty {
                // 1. показываем все активные (до лимита)
                let activeToShow = Array(activeIdxs.prefix(maxRowsTotal))
                ForEach(activeToShow, id: \.self) { idx in
                    FocusEventRow(
                        event: events[idx],
                        theme: theme,
                        showOnline: entry.shouldShowOnline
                    )
                }

                // 2. будущие пары после последней активной
                let lastActive = activeIdxs.max()!
                let future = Array(events.suffix(from: lastActive + 1))

                let remainingSlots = max(0, maxRowsTotal - activeToShow.count)
                let futureToShow = Array(future.prefix(remainingSlots))

                if !futureToShow.isEmpty {
                    VStack(alignment: .leading, spacing: 3) {
                        ForEach(futureToShow) { ev in
                            CompactEventRow(
                                event: ev,
                                theme: theme,
                                showOnline: entry.shouldShowOnline
                            )
                        }
                    }
                    .padding(.top, 3)
                }

                // 3. +N (непоместившиеся активные + непоместившиеся будущие)
                let hiddenActive = max(0, activeIdxs.count - activeToShow.count)
                let hiddenFuture = max(0, future.count - futureToShow.count)
                let hidden = hiddenActive + hiddenFuture

                if hidden > 0 {
                    Text("+\(hidden)")
                        .font(.system(size: 10.5, weight: .semibold))
                        .foregroundColor(.secondary)
                        .padding(.top, 2)
                        .padding(.bottom, 4)
                }

            } else {
                // нет активных прямо сейчас:
                // берём текущую (если идёт) или ближайшую будущую
                let focus = entry.currentEvent ?? events.first { ev in
                    (ev.startDate ?? .distantPast) >= now
                }

                if let f = focus {
                    FocusEventRow(
                        event: f,
                        theme: theme,
                        showOnline: entry.shouldShowOnline
                    )

                    // остальные будущие после фокуса
                    if let idx = events.firstIndex(where: { $0.id == f.id }) {
                        let future = Array(events.suffix(from: idx + 1))
                        let othersToShow = Array(future.prefix(maxRowsTotal - 1))

                        if !othersToShow.isEmpty {
                            VStack(alignment: .leading, spacing: 3) {
                                ForEach(othersToShow) { ev in
                                    CompactEventRow(
                                        event: ev,
                                        theme: theme,
                                        showOnline: entry.shouldShowOnline
                                    )
                                }
                            }
                            .padding(.top, 3)
                        }

                        let hidden = max(0, future.count - othersToShow.count)
                        if hidden > 0 {
                            Text("+\(hidden)")
                                .font(.system(size: 10.5, weight: .semibold))
                                .foregroundColor(.secondary)
                                .padding(.top, 3)
                        }
                    }

                } else {
                    // вообще нет пар
                    HStack(spacing: 6) {
                        Image(systemName: "zzz")
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundColor(.secondary)

                        Text(LocalizedString.commonNoClassesToday.localized)
                            .font(.system(size: 11.5, weight: .medium))
                            .foregroundColor(.secondary)
                            .lineLimit(2)
                            .minimumScaleFactor(0.7)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }
            }
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 10)
    }
}

/// Активная пара (подсветка слева вертикальной палкой цвета типа пары)
private struct FocusEventRow: View {
    let event: ScheduleEvent
    let theme: any Theme
    let showOnline: Bool

    var body: some View {
        let barColor = eventAccentColor(for: event, theme: theme)

        HStack(alignment: .top, spacing: 6) {
            // палка слева
            Capsule()
                .fill(barColor)
                .frame(width: 3, height: 25)
                .padding(.top, 2)

            // инфо слева (аббревиатура + аудитория или wifi)
            VStack(alignment: .leading, spacing: 1) {
                Text(eventAbbreviation(from: event.title))
                    .font(.system(size: 13, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.6)
                    .allowsTightening(true)

                if showOnline && event.isOnline() {
                    Image(systemName: "wifi")
                        .font(.system(size: 8))
                        .foregroundColor(theme.online)
                } else if !event.displayRoom.isEmpty {
                    Text(event.displayRoom)
                        .font(.system(size: 10))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.6)
                        .allowsTightening(true)
                }
            }

            Spacer(minLength: 4)

            // время справа
            VStack(alignment: .trailing, spacing: 0) {
                if let s = event.startDate {
                    Text(s, style: .time)
                        .font(.system(size: 13, weight: .semibold))
                        .monospacedDigit()
                        .foregroundColor(.primary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.7)
                        .allowsTightening(true)
                }
                if let e = event.endDate {
                    Text(e, style: .time)
                        .font(.system(size: 10))
                        .monospacedDigit()
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.7)
                        .allowsTightening(true)
                }
            }
            .frame(minWidth: 46, idealWidth: 52, maxWidth: 60, alignment: .trailing)
        }
    }
}

/// Небольшая строка будущей пары
private struct CompactEventRow: View {
    let event: ScheduleEvent
    let theme: any Theme
    let showOnline: Bool

    var body: some View {
        let dotColor = eventAccentColor(for: event, theme: theme)

        HStack(spacing: 4) {
            if showOnline && event.isOnline() {
                Image(systemName: "wifi")
                    .font(.system(size: 8))
                    .foregroundColor(theme.online)
            } else {
                Circle()
                    .fill(dotColor)
                    .frame(width: 4, height: 4)
            }

            Text(eventAbbreviation(from: event.title))
                .font(.system(size: 11.5, weight: .semibold))
                .foregroundColor(.primary)
                .lineLimit(1)
                .minimumScaleFactor(0.6)
                .allowsTightening(true)
                .layoutPriority(1)

            Spacer(minLength: 2)

            if let s = event.startDate {
                Text(s, style: .time)
                    .font(.system(size: 11, weight: .medium))
                    .monospacedDigit()
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.7)
                    .allowsTightening(true)
                    .frame(minWidth: 38, alignment: .trailing)
            }
        }
    }
}

// MARK: - MEDIUM

/// Medium: окно из максимум 5 строк.
/// Если есть несколько активных пар → все активные подсвечиваются.
/// Старые пары схлопываются вверх в "+N", будущие хвосты — вниз в "+N".
struct MediumWidgetView: View {
    let entry: TimetableWidgetEntry

    @Environment(\.colorScheme) var colorScheme
    private var theme: any Theme {
        ThemeFactory.theme(withId: entry.selectedThemeId, for: colorScheme)
    }

    // компактная палка слева у выделенных пар
    private let barHeight: CGFloat = 12
    private let barWidth: CGFloat = 2

    var body: some View {
        // 1. убираем отменённые пары
        let eventsAll = entry.todayEvents.filter { !$0.isCancelled() }
        let now = entry.date

        // 2. пары, которые ИДУТ прямо сейчас (now внутри [start,end])
        let activeNowIdxs: [Int] = eventsAll.enumerated().compactMap { idx, ev in
            guard let s = ev.startDate, let e = ev.endDate else { return nil }
            return (now >= s && now <= e) ? idx : nil
        }

        // 3. пары, которые ЕЩЁ НЕ начались (start > now)
        //    найдём ближайшее будущее start и возьмём все пары с таким же start
        let futureIdxsByStart: [Int] = {
            // соберём (idx, start) только для будущих
            let futurePairs: [(Int, Date)] = eventsAll.enumerated().compactMap { idx, ev in
                guard let s = ev.startDate else { return nil }
                return (s > now) ? (idx, s) : nil
            }

            guard !futurePairs.isEmpty else { return [] }

            // самое раннее будущее время старта
            let earliestStart = futurePairs.map { $0.1 }.min()!

            // все пары, которые стартуют ровно в earliestStart
            let sameSlotIdxs = futurePairs
                .filter { $0.1 == earliestStart }
                .map { $0.0 }

            return sameSlotIdxs.sorted()
        }()

        // 4. кого будем ПОДСВЕЧИВАТЬ (activeSet):
        //    - если прямо сейчас есть пары -> их
        //    - иначе если сейчас перемена, но есть будущие пары -> ближайший слот (все пары с earliestStart)
        //    - иначе (день кончился) -> никого
        let highlightedIdxs: [Int] = {
            if !activeNowIdxs.isEmpty {
                return activeNowIdxs.sorted()
            } else if !futureIdxsByStart.isEmpty {
                return futureIdxsByStart
            } else {
                return []
            }
        }()
        let activeSet = Set(highlightedIdxs)

        // 5. какой индекс считать "фокусом" для окна:
        //    - если кого-то подсвечиваем → минимальный из них
        //    - иначе день уже прошёл → последняя пара дня (если есть)
        let focusIdx: Int? = {
            if let firstHighlighted = highlightedIdxs.min() {
                return firstHighlighted
            } else if !eventsAll.isEmpty {
                // день закончился, подсветки не будет,
                // но окно хотим прижать к концу дня
                return eventsAll.count - 1
            } else {
                return nil
            }
        }()

        // 6. рассчитываем "окно" (макс 5 строк) вокруг фокуса / выделенных
        //    важно: в computeWindowMultiActive мы передаём highlightedIdxs,
        //    НЕ activeNowIdxs, чтобы во время перемены окно центрировалось
        //    вокруг ближайшего будущего слота.
        let window = computeWindowMultiActive(
            events: eventsAll,
            activeIdxs: highlightedIdxs,
            focusIdx: focusIdx,
            maxVisible: 5
        )

        let visibleEvents = window.visible
        let startIndex    = window.startIndex

        return VStack(alignment: .leading, spacing: 5) {

            // HEADER
            HStack(spacing: 6) {
                Text(LocalizedString.commonToday.localized)
                    .font(.system(size: 14.5, weight: .bold))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [theme.primary, theme.secondary],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .lineLimit(1)

                Spacer()

                Text(entry.date, style: .date)
                    .font(.system(size: 10.5))
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }

            if eventsAll.isEmpty {
                noEventsView
            } else {
                VStack(alignment: .leading, spacing: 2.5) {

                    // +N сверху, если мы порезали прошедшие пары
                    if window.hiddenBefore > 0 {
                        Text("+\(window.hiddenBefore) \(LocalizedString.commonMoreSuffix.localized)")
                            .font(.system(size: 9.5))
                            .foregroundColor(.secondary)
                    }

                    // сами пары
                    ForEach(Array(visibleEvents.enumerated()), id: \.offset) { offset, ev in
                        let globalIndex = startIndex + offset
                        let isHighlighted = activeSet.contains(globalIndex)

                        eventRow(ev, highlight: isHighlighted)
                    }

                    // +N снизу, если мы порезали хвост
                    if window.hiddenAfter > 0 {
                        Text("+\(window.hiddenAfter) \(LocalizedString.commonMoreSuffix.localized)")
                            .font(.system(size: 9.5))
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
        .padding(.vertical, 6.5)
        .padding(.horizontal, 10)
    }

    // MARK: - Рендер строки пары

    private func eventRow(_ event: ScheduleEvent, highlight: Bool) -> some View {
        let barColor = eventAccentColor(for: event, theme: theme)

        return HStack(alignment: .center, spacing: 5) {
            // палка слева, если выделено (активно сейчас или ближайший слот в перемене)
            if highlight {
                Capsule()
                    .fill(barColor)
                    .frame(width: barWidth, height: barHeight)
                    .fixedSize()
            } else {
                Color.clear
                    .frame(width: barWidth, height: barHeight)
                    .fixedSize()
            }

            HStack(spacing: 4) {
                // время (start-end)
                Text(timeRange(event.startDate, event.endDate))
                    .font(.system(size: 11.5, weight: .semibold))
                    .monospacedDigit()
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.9)

                // аббревиатура дисциплины
                Text(eventAbbreviation(from: event.title))
                    .font(.system(size: 11.5, weight: .medium))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.85)

                // аудитория, если оффлайн
                if !event.displayRoom.isEmpty {
                    Text(event.displayRoom)
                        .font(.system(size: 10))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.85)
                }

                Spacer(minLength: 0)

                // Wi-Fi если пара онлайн и пользователь не выключил
                if entry.shouldShowOnline && event.isOnline() {
                    Image(systemName: "wifi")
                        .font(.system(size: 9.5))
                        .foregroundColor(theme.online)
                }
            }
        }
    }

    // MARK: - "Нет занятий"
    private var noEventsView: some View {
        HStack(spacing: 7) {
            Image(systemName: "calendar.badge.checkmark")
                .font(.system(size: 19))
                .foregroundStyle(
                    LinearGradient(
                        colors: [theme.primary, theme.secondary],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )

            VStack(alignment: .leading, spacing: 1) {
                Text(LocalizedString.commonNoClassesToday.localized)
                    .font(.system(size: 12.5, weight: .medium))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)

                Text(LocalizedString.commonEnjoyFreeDay.localized)
                    .font(.system(size: 10.5))
                    .foregroundColor(.secondary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    // MARK: - Окно показа (как и раньше)

    private func computeWindowMultiActive(
        events: [ScheduleEvent],
        activeIdxs: [Int],
        focusIdx: Int?,
        maxVisible: Int
    ) -> (
        visible: [ScheduleEvent],
        startIndex: Int,
        hiddenBefore: Int,
        hiddenAfter: Int
    ) {
        guard !events.isEmpty else {
            return ([], 0, 0, 0)
        }

        let total = events.count

        if !activeIdxs.isEmpty {
            // у нас есть набор индексов, которые хотим держать в кадре (либо реально активные, либо ближайший слот после перемены)
            let minA = activeIdxs.min()!
            let maxA = activeIdxs.max()!
            let spanCount = maxA - minA + 1

            var start: Int
            var endExclusive: Int

            if spanCount >= maxVisible {
                // сам диапазон не влезает целиком → обрезаем его с головы
                start = minA
                endExclusive = min(total, start + maxVisible)
            } else {
                // пробуем показать одну предыдущую пару (если есть) + наш диапазон + добить будущими
                start = max(0, minA - 1)
                endExclusive = start + maxVisible

                // если в это окно не помещается весь span → сдвигаем старт так, чтобы поместился хвост
                if endExclusive < maxA + 1 {
                    start = max(0, (maxA + 1) - maxVisible)
                    endExclusive = min(total, start + maxVisible)
                }

                // если уехали слишком вниз, корректируем
                if endExclusive > total {
                    endExclusive = total
                    start = max(0, endExclusive - maxVisible)
                }
            }

            let vis = Array(events[start..<endExclusive])
            let hiddenBefore = max(0, start)
            let hiddenAfter = max(0, total - endExclusive)
            return (vis, start, hiddenBefore, hiddenAfter)

        } else {
            // день уже закончился: нет активных сейчас и нет будущих
            // просто показываем хвост дня вокруг focusIdx (который = последняя пара)
            let focus = focusIdx ?? 0
            var start = max(0, focus - 1)
            var endExclusive = min(total, start + maxVisible)

            if (endExclusive - start) < maxVisible && endExclusive < total {
                start = max(0, total - maxVisible)
                endExclusive = min(total, start + maxVisible)
            }

            let vis = Array(events[start..<endExclusive])
            let hiddenBefore = max(0, start)
            let hiddenAfter = max(0, total - endExclusive)
            return (vis, start, hiddenBefore, hiddenAfter)
        }
    }
}

// MARK: - LARGE (неделя)

/// Large: неделя.
/// Если дней >=4 (или 3 дня, но перегружены) — рисуем двухколоночную сетку:
/// каждая строка = два дня слева/справа, выравниваем по верху.
/// Внутри дня:
///  - время не сжимается,
///  - название может сжаться,
///  - аудитория может сжаться сильнее,
///  - Wi-Fi для онлайна.
/// Пары с isCancelled() вообще не показываем.
struct LargeWidgetView: View {
    let entry: TimetableWidgetEntry

    @Environment(\.colorScheme) var colorScheme
    private var theme: any Theme {
        ThemeFactory.theme(withId: entry.selectedThemeId, for: colorScheme)
    }

    var body: some View {
        let calendar = Calendar.current

        // сортируем дни недели
        let orderedDays = entry.weekEvents.keys.sorted {
            weekdayRank($0, calendar: calendar) < weekdayRank($1, calendar: calendar)
        }

        let dayCount = orderedDays.count
        let eventsByDay = entry.weekEvents

        // максимум пар в дне
        let maxPerDay = orderedDays
            .map { (eventsByDay[$0]?.count ?? 0) }
            .max() ?? 0

        // решаем, нужен ли двухколоночный режим
        let useGrid = (dayCount >= 4) || (dayCount == 3 && maxPerDay >= 5)

        return VStack(alignment: .leading, spacing: 6) {

            // HEADER недели
            HStack {
                Text(LocalizedString.commonThisWeek.localized)
                    .font(.system(size: 17, weight: .bold))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [theme.primary, theme.secondary],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )

                Spacer()

                let weekNum = calendar.component(.weekOfYear, from: entry.date)
                Text("\(LocalizedString.commonWeek.localized) \(weekNum)")
                    .font(.system(size: 11))
                    .foregroundColor(.secondary)
            }

            if dayCount == 0 {
                // Неделя пустая
                Spacer()
                Text("\(LocalizedString.commonNoClasses.localized) \(LocalizedString.commonThisWeek.localized.lowercased())")
                    .font(.system(size: 13.5))
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .center)
                Spacer()

            } else if useGrid {
                // Двухколоночный режим
                let splitIndex = gridSplitIndex(for: dayCount)
                let leftDays  = Array(orderedDays.prefix(splitIndex))
                let rightDays = Array(orderedDays.dropFirst(splitIndex))
                let rows = max(leftDays.count, rightDays.count)

                VStack(alignment: .leading, spacing: 6) {
                    ForEach(0..<rows, id: \.self) { i in
                        HStack(alignment: .top, spacing: 8) {
                            // левая колонка
                            if i < leftDays.count,
                               let evs = entry.weekEvents[leftDays[i]] {
                                DaySectionCompactView(
                                    date: leftDays[i],
                                    events: evs,
                                    theme: theme,
                                    showOnline: entry.shouldShowOnline
                                )
                                .frame(maxWidth: .infinity, alignment: .leading)
                            } else {
                                Color.clear
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }

                            // правая колонка
                            if i < rightDays.count,
                               let evs = entry.weekEvents[rightDays[i]] {
                                DaySectionCompactView(
                                    date: rightDays[i],
                                    events: evs,
                                    theme: theme,
                                    showOnline: entry.shouldShowOnline
                                )
                                .frame(maxWidth: .infinity, alignment: .leading)
                            } else {
                                Color.clear
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                        }
                    }
                }

            } else {
                // Вертикальный режим (мало учебных дней)
                ForEach(orderedDays, id: \.self) { day in
                    if let events = entry.weekEvents[day] {
                        DaySectionView(
                            date: day,
                            events: events,
                            theme: theme,
                            showOnline: entry.shouldShowOnline
                        )
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 9)
    }
}

/// как разделить дни на левую/правую колонну
private func gridSplitIndex(for daysCount: Int) -> Int {
    switch daysCount {
    case 6: return 3      // 3+3
    case 5: return 3      // 3+2
    case 4: return 2      // 2+2
    case 3: return 2      // 2+1
    case 2: return 1      // 1+1
    default:
        return Int(ceil(Double(daysCount) / 2.0))
    }
}

/// Компактный блок дня для сетки (2 колонки)
private struct DaySectionCompactView: View {
    let date: Date
    let events: [ScheduleEvent]
    let theme: any Theme
    let showOnline: Bool

    var body: some View {
        // не показываем отменённые пары
        let filtered = events.filter { !$0.isCancelled() }

        return VStack(alignment: .leading, spacing: 2.5) {
            // заголовок дня
            HStack(spacing: 4) {
                Text(date, format: .dateTime.weekday(.abbreviated))
                    .font(.system(size: 10, weight: .semibold))
                    .foregroundColor(
                        Calendar.current.isDateInToday(date)
                        ? theme.accent
                        : .primary
                    )

                Text(date, format: .dateTime.day())
                    .font(.system(size: 9.5))
                    .foregroundColor(.secondary)

                Spacer(minLength: 0)
            }

            // максимум 5 пар
            ForEach(filtered.prefix(5)) { ev in
                let color = eventAccentColor(for: ev, theme: theme)

                HStack(spacing: 3.5) {
                    // точка по цвету типа пары
                    Circle()
                        .fill(color)
                        .frame(width: 3, height: 3)

                    // ВРЕМЯ — не сжимать
                    Text(timeRange(ev.startDate, ev.endDate))
                        .font(.system(size: 10, weight: .semibold))
                        .monospacedDigit()
                        .foregroundColor(.primary)
                        .lineLimit(1)
                        .minimumScaleFactor(1.0)
                        .layoutPriority(2)

                    // НАЗВАНИЕ — можно ужать
                    Text(eventAbbreviation(from: ev.title))
                        .font(.system(size: 10))
                        .foregroundColor(.primary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.8)
                        .allowsTightening(true)
                        .layoutPriority(1)

                    // АУДИТОРИЯ — самая низкая важность (сжимается сильнее)
                    if !ev.displayRoom.isEmpty {
                        Text(ev.displayRoom)
                            .font(.system(size: 9))
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                            .minimumScaleFactor(0.5)
                            .allowsTightening(true)
                            .layoutPriority(0)
                    }

                    Spacer(minLength: 0)

                    // Wi-Fi если онлайн
                    if showOnline && ev.isOnline() {
                        Image(systemName: "wifi")
                            .font(.system(size: 8.5))
                            .foregroundColor(theme.online)
                    }
                }
            }

            if filtered.count > 5 {
                Text("+\(filtered.count - 5)")
                    .font(.system(size: 9.5, weight: .semibold))
                    .foregroundColor(.secondary)
            }
        }
    }
}

/// Вертикальная секция дня, если дней <=3 (не сетка)
private struct DaySectionView: View {
    let date: Date
    let events: [ScheduleEvent]
    let theme: any Theme
    let showOnline: Bool

    var body: some View {
        let filtered = events.filter { !$0.isCancelled() }

        return VStack(alignment: .leading, spacing: 4) {

            // заголовок дня
            HStack(spacing: 5) {
                Text(date, format: .dateTime.weekday(.abbreviated))
                    .font(.system(size: 11.5, weight: .semibold))
                    .foregroundColor(
                        Calendar.current.isDateInToday(date)
                        ? theme.accent
                        : .primary
                    )

                Text(date, format: .dateTime.day())
                    .font(.system(size: 10.5))
                    .foregroundColor(.secondary)

                Spacer()

                Text("\(filtered.count) \(LocalizedString.commonClasses.localized)")
                    .font(.system(size: 9.5))
                    .foregroundColor(.secondary)
            }

            // максимум 5 пар
            ForEach(filtered.prefix(5)) { ev in
                let color = eventAccentColor(for: ev, theme: theme)

                HStack(spacing: 5) {
                    Circle()
                        .fill(color)
                        .frame(width: 4, height: 4)

                    // ВРЕМЯ — фиксировано читаемое, не сжимать
                    Text(timeRange(ev.startDate, ev.endDate))
                        .font(.system(size: 11, weight: .semibold))
                        .monospacedDigit()
                        .foregroundColor(.primary)
                        .lineLimit(1)
                        .minimumScaleFactor(1.0)
                        .layoutPriority(2)

                    // НАЗВАНИЕ — средний приоритет
                    Text(eventAbbreviation(from: ev.title))
                        .font(.system(size: 11))
                        .foregroundColor(.primary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.8)
                        .allowsTightening(true)
                        .layoutPriority(1)

                    // АУДИТОРИЯ — можно ужать
                    if !ev.displayRoom.isEmpty {
                        Text(ev.displayRoom)
                            .font(.system(size: 10))
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                            .minimumScaleFactor(0.5)
                            .allowsTightening(true)
                            .layoutPriority(0)
                    }

                    Spacer(minLength: 0)

                    if ev.isOnline() {
                        Image(systemName: "wifi")
                            .font(.system(size: 9.5))
                            .foregroundColor(theme.online)
                    }
                }
            }

            if filtered.count > 5 {
                Text("+\(filtered.count - 5)")
                    .font(.system(size: 10, weight: .semibold))
                    .foregroundColor(.secondary)
            }
        }
    }
}


//// MARK: - Превью (Large, 3×5 и 3×6)
//
//#if DEBUG
//#Preview("Large – 3 days × 5", as: .systemLarge) {
//    TimetableWidget()
//} timeline: {
//    TestData.makeEntry(days: 4, perDay: 5)
//}
//
//#Preview("Large – 3 days × 6", as: .systemLarge) {
//    TimetableWidget()
//} timeline: {
//    TestData.makeEntry(days: 4, perDay: 6)
//}
//
//// MARK: - Preview Mocks (type-checker friendly)
//
//enum TestData {
//    // Календарь/временные константы вынесены и типизированы
//    private static let cal: Calendar = {
//        var c = Calendar(identifier: .gregorian)
//        c.locale = Locale(identifier: "en_US_POSIX")
//        c.timeZone = .current
//        return c
//    }()
//
//    private static let slot: TimeInterval = 75 * 60 // 75 минут пара
//
//    // Один форматтер на все
//    private static let iso: ISO8601DateFormatter = {
//        let f = ISO8601DateFormatter()
//        f.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
//        f.timeZone = .current
//        return f
//    }()
//
//    // Разбиваем большие литералы на батчи — так превью не «подменяет» одну огромную строку
//    private static let titles: [String] = {
//        var out: [String] = []
//        out += ["PGD", "HMWIA", "WDGS"]
//        out += ["PPP", "KP1", "UED"]
//        out += ["PR", "PPG", "PJFIP"]
//        out += ["ALG", "DB"]
//        return out
//    }()
//
//    private static let rooms: [String] = {
//        var out: [String] = []
//        out += ["S55 106", "S55 107", "S47 119"]
//        out += ["S47 216", "S47 314", "S55 308"]
//        return out
//    }()
//
//    // Понедельник текущей недели
//    private static func mondayOfCurrentWeek(_ date: Date = .now) -> Date {
//        let comps = cal.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)
//        return cal.date(from: comps) ?? date
//    }
//
//    // MARK: - Schedule factory (под твою модель)
//
//    static func buildPreviewSchedule(
//        days: Int,
//        perDay: Int,
//        startHour: Int = 8,
//        includeOnline: Bool = true
//    ) -> GroupScheduleResponse {
//        var events: [ScheduleEvent] = []
//        events.reserveCapacity(max(0, min(days, 7) * perDay))
//
//        let weekStart: Date = mondayOfCurrentWeek()
//
//        for d in 0..<min(days, 7) {
//            guard
//                let day = cal.date(byAdding: .day, value: d, to: weekStart),
//                let dayStart = cal.date(bySettingHour: startHour, minute: 0, second: 0, of: day)
//            else { continue }
//
//            for i in 0..<perDay {
//                let start: Date = dayStart.addingTimeInterval(TimeInterval(i) * slot)
//                let end: Date   = start.addingTimeInterval(slot)
//
//                let title: String = titles[(d + i) % titles.count]
//                let room: String  = rooms[(d * 2 + i) % rooms.count]
//                let type: String  = (i % 3 == 0) ? "lecture" : ((i % 3 == 1) ? "exercise" : "laboratory")
//                let online: Bool  = includeOnline && (i % 4 == 3)
//
//                // Конструктор строго под твою модель ScheduleEvent
//                let ev = ScheduleEvent(
//                    title: title,
//                    type: type,
//                    startISO: iso.string(from: start),
//                    endISO: iso.string(from: end),
//                    room: online ? "" : room,          // если online, комнаты нет
//                    grading: nil,
//                    remarks: online ? "online" : nil,  // помечаем online для иконки Wi-Fi
//                    studyTrack: nil,
//                    groups: nil,
//                    teacherId: 1,
//                    teacherName: "Dr. Novak",
//                    teacherEmail: nil,
//                    startDate: start,
//                    endDate: end
//                )
//                events.append(ev)
//            }
//        }
//
//        // Оставь ровно тот init, который есть у тебя в проекте.
//        // Если у тебя именно такой — будет работать из коробки:
//        return GroupScheduleResponse(
//            groupId: 2345,
//            from: "2025-09-01",
//            to: "2026-01-31",
//            intervalType: 1,
//            groupSchedule: events,
//            fetchedAt: "2025-10-25T00:00:00Z"
//        )
//        // Если у тебя другой init, замени на свой, но оставь events как есть.
//    }
//
//    // MARK: - Entry builder
//
//    static func makeEntry(days: Int, perDay: Int) -> TimetableWidgetEntry {
//        let schedule: GroupScheduleResponse = buildPreviewSchedule(days: days, perDay: perDay)
//        return TimetableWidgetEntry(
//            date: .now,
//            schedule: schedule,
//            selectedThemeId: "default",
//            appearanceMode: "system",
//            configuration: nil
//        )
//    }
//}
//#endif

// ===== FILE: TimetableWidget/WidgetConfigurationIntent.swift =====
import AppIntents
import WidgetKit

struct ConfigurationAppIntent: WidgetConfigurationIntent { // fixnik
    static var title: LocalizedStringResource = "Timetable"
    static var description: IntentDescription = IntentDescription("Configure your timetable widget")

//    @Parameter(title: "View", default: .today)
//    var viewType: WidgetViewType

    @Parameter(title: "Show online status", default: true)
        var showOnlineStatus: Bool
}

//enum WidgetViewType: String, AppEnum {
//    case today
//    case week
//
//    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "View")
//
//    static var caseDisplayRepresentations: [WidgetViewType: DisplayRepresentation] = [
//        .today: DisplayRepresentation(title: "Today"),
//        .week:  DisplayRepresentation(title: "Week")
//    ]
//}
